<?xml version="1.0" encoding="UTF-8"?>
<data>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/learn-magento-before-use-archive/]]></link>
		<title><![CDATA[了解 Magento]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>您可能希望在使用 Magento 之前，先了解下 Magento 怎么样？他有哪些功能，和其他系统相比如何？</p> <p>下面的文章可能会帮助你更了解 Magento，文章或是翻译，或是博主自己的看法，请各位自行判断。欢迎留言。</p> <p><a href="/bibi-ecommerce-platform/" target="_blank">漫谈网上商城系统——从技术角度进行比较</a></p> <p><a href="/magento_in_my_eyes/" target="_blank">Magento 之我见</a></p> <p><a href="/new-era-commerce-innovation/" target="_blank">商业创新的新时代(翻译)</a></p> <p><a href="/magento-2-goals/" target="_blank">Magento 2 Goals （翻译）</a></p> <p><a href="/magento-feature-list-chinese-1/" target="_blank">Magento 基本功能列表（翻译一）</a></p> <p><a href="/magento-feature-list-chinese-2/" target="_blank">Magento 基本功能列表（翻译二）</a></p> <p><a href="/magento-feature-list-chinese-3/" target="_blank">Magento 基本功能列表（翻译三）</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-%E4%B8%AD%E6%96%87%E5%8C%96%E4%B8%8E-language-package%EF%BC%88%E5%8E%9F%E5%88%9B%EF%BC%89/]]></link>
		<title><![CDATA[Magento 2 中文化与 language package（原创）]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em>转载请注明出处</em></p> <p>关于 Magento 2 的中文化，之前博主已经写过三篇文章，感兴趣的请参阅本文的相关阅读部分。</p> <p>下面我们来回顾一下。</p> <h2 id="回顾"><a href="#回顾" name="回顾"></a>回顾</h2> <p>首先是设置问题。<br /> 前台设置，<em>Stores &gt; Configuration &gt; General &gt; Local</em> 中设置 Local 为 Chinese（China）<br /> 账户设置，后台你的账户 <em>Account Setting &gt; Interface Local 中设置 Interface Local</em> 为 Chinese（China）</p> <p>Magento 2 的 component 有三种，module、theme、language package。</p> <p>module 和 theme 中都有 <code>i18n</code> ，只要把 zh_Hans_CN.csv 放进去就可以了。module 中 <code>i18n</code> 下的翻译文件会被应用到前台和后台（假设你前后台都是简体中文的话），但是 theme 中的翻译只会被应用到前台。</p> <p>提取的 csv 有四列，但是其实只有前两列有用。重复的字段，实际使用的是最后一个翻译值。</p> <p>之前的文章博主教大家的方法是，寻找 Magento 自带的 language package。这个有一些局限性。</p> <p>主要问题就在于，假如我们采用命令行的方式更新，那么文件会被退回到初始状态，我们放进去的 zh_Hans_CN 会被丢掉。</p> <p>所以更妥当的做法是，我们建一个自己的 language package，或者下载一个，然后放到 app/i18n 下面。</p> <h2 id="如何创建-language-package"><a href="#如何创建-language-package" name="如何创建-language-package"></a>如何创建 language package</h2> <p>以创建中文包为例，但是方法是通用的。</p> <p>我们在 app/i18n 下创建一个文件夹 <code>ThankIT</code> ，在 <code>ThankIT</code> 下创建 <code>zh_Hans_CN</code>，然后在创建以下文件</p> <h4 id="composer.json"><a href="#composer.json" name="composer.json"></a>composer.json</h4> <pre><code>{     "name": "thankit/language-zh_hans_cn",     "description": "Chinese (China) language",     "version": "100.3.0-dev",     "license": [         "OSL-3.0",         "AFL-3.0"     ],     "require": {         "magento/framework": "100.3.*"     },     "type": "magento2-language",     "autoload": {         "files": [             "registration.php"         ]     } } </code></pre> <h4 id="language.xml"><a href="#language.xml" name="language.xml"></a>language.xml</h4> <pre><code>&lt;?xml version="1.0"?&gt; &lt;language xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/Language/package.xsd"&gt;     &lt;code&gt;zh_Hans_CN&lt;/code&gt;     &lt;vendor&gt;ThankIT&lt;/vendor&gt;     &lt;package&gt;zh_Hans_CN&lt;/package&gt; &lt;/language&gt; </code></pre> <h4 id="registration.php"><a href="#registration.php" name="registration.php"></a>registration.php</h4> <pre><code>&lt;?php \Magento\Framework\Component\ComponentRegistrar::register(     \Magento\Framework\Component\ComponentRegistrar::LANGUAGE,     'thankit_zh_hans-cn',     __DIR__ ); </code></pre> <p>最后把之前的 <code>zh_Hans_CN.csv</code> 放进去，齐活。<br /> 正确设置，并使用命令行：</p> <pre><code>php bin/magento setup:static-content:deploy </code></pre> <p>然后就可以看到效果了。</p> <h2 id="常见问题"><a href="#常见问题" name="常见问题"></a>常见问题</h2> <p>经常有人说安装中文包以后出错了，这通常是因为你的 <code>zh_Hans_CN.csv</code> 中含有空行，特别是在结尾的部分，有时候是提供安装包的人不小心干的，有时候是自己不小心干的。</p> <h2 id="福利"><a href="#福利" name="福利"></a>福利</h2> <p>上面的 package 上传到 github 了，可以自己下载，然后放到 app/i18n 目录下。</p> <p><a href="https://github.com/PiscesThankIT/language-zh-hans-cn">PiscesThankIT/language-zh-hans-cn</a></p> <p>另外放一个台湾繁体的。由于繁体的官方的翻译比率太低，所以，博主拿简体中文转化成了繁体中文，翻译比率大概是 88%。</p> <p><a href="https://github.com/PiscesThankIT/language-zh-hant-tw">PiscesThankIT/language-zh-hant-tw</a></p> <p><a href="https://github.com/Magento2Translations" target="_blank">Magento 2 Translations &#038; language packs （所有语言）</a></p> <p>如果你想修改翻译，请参考相关阅读部分。</p> <h2 id="相关阅读"><a href="#相关阅读" name="相关阅读"></a>相关阅读</h2> <p><a href="/magento-2-zh-hans-cn-csv/">Magento 2 中文化问题（原创）</a><br /> <a href="/how-to-update-csv-using-older-csv-file/">关于中文包的更新方法问题 （原创）</a><br /> <a href="/magento-csv-php-update/">中文包的更新方法问题（二）</a></p> <p>其他相关<br /> <a href="/magento-2-validation-js-bug-fix/">Magento 2.0/2.1 表单验证翻译 bug 修复</a><br /> <a href="/excel-csv-utf8/">Excel 编辑 csv 中文乱码</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-user-guide-contents/]]></link>
		<title><![CDATA[Magento 2 用户使用手册 目录索引]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em>前言：该目录索引记录了本网站内目前翻译出的文档结构，会不定期更新。后期有空的时候会增加目录树的展开收起，方便阅读。欢迎给我提建议。谢谢！</em></p> <pre><code>用户使用手册是非常详细的，翻译过程中有的地方博主都觉得太啰嗦了。但是我们要理解用户手册设计的目的，目的是当你在使用Magento 2的时候遇到问题，通过查手册就可以了解到详细内容，他实际上是一本说明书。说明书，你懂的，枯燥而且内容间的联系比较少，就算你把说明书全读一遍，还是会不明白怎么做。所以他不是很好的入门教程，他是遇到问题时的查询手册。当然，如果你有兴趣通读的话，也会有收获的。比如会发现Magento 的一些操作共性。 博主的翻译实际上根据自己需要来推进的，研究哪一部分，就会顺道翻译出来，所以整个文档的翻译完工日，是不确定的哦！╮(～▽～)╭ </code></pre> <ul> <li>Getting Started <ul> <li><a href="/configuration-basic/">基本设置 (Basic Configuration)</a> <ul> <li><a href="/admin/">管理后台 (Store Admin)</a> <ul> <li><a href="/admin-signin/">Admin 登录 (Admin Sign In)</a></li> <li><a href="/admin-account/">管理员账户 (Your Admin Account)</a></li> <li><a href="/admin-menu/">管理后台菜单 (Admin Sidebar)</a></li> <li><a href="/admin-workspace/">管理工具 (Admin Workspace)</a> <ul> <li><a href="/admin-dashboard/">控制面板 (Dashboard)</a></li> <li><a href="/admin-message-inbox/">后台消息收件箱 (Message Inbox)</a></li> <li><a href="/admin-global-search/">后台全局搜索 (Global Search)</a></li> <li><a href="/grid-controls/">表格控件 (Grid Controls)</a> <ul> <li><a href="/admin-grid-layout/">表格布局 (Grid Layout)</a></li> </ul> </li> <li><a href="/admin-actions-control/">操作控件 (Actions Control)</a></li> </ul> </li> </ul> </li> <li><a href="/store-details/">店铺详情 (Store Details)</a> <ul> <li><a href="/store-information/">店铺信息 (Store Information)</a></li> <li><a href="/locale-options/">区域设置选项 (Locale Options)</a></li> <li><a href="/state-options/">行政区域选项 (State Options)</a></li> <li><a href="/country-options/">国家选项 (Country Options)</a></li> <li><a href="/merchant-location/">商户位置 (Merchant Location)</a></li> <li><a href="/currency-overview/">货币 (Currency)</a></li> <li><a href="/store-email-addresses/">店铺邮箱 (Store Email Addresses)</a></li> <li><a href="/contact-us/">联系我们 (Contact Us)</a></li> </ul> </li> <li><a href="/storefront-branding/">店面品牌 (Storefront Branding)</a> <ul> <li><a href="/logo-upload/">上传您的 Logo (Uploading Your Logo)</a></li> <li><a href="/favicon/">上传 Favicon (Adding a Favicon)</a></li> <li><a href="/welcome-message/">欢迎信息 (Welcome Message)</a></li> <li><a href="/copyright-notice/">版权声明 (Copyright Notice)</a></li> <li><a href="/demo-notice/">店铺演示提示 (Store Demo Notice)</a></li> </ul> </li> <li><a href="/websites-stores-views/">网站(Websites), 店铺(Stores) 和 视图(Views)</a> <ul> <li><a href="/configuration-scope/">配置范围 (Scope)(out of date)</a></li> <li><a href="/store-mode-single/">单店模式 (Single Store Mode)</a></li> </ul> </li> <li>行业规范</li> </ul> </li> </ul> </li> <li>products <ul> <li><a href="/products-menu/">商品菜单 (Products Menu)</a> <ul> <li><a href="/catalog-workspace/">产品目录工作区 (Catalog Workspace)</a> <ul> <li><a href="/product-scope/">产品作用范围 (Product Scope)</a></li> </ul> </li> </ul> </li> <li><a href="/product-create/">创建商品 (Creating Products)</a> <ul> <li><a href="/catalog-urls/">目录 URL (Catalog URLs)</a> <ul> <li><a href="/catalog-urls-dynamic-media/">动态媒体网址 (Dynamic Media URLs)</a></li> </ul> </li> <li><a href="/product-workspace/">产品工作区 (Product Workspace)</a> <ul> <li><a href="/product-fields-autogenerated/">默认字段值 (Default Field Values)</a></li> </ul> </li> <li><a href="/product-types/">商品类型 (Product Types)</a></li> <li><a href="/product-create-simple/">简单商品 (Simple Product)</a></li> <li><a href="/product-create-configurable/">可配置商品 (Configurable Product)</a> <ul> <li><a href="/product-create-configurable-add-configurations">可配置商品添加配置项 (Adding Configurations)</a></li> </ul> </li> <li><a href="/product-create-grouped/">组合商品 (Grouped Product)</a></li> <li><a href="/product-create-virtual/">虚拟商品 (Virtual Product)</a></li> <li><a href="/product-create-bundle/">捆绑商品 (Bundle Product)</a></li> <li><a href="/product-create-downloadable/">可下载商品 (Downloadable Product)</a> <ul> <li><a href="/product-download-options/">配置下载选项 (Configuring Download Options)</a></li> </ul> </li> </ul> </li> <li><a href="/settings-basic/">基本设置 （Basic Settings）</a> <ul> <li><a href="/settings-basic-product-details/">商品详情（Product Details）</a></li> <li><a href="/settings-basic-image-management/">图像和视频（Images and Video）</a> <ul> <li><a href="/product-image-upload/">上传产品图片（Uploading Product Images）</a></li> <li><a href="/product-video/">添加产品视频 (Adding Product Video)</a></li> <li><a href="/media-gallery/">媒体库 (Media Gallery)</a></li> <li><a href="/product-image-placeholders/">占位图 (Placeholders)</a></li> <li><a href="/product-image-watermarks/">水印 (Watermarks)</a></li> <li><a href="/swatches/">色板 (Swatches)</a> <ul> <li><a href="/swatch-create/">创建色板 (Creating Swatches)</a></li> </ul> </li> </ul> </li> </ul> </li> <li>Product Settings</li> <li>Categories <ul> <li>Creating Categories <ul> <li><a href="/category-root/">根类别 (Root Categories)</a></li> </ul> </li> </ul> </li> <li>Attributes</li> </ul> </li> <li>Marketing <ul> <li>Communications <ul> <li><a href="/variables/">使用变量 (Using Variables)</a> <ul> <li><a href="/variables-predefined/">添加预定义的变量 (Adding Predefined Variables)</a></li> <li><a href="/variables-custom/">添加自定义变量 (Adding Custom Variables)</a></li> <li><a href="/markup-tags/">Markup Tags</a> <ul> <li><a href="/markup-tags-links/">在链接中使用 Markup Tags(Using Markup Tags in Links)</a></li> </ul> </li> <li><a href="/catalog-urls-dynamic-media/">动态媒体网址 (Dynamic Media URLs)</a></li> <li><a href="/variables-reference/">变量参考列表 (Variable Reference)</a></li> </ul> </li> </ul> </li> </ul> </li> <li>Content <ul> <li>Elements <ul> <li>Content Elements Menu <ul> <li><a href="/pages/">页面 Pages</a> <ul> <li><a href="/pages-core/">核心内容页 (Core Content Pages)</a> <ul> <li><a href="/pages-default/">默认页面 Default Pages</a></li> </ul> </li> <li><a href="/pages-workspace/">页面工作区 Page Workspace Controls</a> <ul> <li>Page Search</li> <li>Page Actions</li> <li>Grid Layout</li> </ul> </li> <li><a href="/page-add/">新增页面 (Adding a New Page)</a> <ul> <li><a href="/page-home-new/">更改首页 (Changing the Home Page)</a></li> </ul> </li> <li><a href="/media-storage/">媒体库 (Media Storage)</a></li> <li>Using the Editor <ul> <li>Inserting a Link</li> <li>Inserting an Image</li> <li>Inserting a Widget</li> <li>Inserting a Variable</li> <li>Configuring the Editor</li> </ul> </li> </ul> </li> <li><a href="/blocks/">Blocks</a> <ul> <li><a href="/block-add/">新增 Blocks (Adding New Blocks)</a> <ul> <li>Adding Social Plugins</li> <li>Adding a Lightbox or Slider</li> </ul> </li> <li><a href="/block-position/">定位 Blocks (Positioning Blocks)</a> <ul> <li><a href="/widget-static-block/">使用 widget (Using a Widget)</a></li> <li><a href="/layout-update-place-block/">Using a Layout Update</a></li> </ul> </li> </ul> </li> <li><a href="/widgets/">Widgets</a> <ul> <li><a href="/widget-types/">小部件类型 (Widgets Types)</a></li> <li><a href="/widget-create/">创建小部件 (Creating a Widget)</a> <ul> <li><a href="/widget-new-products-list/">新产品列表 (New Products List)</a></li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>Design &amp; Theme <ul> <li><a href="/design-menu/">Design Menu</a> <ul> <li><a href="/design-configuration/">Design Configuration</a></li> <li><a href="/page-setup/">Page Setup</a> <ul> <li>HTML Head</li> <li>Header</li> <li>Footer</li> </ul> </li> <li>Page Layout <ul> <li><a href="/standard-page-layouts/">Standard Block Layout</a></li> <li><a href="/page-layout-examples/">Storefront Examples</a></li> <li>Layout Updates (这一部分官方未更正)</li> </ul> </li> <li>Themes</li> <li>Scheduling Design Changes</li> </ul> </li> </ul> </li> </ul> </li> <li>Sales <ul> <li>Shipping <ul> <li><a href="/shipping-settings/">发货设置 (Shipping Settings)</a> <ul> <li><a href="/point-of-origin/">起点 (Point of Origin)</a></li> <li><a href="/shipping-multiaddress/">多个地址 (Multiple Addresses)</a></li> <li><a href="/shipping-policy-parameters/">发货条款 (Shipping Policy)</a></li> </ul> </li> <li><a href="/shipping-methods/">基本的送货方式 (Basic Shipping Methods)</a> <ul> <li><a href="/shipping-free/">包邮 (Free Shipping)</a></li> <li><a href="/shipping-flat-rate/">固定运费 (Flat Rate Shipping)</a></li> <li><a href="/shipping-table-rate/">表费率 (Table Rates)</a></li> <li><a href="/weight-dimensional/">体积重量 (Dimensional Weight)</a></li> </ul> </li> <li>Carriers <ul> <li><a href="/ups/">UPS</a></li> </ul> </li> <li>Shipping Labels <ul> <li><a href="/shipping-label-workflow/">Shipping Label Workflow</a></li> </ul> </li> </ul> </li> </ul> </li> </ul> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/web-fonts/]]></link>
		<title><![CDATA[Web 字体]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="web-安全字体"><a href="#web-安全字体" name="web-安全字体"></a>Web 安全字体</h2> <p>默认情形下，浏览器是以系统中已经安装的字体来进行渲染的。</p> <p>css 的 font-family 命令，指定了网页元素所使用的字体。下面是一个例子：</p> <pre><code>font-family: Georgia, "Times New Roman",              "Microsoft YaHei", "微软雅黑",              STXihei, "华文细黑",              serif; </code></pre> <p>它的规则有三条：</p> <ol> <li>优先使用排在前面的字体。</li> <li>如果找不到该种字体，或者该种字体不包括所要渲染的文字，则使用下一种字体。</li> <li>如果所列出的字体，都无法满足需要，则让操作系统自行决定使用哪种字体。</li> </ol> <p>但是世界上有那么多的系统，那么多版本，预装的字体也大不相同，如果让操作系统自行决定，可能结果不是很好看。所以，人们对主流个人计算机操作系统中的系统字体做了统计，选出最小公分母，也就是大家都有的字体，称之为 Web 安全字体。</p> <p>要了解 Web 安全字体，可以参阅 <a href="http://www.w3schools.com/cssref/css_websafe_fonts.asp" target="_blank">CSS Web Safe Font Combinations</a></p> <p>下面举一个例子：</p> <pre><code>font-family: Arial, Helvetica, sans-serif; </code></pre> <p>我们选择 Arial 作为首选字体（注：Arial 字体是最常用的 sans serif 字体，也是 Windows 的默认字体，当字体很小是不容易阅读），但是，苹果系统中没有这个字体，所以我们选择 Helvetica（和 Arial 很相似）作为第二备选字体，最后我们选择 sans-serif 作为第三备选字体，如果在一个既没有 Arial 也没有 Helvetica 的系统里，那么浏览器会使用默认的 sans-serif 字体来渲染文字。这样，我们很大程度上保证了使用不同操作系统的访问者都能看到相同（至少是类似）的页面文字。</p> <p>除了 Arial，常见的安全字体还有：</p> <ul> <li>Verdana 字体，它是微软公司的核心字体之一，专门为屏幕显示而开发的。它的应用广泛，宽度大而易于阅读，是显示器中最清晰的字体。CSS 写法：<code>font-family: Verdana, Geneva, sans-serif;</code></li> <li>Times New Roman 字体，它是最常用的 serif 字体，是浏览器默认的字体。小号字的易读性也很差。CSS 写法：<code>font-family: 'Times New Roman', Times, serif;</code></li> </ul> <p>以上说的这些其实是西文字体，对于中文字体，当然涉及到各类系统中中文字体的安装情况的一个统计，博主会另写一篇。</p> <p>安全字体显然是不够用的，所以也出现了一些通过图像，Adobe Flash或其他基于非文本的技术的解决办法。这里不做展开，但是这种方式的缺点很明显，就是它不是文本，不可以选择、这样就不能很好地被识别，翻译，供残疾人使用的设备访问。所以这种技术越来越被淘汰了。</p> <h2 id="@font-face"><a href="#@font-face" name="@font-face"></a>@font-face</h2> <p>他是 CSS3 的一项新特性，也不是什么新鲜技术，它最早出现在 CSS2 的规范定义中，但在 CSS2.1 中又被删除，现在正式列入 CSS3。目前主流的浏览器（IE 4+/Firefox 3.5+/Chrome 1+/Safari 3.1+/Opera 10+）都能够支持这个属性，所以不用担心会有浏览器兼容性问题。</p> <p>@font-face 允许您在网页中使用电脑中没有安装的字体，完全摆脱安全字体的限制。只需将字体包安装在服务器上，当用户加载网页时，字体包会自动下载到用户机器上，保证字体能够正确渲染。</p> <p>随着 @font-face 的不断流行，产生了许多新的字体格式图标集，称为网络字体。Google Fonts API 就是基于@font-face 的特性开发的一套优秀的网络字体库。</p> <p>网络字体的优点有很多：</p> <ul> <li>使用的是真正的文本，而不是图片，放大和缩小都不会影响渲染效果，用户体验好；</li> <li>可以被搜索引擎辨认；</li> <li>不像图片每次需要重新生成，添加删除更方便。</li> </ul> <p>这里先讲原理，首先，使用<code>@font-face</code>声明一个字体集，使用<code>font-family</code>描述符为它提供一个名称，然后使用<code>src</code>指向包含字体本身的文件：</p> <pre><code>@font-face {   font-family: 'Awesome Font';   src: url('awesome-font.ttf'); } </code></pre> <p>这里，通过链接到一个名为 <code>wesome-font.ttf</code> 的字体文件，定义了一个名为Awesome Font 的字体集。</p> <p>然后，在您的CSS中，使用 <code>font-family</code> 属性将该字体应用到一个 HTML 元素：</p> <pre><code>h1 {   font-family: 'Awesome Font'; } </code></pre> <p>但是，Web 字体具有许多不同的格式，并且各种 Web 浏览器支持这些格式的不同子集。</p> <p><img src="/wp-content/uploads/2016/11/web-fonts.jpg" alt="" class="img-responsive" /></p> <p>也就是说，为了支持所有的主流 Web 浏览器，一个 <code>@font-face</code> CSS 声明实际上无法像前面提到的那样那么简单：</p> <pre><code>@font-face {   font-family: 'Awesome Font';   src: url('awesome-font.ttf'); } </code></pre> <p>它应该是这样的：</p> <pre><code>@font-face {   font-family: 'Awesome Font';   src: url('awesome-font.eot'); /* IE9 Compat Modes */   src: url('awesome-font.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */        url('awesome-font.woff') format('woff'), /* Modern Browsers */        url('awesome-font.ttf')  format('truetype'), /* Safari, Android, iOS */        url('awesome-font.svg#svgFontName') format('svg'); /* Legacy iOS */ } </code></pre> <p>总结起来要点就是：</p> <ul> <li>将 WOFF 2.0 变体提供给支持它的浏览器</li> <li>将 WOFF 变体提供给大多数浏览器</li> <li>将 TTF 变体提供给旧 Android（4.4 版以下）浏览器</li> <li>将 EOT 变体提供给旧 IE（IE9 之下）浏览器</li> </ul> <p>从技术上讲，还有 SVG 字体容器，但 IE 和 Firefox 从不支持它，并且现在 Chrome 也不再支持它。因此，其用途就很有限。</p> <p>看到这里，感觉脑袋都要炸了。Google Fonts 提供了便利。Google Fonts 会根据浏览器的类型，来加载不同的 CSS 以加载不同格式的字体。</p> <h2 id="如何使用-google-fonts"><a href="#如何使用-google-fonts" name="如何使用-google-fonts"></a>如何使用 Google Fonts</h2> <ol> <li>标准方法 <pre><code> link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Condiment'&gt; </code></pre> </li> <li><code>@import</code> 方式 <pre><code> @import url(http://fonts.googleapis.com/css?family=Condiment); </code></pre> </li> <li>JavaScript 方式（代码省略）</li> </ol> <h2 id="国内环境使用-google-fonts"><a href="#国内环境使用-google-fonts" name="国内环境使用-google-fonts"></a>国内环境使用 Google Fonts</h2> <p>有知乎大神，通过 Best Trace 追踪路由器，发现 Google 字体库的国内服务器在北京和上海，另外通过站长工具 ping 测试<code>http://fonts.googleapis.com</code>，速度是杠杆的。<a href="https://www.zhihu.com/question/24955477" target="_blank">参考地址</a>。</p> <p>博主在本地也测试了引用 google fonts 的某个字体，速度是 74ms。所以看起来本阶段可以直接用 Google Fonts 了。之前的观念可以改改了。。</p> <p>如果速度依然有问题，可以参考参考文档的最后一条，结合前面的原理，应该是很好理解的。</p> <h2 id="字体图标原理"><a href="#字体图标原理" name="字体图标原理"></a>字体图标原理</h2> <p><code>@font-face</code>引入一个字体集，这个字体集对应着字符的显示信息，那么浏览器读取到 <code>A</code> 的时候，就会使用 <code>A</code> 对应的 Unicode 编码去查找字体集中对应的显示描述信息。</p> <p>字体图标只是让某些 unicode 码（可以自己创建）对应我们自定义的字体库，而我们的字体库文件中有关于该 unicode 码的显示描述信息而已。</p> <pre><code>font-family: 'Glyphicons Halflings'; content: "\e131"; padding-right: 8px; color: #b1b1b1; float: left; </code></pre> <p>这里 unicode 码就是 <code>\e131</code>。查看网站的加载信息，可以发现我们引用了 Glyphicons Halflings 字体。他的格式和字体的格式也是相同的。</p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="http://www.adobe.com/cn/devnet/html5/articles/web-typography-and-css-font-face.html" target="_blank">Web版式和@font-face简介</a><br /> <a href="https://www.ibm.com/developerworks/cn/web/1505_zhangyan_googlefont/#icomments" target="_blank">使用 Google Fonts 为网页添加美观字体</a><br /> <a href="https://developers.google.com/fonts/docs/technical_considerations" target="_blank">Google Fonts Technical Considerations</a><br /> <a href="https://uhy.github.io/2014/06/22/google-fonts-api/" target="_blank">如何优雅的使用Google Fonts API</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/web-fonts-chinese/]]></link>
		<title><![CDATA[中文 Web 安全字体]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>上一篇 <a href="/web-fonts/" target="_blank" rel="noopener noreferrer">Web 字体</a> 讲了 css 的 font-family 规则以及西文的 Web 安全字体。这篇我们来讲中文安全字体。</p> <h2 id="操作系统预装字体有哪些"><a href="#操作系统预装字体有哪些" name="操作系统预装字体有哪些"></a>操作系统预装字体有哪些</h2> <p>首先我们需要知道操作系统的预装字体有哪些。</p> <table class="table"> <thead> <tr> <th>Windows</th> <th>OS X</th> </tr> </thead> <tbody> <tr> <td>黑体：SimHei</td> <td>冬青黑体: Hiragino Sans GB （SNOW LEOPARD 10.6 开始提供）</td> </tr> <tr> <td>宋体：SimSun</td> <td>华文细黑：STHeiti Light （又名STXihei）</td> </tr> <tr> <td>新宋体：NSimSun</td> <td>华文黑体：STHeiti</td> </tr> <tr> <td>仿宋：FangSong</td> <td>华文楷体：STKaiti</td> </tr> <tr> <td>楷体：KaiTi</td> <td>华文宋体：STSong</td> </tr> <tr> <td>仿宋_GB2312：FangSong_GB2312</td> <td>华文仿宋：STFangsong</td> </tr> <tr> <td>楷体_GB2312：KaiTi_GB2312</td> <td></td> </tr> <tr> <td>微软雅黑：Microsoft YaHei （Windows 7开始提供）</td> </tr> </tbody> </table> <p><em>注：在XP系统中，没有仿宋、楷体，只有仿宋_GB2312和楷体_GB2312这两种字体。但是到了Win7系统，却只有仿宋和楷体，没有了仿宋_GB2312和楷体_GB2312这两种字体。所以在XP系统下制作的公文在Win7系统中打开，全部转换成系统默认的微软雅黑字体。而在Win7系统下制作的公文在XP系统中打开，全部转换成系统默认的宋体。</em></p> <h2 id="font-family-使用注意"><a href="#font-family-使用注意" name="font-family-使用注意"></a>font-family 使用注意</h2> <p>使用 css font-family 需要注意以下几点：</p> <ol> <li>中文字体有英文名称的，建议把中英文名称都写上，比如： <pre><code>     font-family: Tahoma, Helvetica, Arial, "Microsoft Yahei","微软雅黑", STXihei, "华文细黑", sans-serif; </code></pre> <p>“Microsoft YaHei” 是 “微软雅黑” 的英文名</li> <li>在声明中文字体前声明英文字体<br /> 原因是 font-family 会优先使用前面的字体，这样如果中文字体包含了英文字母，那么就会用中文字体库来渲染，这样往往不好看。</li> <li>字体名如果由多个单词组成，那么需要使用引号</li> </ol> <h2 id="衬线体和无衬线体"><a href="#衬线体和无衬线体" name="衬线体和无衬线体"></a>衬线体和无衬线体</h2> <p>衬线体(Serif)是比划末端带有衬线的字体，衬线体装饰性强，易于辨认，常用于正文。<br /> 无衬线体当然就是不带衬线的字体，常用于标题，用于强调和突出。</p> <h2 id="常见的中文字体"><a href="#常见的中文字体" name="常见的中文字体"></a>常见的中文字体</h2> <h3 id="宋体-(simsun)"><a href="#宋体-(simsun)" name="宋体-(simsun)"></a>宋体 (SimSun)</h3> <p><img class="img-responsive" src="/wp-content/uploads/2017/01/chinese-web-fonts-simsun.jpg" alt="" /></p> <p>宋体是最常用的字体。很多人不喜欢宋体，就像很多设计师不喜欢 Arial 一样（windows 的错…）。</p> <p>如果没有指定字体，windows 系统往往会选择宋体来渲染。</p> <p>声明就像这样：</p> <pre><code>font-family: Arial, Helvetica, tahoma, verdana, SimSun,宋体,STXihei,华文细黑, sans-serif; </code></pre> <h3 id="微软雅黑-(microsoft-yahei)"><a href="#微软雅黑-(microsoft-yahei)" name="微软雅黑-(microsoft-yahei)"></a>微软雅黑 (Microsoft YaHei)</h3> <p><img class="img-responsive" src="/wp-content/uploads/2017/01/chinese-web-fonts-Microsoft-yahei.jpg" alt="" /></p> <p>微软雅黑应该说是 windows 平台上最主要的字体了。不过这个字体表现良好主要归功于 ClearType feature，但是 Windows XP 默认关闭了这个功能，所以在 XP 上看起来就惨不忍睹了。<br /> <img class="img-responsive" src="/wp-content/uploads/2017/01/chinese-web-fonts-clear-type.jpg" alt="" /></p> <p>当然 XP 并没有预装这种字体，可以给微软雅黑设置一个 fallback 宋体或者黑体。不过黑体比较粗，不适合用于字号较小的文字。<br /> OS X 对应的字体是华文细黑 (STXihei)</p> <p>声明就像这样：</p> <pre><code>font-family: Tahoma, Arial, Helvetica, "Microsoft YaHei New", "Microsoft Yahei", "微软雅黑", 宋体, SimSun, STXihei, "华文细黑", sans-serif; </code></pre> <h3 id="仿宋-(fangsong)"><a href="#仿宋-(fangsong)" name="仿宋-(fangsong)"></a>仿宋 (FangSong)</h3> <p>仿宋是一种更具装饰性的字体，是衬线体。只有 14 px 以上才比较好，不然太模糊了。(仿宋体是国家规定的机械制图标准字体。)</p> <h3 id="楷体-(kaiti)"><a href="#楷体-(kaiti)" name="楷体-(kaiti)"></a>楷体 (KaiTi)</h3> <p>楷体的装饰性也很强，字面比仿宋体还宽一点，笔画更清楚些，模仿手写体，但是也不宜用在 14 px 以下。</p> <h3 id="冬青黑体简体中文-(hiragino-sans-gb)"><a href="#冬青黑体简体中文-(hiragino-sans-gb)" name="冬青黑体简体中文-(hiragino-sans-gb)"></a>冬青黑体简体中文 (Hiragino Sans GB)</h3> <p>这是 OS X 系统的字体，从 10.6 开始提供，苹果系统使用了很长世间的华文黑体 STHeiti 。从 OS X 10.6 开始 STHeiti 被彻底修订了(combining 华文黑体STHeiti and 华文细黑STXihei)，重命名为(汉黑) HanHei SC ，并且作为系统的默认字体。但是，冬青黑被认为是最好的 web 中文字体，但冬青黑不是 Mac 系统的默认字体。</p> <h3 id="兰亭黑-pro"><a href="#兰亭黑-pro" name="兰亭黑-pro"></a>兰亭黑 pro</h3> <p>兰亭黑 pro 是兰亭黑的改造版，很适合演示。不过不在安全字体的讨论范围内。因为系统是没有预装兰亭黑 pro 的</p> <h2 id="字体的排位"><a href="#字体的排位" name="字体的排位"></a>字体的排位</h2> <p>很多时候我们会将 Windows 的字体放在 OS X 系统之前，按照道理是没问题的，反正 OS X 系统里又没有 Windows 的字体。但是由于各种因素 (比如 Office for Mac 软件帮你安装了 Win 下常用的中文字体)，所以这个时候对 OS X 的用户来说，体验就不好了。相反，Windows 的用户较少安装 OS X 的字体，所以我们应该将针对 OS X 的字体放在 Win 的前面。</p> <h2 id="不一定是最佳实践的-tip"><a href="#不一定是最佳实践的-tip" name="不一定是最佳实践的-tip"></a>不一定是最佳实践的 Tip</h2> <pre><code>font-family: Helvetica, Tahoma, Arial, "Hiragino Sans GB", "Microsoft YaHei","WenQuanYi Micro Hei", sans-serif; </code></pre> <p>“WenQuanYi Micro Hei” 用于 Linux 用户。<br /> 其他的就让他自己 fallback 吧。</p> <p>然后博主又去找了 Apple 网站的字体设置</p> <pre><code>font-family: 'HanHei SC', 'PingFang SC', 'Helvetica Neue', 'Helvetica', 'STHeitiSC-Light', 'Arial', sans-serif; </code></pre> <p>看起来没有考虑 Windows 用户呢 … 就让系统自己选吧</p> <p>然后是微软商城的</p> <pre><code>font-family: "SegoeUI", "Microsoft YaHei", "Hiragino Sans GB"; </code></pre> <p>好像位置不正确呢？…</p> <p>也许可以参考小米、简书的。</p> <h2 id="常见字体效果比较"><a href="#常见字体效果比较" name="常见字体效果比较"></a>常见字体效果比较</h2> <p>windows 平台，安装了冬青黑体简体中文和汉黑，<a href="https://pan.baidu.com/s/1skJVqiD#list/path=%2Fwww.hellomagento2.com%2F%E5%AD%97%E4%BD%93" target="_blank" rel="noopener noreferrer">下载地址</a></p> <p>下图是 chrome 下的效果</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/01/web-fonts-chineses-compare.png" alt="" /></p> <p>chrome 上没有指定字体使用的是宋体，但是博主在 firefox 上测试发现未指定字体使用的是微软雅黑，而且浏览器中可以设置字体。</p> <p>最后附上这段效果的 html 代码，有兴趣的可以自行测试</p> <pre><code>&lt;html lang="zh"&gt;   &lt;head&gt;   &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;     &lt;style&gt;     body {         text-align: center;         margin-top: 50px;         background-color: #efe1d6;         font-size: 14px;     }       .songti {         font-family: 'SimSun',宋体;       }       .fsong {         font-family: 'FangSong',仿宋;       }       .kai {         font-family: 'KaiTi',楷体;       }       .yh {         font-family: 'Microsoft YaHei',微软雅黑;       }       .dqh {         font-family: 'Hiragino Sans GB';       }       .hh {         font-family: 'HanHeiSC';       }     &lt;/style&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;p&gt;没有没有指定字体]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/centos-7-%E6%90%AD%E5%BB%BA-lnmp-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85-magento/]]></link>
		<title><![CDATA[Centos 7 搭建 LNMP 环境安装 Magento]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本次使用 centos 7.4、Nginx、MySQL、PHP 7.1 搭建 LNMP 环境，安装 Magento 2.2 。<br /> 在实践过程中，发现 Magento 官方文档有微小错误，所以本文可做参考佐证。</p> <p><a href="http://devdocs.magento.com/guides/v2.2/install-gde/prereq/nginx.html" target="_blank" rel="noopener">Magento 官方文档 nginx</a></p> <h2 id="安装-nginx"><a href="#安装-nginx" name="安装-nginx"></a>安装 nginx</h2> <pre><code>yum -y install epel-release yum -y install nginx </code></pre> <p>安装完成后，启动 ng 设置他开机启动</p> <pre><code>systemctl start nginx systemctl enable nginx </code></pre> <p>centos 中 ng 的配置文件一般在 <code>/etc/nginx/nginx.conf</code> 打开后查看下：<br /> <img src="/wp-content/uploads/2017/11/ng-conf.png" alt="ng 配置文件" /></p> <p>访问网站，可以看到欢迎页面:<br /> <img src="/wp-content/uploads/2017/11/ng-welcome-page.png" alt="nginx welcome" /></p> <h2 id="安装-php"><a href="#安装-php" name="安装-php"></a>安装 php</h2> <pre><code>yum install -y http://dl.iuscommunity.org/pub/ius/stable/CentOS/7/x86_64/ius-release-1.0-14.ius.centos7.noarch.rpm yum -y update </code></pre> <p>安装 php 扩展</p> <pre><code>yum -y install php71u php71u-pdo php71u-mysqlnd php71u-opcache php71u-xml php71u-mcrypt php71u-gd php71u-devel php71u-mysql php71u-intl php71u-mbstring php71u-bcmath php71u-json php71u-iconv php71u-soap </code></pre> <p>安装 php-fpm</p> <pre><code>yum -y install php71u-fpm </code></pre> <p>怎么查看内存多大</p> <pre><code>grep MemTotal /proc/meminfo </code></pre> <h3 id="修改-php.ini"><a href="#修改-php.ini" name="修改-php.ini"></a>修改 php.ini</h3> <p>打开 <code>/etc/php.ini</code><br /> 去掉 <code>cgi.fix_pathinfo</code> 前 <code>;</code> 并修改值为 0<br /> 并且修改以下行：</p> <pre><code>memory_limit = 2G max_execution_time = 1800 zlib.output_compression = On </code></pre> <p>注释下列行：</p> <pre><code>;session.save_path = "/var/lib/php/session" </code></pre> <p>保存文件。</p> <h3 id="修改-phpfpm-的设置"><a href="#修改-phpfpm-的设置" name="修改-phpfpm-的设置"></a>修改 phpfpm 的设置</h3> <p>打开 <code>/etc/php-fpm.d/www.conf</code><br /> 修改以下行的值</p> <pre><code>user = nginx group = nginx listen = /run/php-fpm/www.sock listen.owner = nginx listen.group = nginx listen.mode = 0660 </code></pre> <p>注释以下行：</p> <pre><code>env[HOSTNAME] = $HOSTNAME env[PATH] = /usr/local/bin:/usr/bin:/bin env[TMP] = /tmp env[TMPDIR] = /tmp env[TEMP] = /tmp </code></pre> <p>注意：<br /> php_value[session.save_handler] = files<br /> php_value[session.save_path] = /var/lib/php/fpm/session</p> <p>所以更改权限</p> <pre><code>chown -R nginx:nginx /var/lib/php/fpm/ </code></pre> <p>如果不存在则创建：</p> <pre><code>mkdir -p /run/php-fpm/</code></pre> <pre><code>chown -R nginx:nginx /run/php-fpm/ </code></pre> <pre><code>systemctl start php-fpm systemctl enable php-fpm </code></pre> <p>验证下：</p> <pre><code>netstat -pl ]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/centos-7-lamp-magento-2/]]></link>
		<title><![CDATA[CentOS 7 搭建 LAMP 环境安装 Magento 2]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="安装-apache"><a href="#安装-apache" name="安装-apache"></a>安装 Apache</h2> <pre><code>yum -y install httpd </code></pre> <p>验证安装是否成功</p> <pre><code>httpd -v </code></pre> <p>如果出现类似下面的信息就是安装好了</p> <pre><code>Server version: Apache/2.4.6 (CentOS) Server built: Jul 18 2016 15:30:14 </code></pre> <p>启动 apache</p> <pre><code>systemctl restart httpd.service </code></pre> <p>访问网站可以看到 Apache HTTP Server 测试页面 <code>Testing 123...</code></p> <pre><code>vi /etc/httpd/conf/httpd.conf </code></pre> <p>更改为：</p> <pre><code>&lt;Directory /var/www/html&gt; AllowOverride All &lt;/Directory&gt; </code></pre> <h2 id="安装-php-7"><a href="#安装-php-7" name="安装-php-7"></a>安装 php 7</h2> <p>CentOS 7</p> <pre><code>yum install -y http://dl.iuscommunity.org/pub/ius/stable/CentOS/7/x86_64/ius-release-1.0-14.ius.centos7.noarch.rpm yum -y update </code></pre> <pre><code>yum -y install php70u php70u-pdo php70u-mysqlnd php70u-opcache php70u-xml php70u-mcrypt php70u-gd php70u-devel php70u-mysql php70u-intl php70u-mbstring php70u-bcmath php70u-json php70u-iconv </code></pre> <p>重启 Apache</p> <pre><code>systemctl restart httpd.service </code></pre> <p>验证安装是否成功</p> <pre><code>php -v </code></pre> <p>如果看到类似下面的信息就是安装成功了</p> <pre><code>PHP 7.0.13 (cli) (built: Nov 10 2016 08:44:18) ( NTS ) Copyright (c) 1997-2016 The PHP Group Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies with Zend OPcache v7.0.13, Copyright (c) 1999-2016, by Zend Technologies </code></pre> <p>修改 php.ini</p> <pre><code>vi /etc/php.ini </code></pre> <p>修改</p> <pre><code>date.timezone = "Asia/Shanghai" memory_limit = 1024M </code></pre> <p>看起来就只有这一个 php.ini</p> <h2 id="安装-mysql"><a href="#安装-mysql" name="安装-mysql"></a>安装 MySQL</h2> <p>CentOS 7 安装 MySQL 5.7</p> <pre><code>wget http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm yum -y localinstall mysql57-community-release-el7-7.noarch.rpm </code></pre> <p>安装</p> <pre><code>yum -y install mysql-community-server systemctl start mysqld.service </code></pre> <p>验证是否安装成功</p> <pre><code>mysql --version </code></pre> <p>如果出现类似下面的信息即安装成功</p> <pre><code>mysql Ver 14.14 Distrib 5.7.16, for Linux (x86_64) using EditLine wrapper </code></pre> <p>取得 root 用户的临时密码</p> <pre><code>grep 'temporary password' /var/log/mysqld.log </code></pre> <p>secure the installation</p> <pre><code>mysql_secure_installation </code></pre> <p>然后根据提示设置新的密码和配置</p> <p>登录 MySQL 并创建一个数据库，授权给用户</p> <pre><code>create database dbname GRANT ALL ON dbname.* TO user@localhost IDENTIFIED BY 'password'; </code></pre> <h2 id="添加用户"><a href="#添加用户" name="添加用户"></a>添加用户</h2> <pre><code>useradd -r -m -s /bin/bash newuser passwd newuser </code></pre> <p>查看 apache 所属的用户组</p> <pre><code>egrep -i '^user]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/aliyun-ecs-install-magento-2/]]></link>
		<title><![CDATA[阿里云 ECS (Ubuntu LAMP)安装 Magento 2 (原创)]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="magento2-系统要求"><a href="#magento2-系统要求" name="magento2-系统要求"></a>Magento2 系统要求</h2> <p>官方参考网址：<br /> <a href="http://devdocs.magento.com/guides/v2.0/install-gde/system-requirements.html">http://devdocs.magento.com/guides/v2.0/install-gde/system-requirements.html</a></p> <h3 id="操作系统"><a href="#操作系统" name="操作系统"></a>操作系统</h3> <p>Linux x86-64 (RedHat Enterprise Linux (RHEL), CentOS, Ubuntu, Debian 等)</p> <h3 id="web-服务器软件"><a href="#web-服务器软件" name="web-服务器软件"></a>web 服务器软件</h3> <ol> <li>Apache 2.2 或者 2.4 (必须打开 mod_rewrite)</li> <li>nginx 1.8 (or latest mainline version)</li> </ol> <h3 id="数据库"><a href="#数据库" name="数据库"></a>数据库</h3> <p>MySQL 5.6 或者 5.7</p> <h3 id="php"><a href="#php" name="php"></a>PHP</h3> <p>Update: 下面的要求特指 Magneto 2.1.0 后续版本有差异，请参考官方获得最新的消息</p> <ol> <li>5.6.x</li> <li>5.5.x ( x 大于 22)</li> <li>7.0.2 至 7.1.0 (除了 7.0.5 和 7.0.4) (7.0.4 官文没有说，但 github 上有 bug 亲测不可用)</li> <li>php 扩展<br /> bc-math (ee版本才需要)<br /> curl<br /> gd 或者 ImageMagick 6.3.7及以上版本 也可以两个都装<br /> intl<br /> mbstring<br /> mcrypt<br /> mhash<br /> openssl<br /> PDO/MySQL<br /> SimpleXML<br /> soap<br /> xml<br /> xsl<br /> zip<br /> PHP 7 only:<br /> json<br /> iconv</li> </ol> <h3 id="其他"><a href="#其他" name="其他"></a>其他</h3> <p>暂时不考虑</p> <h2 id="目标"><a href="#目标" name="目标"></a>目标</h2> <p>阿里云 ECS 操作系统 Ubuntu 14.04 64位<br /> Apache 2.4<br /> MySQL 5.7<br /> PHP 7 (据说速度比 PHP 5 提高25%)<br /> Magento 2.1.0</p> <h2 id="准备"><a href="#准备" name="准备"></a>准备</h2> <p><em>下面的软件可以去这里下：<a href="http://pan.baidu.com/s/1skJVqiD" target="_blank">http://pan.baidu.com/s/1skJVqiD </a></em></p> <h3 id="magento-2-的安装包"><a href="#magento-2-的安装包" name="magento-2-的安装包"></a>Magento 2 的安装包</h3> <ol> <li>官方下载地址：<br /> <a href="https://www.magentocommerce.com/download">https://www.magentocommerce.com/download</a></li> <li>Composer</li> <li>GitHub</li> </ol> <p><em>他们的目录略有不同，个人觉得第一种比较容易哈，下面我们下载 Magento 2.1.0 版本，带 Sample Data的</em></p> <h3 id="ftp-工具"><a href="#ftp-工具" name="ftp-工具"></a>FTP 工具</h3> <p>一会儿需要用FTP上传到服务器上</p> <blockquote> <p>个人用的是FileZilla Client</p> </blockquote> <h3 id="远程登陆工具"><a href="#远程登陆工具" name="远程登陆工具"></a>远程登陆工具</h3> <p>用它来远程连接服务器</p> <blockquote> <p>个人用的是Putty</p> </blockquote> <h2 id="apache"><a href="#apache" name="apache"></a>Apache</h2> <p>用远程登陆工具登上服务器</p> <h3 id="安装-apache"><a href="#安装-apache" name="安装-apache"></a>安装 Apache</h3> <pre><code>apt-get -y update apt-get -y install apache2 apache2 -v </code></pre> <h3 id="enable-rewrites-and-.htaccess"><a href="#enable-rewrites-and-.htaccess" name="enable-rewrites-and-.htaccess"></a>Enable rewrites and .htaccess</h3> <ol> <li>启用Apache rewrite 模块<br /> <code>a2enmod rewrite</code></li> <li>配置允许存在于.htaccess中的指令<br /> <code>vi /etc/apache2/sites-available/000-default.conf</code><br /> 在文件末尾添加</p> <pre><code>&lt;Directory "/var/www/html"&gt;  AllowOverride  all &lt;/Directory&gt; </code></pre> </li> <li>重启Apache<br /> <code>service apache2 restart</code></li> </ol> <h2 id="mysql"><a href="#mysql" name="mysql"></a>MySQL</h2> <h3 id="安装mysql"><a href="#安装mysql" name="安装mysql"></a>安装MySQL</h3> <p>(Ubuntu 自带的源目前没有MySQL 5.7)</p> <pre><code>apt-get -y update apt-get -y upgrade apt-get install software-properties-common add-apt-repository -y ppa:ondrej/mysql-5.7 apt-get update apt-get install mysql-server-5.7 </code></pre> <p>mysql-client 也会自动装好的</p> <pre><code>mysql -V mysql -u root -p </code></pre> <h3 id="新建一个数据库-demomagento-并授权给用户-demomagento-密码是-magento"><a href="#新建一个数据库-demomagento-并授权给用户-demomagento-密码是-magento" name="新建一个数据库-demomagento-并授权给用户-demomagento-密码是-magento"></a>新建一个数据库 demomagento 并授权给用户 demomagento 密码是 Magento</h3> <p>(仅作演示用)</p> <pre><code>create database demomagento; GRANT ALL ON demomagento.* TO demomagento@localhost IDENTIFIED BY 'Magento'; </code></pre> <h2 id="php"><a href="#php" name="php"></a>PHP</h2> <h3 id="安装-php-和扩展"><a href="#安装-php-和扩展" name="安装-php-和扩展"></a>安装 PHP 和扩展</h3> <pre><code>apt-get -y update add-apt-repository ppa:ondrej/php apt-get -y update apt-get install -y php7.0 libapache2-mod-php7.0 php7.0 php7.0-common php7.0-gd php7.0-mysql php7.0-mcrypt php7.0-curl php7.0-intl php7.0-xsl php7.0-mbstring php7.0-zip php7.0-bcmath php7.0-iconv </code></pre> <p>查看版本<br /> <code>php -v</code></p> <h3 id="修改-php-设置"><a href="#修改-php-设置" name="修改-php-设置"></a>修改 PHP 设置</h3> <p><code>vi /etc/php/7.0/apache2/php.ini</code></p> <p>该文件是apache使用的配置文件，可通过phpinfo() 找到他。还有一个php.ini配置文件用于命令行，可以通过<code>php -i ]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/wampserver-install-magento-2/]]></link>
		<title><![CDATA[Wampserver 本地搭建 Magento 2]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="wampserver-简介"><a href="#wampserver-简介" name="wampserver-简介"></a>Wampserver 简介</h2> <p>Wampserver 是 window 下的 apache、 php 和 mysql 的集成包。他可以帮助你快速搭建PHP环境。对于初学者来说，非常适合。不过要进入生产环境，这样的集成包有一些奇怪的问题，还是用标准的配置方法更好。对于 Magento 2 来说，官方的系统要求是 Linux，所以强烈建议深入学习和生产环境时使用Linux 环境进行服务器配置。可以参考本站的另一篇文章 <a href="/aliyun-ecs-install-magento-2/">阿里云 ECS 安装 Magento 2 (原创)</a></p> <h3 id="准备需要的软件"><a href="#准备需要的软件" name="准备需要的软件"></a>准备需要的软件</h3> <ol> <li>Wampserver<br /> Wampserver 可以去<a href="https://sourceforge.net/projects/wampserver/">该网站下载</a>，官方发布，可以获得最新版，缺点就是下载速度慢地很。<br /> 可以去我的百度云下载：<a href="http://pan.baidu.com/s/1skJVqiD">http://pan.baidu.com/s/1skJVqiD</a></li> <li>Magento 安装包<br /> 这个官方给出了三种：</p> <ul> <li><a href="https://www.magentocommerce.com/download">官方下载地址</a></li> <li>Composer 的方式</li> <li>GitHub 的方式<br /> 这里，我推荐官方下载地址，也可以去我的百度云下载（<a href="http://pan.baidu.com/s/1skJVqiD）">http://pan.baidu.com/s/1skJVqiD）</a></li> </ul> </li> </ol> <p>该教程准备的Wampserver 是 wampserver3.0.4_x64_apache2.4.18_mysql5.7.11_php5.6.19-7.0.4.exe ，我是64位的系统，云盘里放的也是这个版本，还放了一个32位的。</p> <p>Magento 是 Magento-CE-2.1.0_sample_data-2016-06-23-02-32-34.zip ，这个是Magento 2.1 版本带演示数据的。（云盘里有2.1版本带演示数据和不带演示数据的）</p> <h2 id="安装-wampserver"><a href="#安装-wampserver" name="安装-wampserver"></a>安装 Wampserver</h2> <p>这个很简单啦，下一步下一步就行。<br /> 安装好后启动它。</p> <h2 id="配置-wampserver-虚拟目录"><a href="#配置-wampserver-虚拟目录" name="配置-wampserver-虚拟目录"></a>配置 Wampserver 虚拟目录</h2> <p>我们的开发环境要能够放多个网站，当然用子目录也是可以的，子目录就是比如<code>http://127.0.0.1/a</code> 放一个站，<code>http://127.0.0.1/b</code> 又放一个站。不过这样很容易混乱，所以我们来配置一下虚拟目录。</p> <h3 id="配置虚拟目录"><a href="#配置虚拟目录" name="配置虚拟目录"></a>配置虚拟目录</h3> <p>我的在wamp 安装在<code>D:\wamp64</code> 目录下。<br /> 打开<code>D:\wamp64\bin\apache\apache2.4.17\conf\extra\httpd-vhosts.conf</code> 我们可以看到如下内容：</p> <pre><code># # Virtual Hosts #  &lt;VirtualHost *:80&gt;     ServerName localhost     DocumentRoot d:/wamp64/www     &lt;Directory  "d:/wamp64/www/"&gt;         Options +Indexes +FollowSymLinks +MultiViews         AllowOverride All         Require local     &lt;/Directory&gt; &lt;/VirtualHost&gt; </code></pre> <p>我将他改为</p> <pre><code># # Virtual Hosts #  &lt;VirtualHost *:80&gt;     ServerName localhost     DocumentRoot e:/www/hellomagento2     &lt;Directory  "e:/www/hellomagento2"&gt;         Options +Indexes +FollowSymLinks +MultiViews         AllowOverride All         Require local     &lt;/Directory&gt; &lt;/VirtualHost&gt;  &lt;VirtualHost *:81&gt;     ServerName localhost     DocumentRoot e:/www/wp     &lt;Directory  "e:/www/wp"&gt;         Options +Indexes +FollowSymLinks +MultiViews         AllowOverride All         Require local     &lt;/Directory&gt; &lt;/VirtualHost&gt; </code></pre> <p>然后修改<code>D:\wamp64\bin\apache\apache2.4.17\conf\httpd.conf</code>找到这一段</p> <pre><code>Listen 0.0.0.0:80 Listen [::0]:80 </code></pre> <p>在后面添加监听81端口</p> <pre><code>Listen 0.0.0.0:80 Listen [::0]:80 Listen 0.0.0.0:81 Listen [::0]:81 </code></pre> <p>这时候我们在任务栏里找到 wamp 的图标，单击一下，点击<strong>Restart All services</strong> 等到 wamp 由再次变成绿色以后，在浏览器输入<code>127.0.0.1</code>就会访问<code>e:/www/hellomagento2</code>下的网站，而如果输入<code>127.0.0.1:81</code>则会访问<code>e:/www/wp</code><br /> 上面两个<code>127.0.0.1</code>都可以用<code>localhost</code>替代。我们来看下为什么可以用<code>localhost</code>替代。<br /> 以管理员身份打开记事本，在记事本中打开<code>C:\Windows\System32\drivers\etc\hosts</code>，我们可以看到这样的记录<code>127.0.0.1 localhost</code><br /> hosts 是一个记录主机名和ip地址映射的文件，相当于本地的 DNS，当我在浏览器中输入某个域名的时候，本机会先查看 hosts 中是否有记录，如果有直接转到该 ip，不需要再访问DNS服务器了。所以我们现在给他加一条<code>127.0.0.1 thankit.cn</code> 加完后我们在浏览器中输入<code>thankit.cn</code>照样可以访问<code>e:/www/hellomagento2</code>下的网站了对吧。</p> <p>上面我们给不同的端口分配了不同的虚拟目录，现在我要同一个端口也可以有不同的网站呢？<br /> 我们已经给hosts 增加了一条记录，让<code>thankit.cn</code>也可以访问到<code>127.0.0.1</code>了，现在我要让<code>thankit.cn</code>对应<code>e:/www/thankit</code>应该怎么做呢？<br /> 打开<code>D:\wamp64\bin\apache\apache2.4.17\conf\extra\httpd-vhosts.conf</code> 在上面的基础上添加如下内容：</p> <pre><code>&lt;VirtualHost *:80&gt;     ServerName thankit.cn     DocumentRoot e:/www/thankit     &lt;Directory  "e:/www/thankit"&gt;         Options +Indexes +FollowSymLinks +MultiViews         AllowOverride All         Require local     &lt;/Directory&gt; &lt;/VirtualHost&gt; </code></pre> <p>注意 ServerName 现在是 <code>thankit.cn</code>让 wamp <strong>Restart All services</strong>，之后浏览器中输入<code>thankit.cn</code>是不是可以访问到<code>e:/www/thankit</code></p> <p>根据你的需求配置好自己的虚拟目录吧。</p> <h2 id="安装-magento-2.1"><a href="#安装-magento-2.1" name="安装-magento-2.1"></a>安装 Magento 2.1</h2> <p>我们用<code>localhost</code> 对应的<code>e:/www/hellomagento2</code>来安装 Magento 2。<br /> 先将2.1的zip 解压后放到<code>e:/www/hellomagento2</code>下。<br /> 我们来创建一个数据库。在任务栏找到 wamp ，单击出现的面板中再点击 phpMyAdmin，默认用户名为root，密码为空。登录后创建一个数据库hellomagento2。<br /> 在浏览器中打开<code>localhost</code>这时候就是 Magento 安装界面了。第一步的检测，PHP Settings Check 发生错误。<br /> <img src="/wp-content/uploads/2016/08/wampserver-install-magento2-error.png" alt="" /><br /> 上面说让我们打开php.ini 修改 <code>always_populate_raw_post_data</code> 为 -1</p> <p><em>wampserver 是有两个 php.ini 的，我的在wamp 安装在<code>D:\wamp64</code> 目录下，以我的安装目录为例，php 下的<code>D:\wamp64\bin\php\php5.6.19\php.ini</code>是cli 命令行使用时的配置文件，而apache 下的<code>D:\wamp64\bin\apache\apache2.4.18\bin\php.ini</code>是web 访问时的配置文件。此处先注意一下，以后会需要改命令行下的 php.ini，现在不需要</em></p> <p>现在我们改<code>D:\wamp64\bin\apache\apache2.4.18\bin\php.ini</code>，找到<code>always_populate_raw_post_data</code> 发现他是<code>;always_populate_raw_post_data = -1</code>，去掉前面的分号保存，wamp <strong>Restart All services</strong>，回到浏览器 Magento 安装页面，重新检测一下(Try again)，这次没有错误啦。<br /> 下一步，填入数据库名称<code>hellomagento2</code>再下一步，下面很简单，根据提示下一步下一步就安装成功啦。</p> <h2 id="简单调优"><a href="#简单调优" name="简单调优"></a>简单调优</h2> <p>我们可以通过增加 PHP 的 memory_limit 来让 Magento 跑快一点。<br /> 官方推荐的memory_limit 是这样的：</p> <ul> <li>Compiling code, 768M</li> <li>Deploying static asses, 768M</li> <li>Installing and updating Magento components from Magento Marketplace, 1G</li> <li>Testing, 2G<br /> 所以我们起码给个 768M 吧，这次我们修改 <code>D:\wamp64\bin\apache\apache2.4.18\bin\php.ini</code> 和 <code>D:\wamp64\bin\php\php5.6.19\php.ini</code>，找到 <code>memory_limit</code>，发现默认才给了128M，速度当然慢了。强烈建议你两个都修改，因为 Magento 是要用命令行的，而博主就遇到过一直报内存不够的错误，当时我还不知道 Wamp 是有两个 php.ini 的…<br /> 记得改完<strong>Restart All services</strong></li> </ul> <h2 id="相关文章列表"><a href="#相关文章列表" name="相关文章列表"></a>相关文章列表</h2> <p><a href="/wampserver-lan-magento" target="_blank">局域网访问本地 Magento</a><br /> <a href="/php-path/" target="_blank">php 不是内部或外部命令，也不是可运行的程序或批处理文件</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/hyper-v-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/]]></link>
		<title><![CDATA[hyper-v 创建虚拟机]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>博主是 windows 系统，用 wamp 本地开发经常遇到些奇奇怪怪的问题。所以需要一个虚拟机方案。</p> <p>从 win8 开始，自带 hyper-v ，你也可以考虑用 VirtualBox 、VMware 等其他方案。</p> <h2 id="启用-hyper-v"><a href="#启用-hyper-v" name="启用-hyper-v"></a>启用 hyper-v</h2> <p>控制面板 -&gt; 启用或关闭 windows 功能，勾选 Hyper-v</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/10/启用Hyper-v.png" alt="启用 Hyper-v" /></p> <p>然后重启电脑</p> <p>重启后从搜索中找到 Hyper-v 管理器，然后甩开膀子开始玩吧。。</p> <p>需要注意，要创建一个外部虚拟交换机，并且设置虚拟机使用该外部虚拟交换机，然后虚拟机就能上网了。</p> <h2 id="安装系统"><a href="#安装系统" name="安装系统"></a>安装系统</h2> <p>这个随便你安装什么系统了，博主用的 ubuntu 16，所以本段记录博主遇到的问题。</p> <p>问题一：ubuntu 16 安装时选择中文，出现错误 “无法安装busybox-initramfs”，然后我试了 14 版本，安装 MySQL 时遇到了错误 “return codecs.ascii_decode(input, self.errors)[0] UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xc5 in position 92: ordinal not in range(128)” 。</p> <p>解决方法：安装了 ubuntu 16 但是选择英文。不要问我为什么。。</p> <p>问题二：hyper-v 本来的连接工具竟然无法使用复制粘贴。<br /> 解决方法：安装 ssh 服务</p> <pre><code>sudo apt-get install net-tools #安装网络工具 sudo apt-get install openssh-server #安装ssh服务 ufw allow 22/tcp </code></pre> <p>下面用 ssh 客户端工具连接就行了。博主用的 Putty 。</p> <p>问题三：hyper-v 虚拟机的网络一般用的是 DHCP，获取的 ip 地址是动态的，要把他设置成静态的。不然每次重启后，可能地址就不一样了，这样要查地址、改地址，不是烦死球了。</p> <p>解决方法（以 ubuntu 为例）：</p> <pre><code>sudo vi /etc/network/interfaces </code></pre> <p>由</p> <pre><code>auto lo iface lo inet loopback auto eth0 iface eth0 inet dhcp </code></pre> <p>改为：</p> <pre><code>auto lo iface lo inet loopback iface eth0 inet static address 192.168.0.250 netmask 255.255.255.0 gateway 192.168.0.1 </code></pre> <p>address 是你要设置的静态地址，请根据你的实际情况写。</p> <p>设置 DNS 服务器</p> <pre><code>sudo vi /etc/resolv.conf </code></pre> <p>添加：</p> <pre><code>nameserver 192.168.0.250 nameserver 218.2.2.2 </code></pre> <pre><code>vi /etc/resolvconf/resolv.conf.d/base </code></pre> <p>添加：</p> <pre><code>nameserver 192.168.0.250 nameserver 218.2.2.2 </code></pre> <p>重启 networking 服务使其生效：</p> <pre><code>/etc/init.d/networking restart </code></pre> <p>然后：</p> <pre><code>ifconfig </code></pre> <p>查看是否生效。<br /> 如果还是无效，就重启整个物理机。</p> <p>参考 <a href="http://blog.csdn.net/litao31415/article/details/49661399" target="_blank" rel="noopener">ubuntu设置静态ip地址</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/virtualbox%E4%B8%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%86%85%E7%BD%91%E4%BA%92%E9%80%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%9D%99%E6%80%81ip%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D/]]></link>
		<title><![CDATA[VirtualBox下虚拟机和主机内网互通+虚拟机静态IP的网络配置]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="配置主机的内网静态-ip"><a href="#配置主机的内网静态-ip" name="配置主机的内网静态-ip"></a>配置主机的内网静态 IP</h2> <p>打开 Orcale VM VirtualBox 管理器，从菜单中选择 <strong>管理</strong> &gt; <strong>主机网络管理器</strong>，双击 VirtualBox Host-Only Ethernet Adapter ，修改他的 IP 地址为 192.168.1.1</p> <p><img src="/wp-content/uploads/2018/01/host-only.png" alt="" /></p> <p>关闭 DHCP 服务器</p> <p><img src="/wp-content/uploads/2018/01/host-only-colse-dhcp.png" alt="" /></p> <h2 id="配置虚拟机的网卡"><a href="#配置虚拟机的网卡" name="配置虚拟机的网卡"></a>配置虚拟机的网卡</h2> <p>加入第一块网卡，配置如下：</p> <p><img src="/wp-content/uploads/2018/01/eth0.png" alt="" /></p> <p>加入第二块网卡，配置如下：</p> <p><img src="/wp-content/uploads/2018/01/eth1.png" alt="" /></p> <p>注意：虚拟机之间的内网名字可以随便起，这里叫做 neta。如果在配置在第二个虚拟机的时候，也要记得选择 netca 这个内网名字，这样虚拟机之间才可以互相通信。</p> <p>加入第三块网卡，配置如下：</p> <p><img src="/wp-content/uploads/2018/01/eth2.png" alt="" /></p> <p>装系统的步骤就跳过了，博主使用的是 ubuntu 16</p> <p>进入系统后，输入：</p> <pre><code>ifconfig -a </code></pre> <p>查看所有的网卡信息，根据 mac 地址确定三块网卡对应的名称。</p> <h2 id="在虚拟机内部配置网卡"><a href="#在虚拟机内部配置网卡" name="在虚拟机内部配置网卡"></a>在虚拟机内部配置网卡</h2> <p>sudo vi /etc/network/interfaces</p> <pre><code># This file describes the network interfaces available on your system # and how to activate them. For more information, see interfaces(5).  source /etc/network/interfaces.d/*  # The loopback network interface auto lo iface lo inet loopback  # The primary network interface auto enp0s3 iface enp0s3 inet static address 192.168.1.2 netmask 255.255.255.0  auto enp0s8 iface enp0s8 inet static address 192.168.0.2 netmask 255.255.255.0  auto enp0s9 iface enp0s9 inet dhcp </code></pre> <p>重启 networking 服务使其生效：</p> <pre><code>/etc/init.d/networking restart </code></pre> <h2 id="验证"><a href="#验证" name="验证"></a>验证</h2> <p>通过主机 ping 虚拟机</p> <pre><code>ping 192.168.1.2 </code></pre> <p>在虚拟机中 ping 主机</p> <pre><code>ping 192.168.1.1 </code></pre> <p>ping 不通，尝试关闭主机的防火墙，这次就通了。</p> <p>虚拟机之间互 ping</p> <pre><code>ping 192.168.0.2 </code></pre> <p>虚拟机上网</p> <pre><code>ping baidu.com </code></pre> <h2 id="参考资料"><a href="#参考资料" name="参考资料"></a>参考资料</h2> <p><a href="http://xintq.net/2014/09/05/virtualbox/">VirtualBox下虚拟机和主机内网互通+虚拟机静态IP的网络配置</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan-magento-2-javascript-init-scripts/]]></link>
		<title><![CDATA[Magento 2 Javascript Init Scripts（翻译）]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em><a href="http://alanstorm.com/magento_2_javascript_init_scripts/" target="_blank" rel="noopener">原文地址</a></em></p> <p>在 Alan 的 <a href="http://alanstorm.com/category/magento-2/#magento_2_mvc" target="_blank" rel="noopener">Magento 2 for PHP MVC</a>系列文章中，曾经提到 RequireJS 是 Magento 2 系统所有 JS 的基础。这的确是事实，但是 RequireJS 仅仅触及 Magento 中 javaScript 可能性的表面。</p> <p>今天我们将探索 Magento 2 引入的各种系统，以执行非嵌入<code>&lt;script type="text/javascript"&gt;</code>标签的 js 代码作为开始。</p> <h2 id="javascript-init-methods"><a href="#javascript-init-methods" name="javascript-init-methods"></a>JavaScript Init Methods</h2> <p>Magento js init 方法解决了一些不同的问题：<br /> 第一，他提供了一种标准机制，阻止直接在页面中嵌入 js 代码的行为。<br /> 第二，提供了调用 RequireJS 模块程序的方式（通过 define 来定义）(原话：Second, they provide a way to invoke a stand alone RequireJS module (defined with define) <strong>as a program</strong>.)<br /> 第三，提供了给程序传递服务器端产生的 JSON 对象的方式。<br /> 第四，提供了一种方式，告诉程序哪个　DOM　节点（如果有的话）是它的作用对象。</p> <p>记住这四点。They may help you if you’re struggling with the mental model behind these custom framework features.</p> <h2 id="setting-up-a-module"><a href="#setting-up-a-module" name="setting-up-a-module"></a>Setting up a Module</h2> <p>今天的教程和 Magento 的 PHP 不怎么相关，你可以在任何<code>phtml</code>模板上进行实验。</p> <p>这里 Alan 没有提供示例代码，不过博主建了一个，可以去<a href="https://github.com/PiscesThankIT/JavascriptInitTutorial" target="_blank" rel="noopener">https://github.com/PiscesThankIT/JavascriptInitTutorial</a>下载。</p> <p>下载后启用它</p> <pre><code>$ php bin/magento module:enable Pulsestorm_JavascriptInitTutorial $ php bin/magento setup:upgrade </code></pre> <p>现在在浏览器中输入如下URL</p> <pre><code>http://magento.example.com/pulsestorm_javascriptinittutorial/ </code></pre> <p>你应该看到<code>app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml</code>模板被渲染出来了。</p> <h2 id="setting-up-a-requirejs-module"><a href="#setting-up-a-requirejs-module" name="setting-up-a-requirejs-module"></a>Setting up a RequireJS Module</h2> <p>我们现在已经有了一个模块，下面我们创建一个 RequireJS 的模块。<br /> 创建如下文件：</p> <pre><code>//File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/web/example.js define([], function(){     alert("A simple RequireJS module");     return {}; }); </code></pre> <p>这是个很简单的 RequireJS 模块。根据模块的文件位置以及 Magento 载入js 文件的方式，我们可以推得该模块的名称/ID是<code>Pulsestorm_JavascriptInitTutorial/example</code></p> <p>下面，修改<code>content.phtml</code>文件成下面的样子：</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml &lt;script type="text/javascript"&gt;     requirejs(['Pulsestorm_JavascriptInitTutorial/example'],function(example){         alert("Loaded");         console.log(example);     }); &lt;/script&gt; </code></pre> <p>这里我们创建了一个依赖<code>Pulsestorm_JavascriptInitTutorial/example</code>模块的程序。</p> <p>浏览器中刷新<code>http://magento.example.com/pulsestorm_javascriptinittutorial/</code> URL，你应该看到 alert 弹出。</p> <p>如果你觉得上面的内容不太熟悉，你可以参阅本站<a href="/alan-magento-2-and-requirejs/" target="_blank" rel="noopener">Magento 2 and RequireJS (翻译)</a></p> <p>译者注：刷新浏览器后首先看到的是 A simple RequireJS module 弹出框，点击确定后，看到 Loaded 弹出框，点击确定后，在 Console 中看到输出的空对象。</p> <p>页面载入时先执行了<code>Pulsestorm_JavascriptInitTutorial/example</code> 成功后返回值为空对象，传递给了回调函数的<code>example</code>。执行回调函数内部的alert 和 console 输出。</p> <h2 id="x-magento-init"><a href="#x-magento-init" name="x-magento-init"></a>X-Magento-Init</h2> <p>首先我们来了解<code>&lt;script type="text/x-magento-init"&gt;</code>初始化方法。这个方法最简单的用法是让你运行某个 RequireJS 模块。把<code>content.phtml</code>模板改成下面的样子：</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml &lt;div id="one" class="foo"&gt;     Hello World &lt;/div&gt; &lt;div id="two" class="foo"&gt;     Goodbye World &lt;/div&gt;  &lt;script type="text/x-magento-init"&gt;     {         "*": {             "Pulsestorm_JavascriptInitTutorial/example":{}         }     } &lt;/script&gt; </code></pre> <p>现在在重新载入页面，你应该看到 A simple RequireJS module 弹出框。这个是我们<code>example.js</code>中的定义的。</p> <p>如果你从来没看过这种语法，可能觉得他看起来很怪。让我们一点一点来看一看。</p> <p>首先是<code>&lt;script/&gt;</code>标签</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml &lt;script type="text/x-magento-init"&gt;     //... &lt;/script&gt; </code></pre> <p>这不是 javaScript 的标签。注意<code>type="text/x-magento-init"</code>属性。如果浏览器不认识 script 标签中的值，它就会忽略该标签中的内容。Magento (其他现代前端框架类似)利用了这个行为来实现它自己的功能。Magento 中有 js 代码会查找带有<code>text/x-magento-init</code>属性的标签，这超出了本篇教程的范围。如果你想进一步探索的话，可以先看看这个<a href="http://magento.stackexchange.com/questions/89187/in-magento2-what-is-script-type-text-x-magento-init" target="_blank" rel="noopener">this Stack Exchange question and answer</a></p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml {     "Pulsestorm_JavascriptInitTutorial/example":{} } </code></pre> <p>Magento 会查找该对象的键，并且以 RequireJS 模块的方式将他载入进来。这里就是让<code>example.js</code>被载入的关键。</p> <p>你很可能很想知道为什么这个对象没有值呢。你还可能很想知道为什么这个对象是另一个键为<code>*</code>的对象的值。</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml {     "*": {/*...*/} } </code></pre> <p>解释这些原因前，我们得先说一说 javascript components。</p> <h2 id="magento-javascript-components"><a href="#magento-javascript-components" name="magento-javascript-components"></a>Magento JavaScript Components</h2> <p>上面的例子运行了一个 RequireJS 模块程序。Magento 经常用<code>x-magento-init</code>方法调用 RequireJS 模块程序。但是，<code>x-magento-init</code>真正强大的能力是创建<strong>Magento Javascript Component</strong></p> <p><strong>Magento Javascript Component are RequireJS modules that return a function。</strong> Magento’s system code will call this function in a specific way that exposes extra functionality.</p> <p>下面我们来看例子。修改<code>example.js</code></p> <pre><code>//File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/web/example.js define([], function () {     var mageJsComponent = function()     {         alert("A simple magento component.");     };      return mageJsComponent; }); </code></pre> <p>这里我们定义了一个匿名函数，并将他分配给了<code>mageJsComponent</code>变量。然后我们返回他。</p> <p>重新载入页面，你会看到 A Simple Magento Component 弹出框。</p> <p>看起来可能有点蠢——如果 Magento 只是要调用它，返回一个 function 的意义是什么呢？你是对的，但是你对是因为我们少了点什么。修改<code>phtml</code>模板：</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml &lt;div id="one" class="foo"&gt;     Hello World &lt;/div&gt; &lt;div id="two" class="foo"&gt;     Goodbye World &lt;/div&gt;  &lt;script type="text/x-magento-init"&gt;     {         "*": {             "Pulsestorm_JavascriptInitTutorial/example":{"config":"value"}         }     } &lt;/script&gt; </code></pre> <p>修改 RequireJS 模块</p> <pre><code>//File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/web/example.js define([], function () {     var mageJsComponent = function(config)     {         alert("Look in your browser's console");         console.log(config);         //alert(config);     };      return mageJsComponent; }); </code></pre> <p>重新载入页面，你可以看到 alert 中的信息变成了Look in your browser’s console。你在浏览器的 console 中会看到：</p> <pre><code>&gt; Object {config:"value"} </code></pre> <p>When we create a Magento Javascript Component, Magento calls the returned function and includes the object from text/x-magento-init</p> <pre><code>"Pulsestorm_JavascriptInitTutorial/example":{"config":"value"} </code></pre> <p>键是 RequireJS 模块名，值是我们要传递给该 component 的对象。</p> <p>这些例子可能看起来又傻又抽象。但是，在实际使用的模块中，我们会使用 PHP 来生成 JSON。系统允许我们在 phtml 模板中 render the JSON，并将他们传递给 js 代码。这有助于避免使用 PHP 直接生成 js 代码，直接生成的做法会产生糟糕的代码，还可能引入错误或者安全问题。</p> <p>结束<code>x-magento-init</code>之前，还有最后一点要说。记得前文说<code>x-magento-init</code></p> <pre><code>提供了给程序传递服务器端产生的 JSON 对象的方式。 提供了一种方式，告诉程序哪个　DOM　节点（如果有的话）是它的作用对象。 </code></pre> <p>我们已经说过如何将服务器端生成的 JSON 传递给js 了，还没有说 DOM 节点。</p> <p>修改<code>example.js</code>模块</p> <pre><code>//File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/web/example.js define([], function () {     var mageJsComponent = function(config, node)     {         console.log(config);         console.log(node);         //alert(config);     };      return mageJsComponent; }); </code></pre> <p>这里我们给<code>mageJsComponent</code>函数增加了一个参数。第二个参数就是我们程序要作用的 DOM node。但是，刷新页面，你会看到：</p> <pre><code>&gt; Object {config:"value"} &gt; false </code></pre> <p>Magento 确实传递了值给<code>node</code>——但值输出是<code>false</code>，这个值是什么呢？</p> <p>Magento不能神奇地知道你要作用于哪个 DOM node。我们得告诉他。修改<code>phtml</code>模板：</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml  &lt;div id="one" class="foo"&gt;Hello World&lt;/div&gt; &lt;div id="two" class="foo"&gt;     Goodbye World &lt;/div&gt;  &lt;script type="text/x-magento-init"&gt;     {         "#one": {             "Pulsestorm_JavascriptInitTutorial/example":{"config":"value"}         }     } &lt;/script&gt; </code></pre> <p>这里我们把原先的<code>*</code>改成了<code>#one</code>。之前我们用的<code>*</code>代表了这样一种特殊情形：当程序不需要作用于任何 DOM node 的时候。这个对象的键实际上是 CSS/jQuery style selector 。这个键告诉<code>Pulsestorm_JavascriptInitTutorial/example</code>程序哪个 DOM node 是他的作用对象。现在我们刷新页面（记得刷新下缓存），我们会在 console 中看到：</p> <pre><code>&gt; Object {config: "value"} &gt; &lt;div id="one" class="foo"&gt;Hello World&lt;/div&gt; </code></pre> <p>你不仅可以使用id选择器，还可以用css class 选择器。</p> <pre><code>#File: app/code/Pulsestorm/JavascriptInitTutorial/view/frontend/templates/content.phtml ".foo": {     "Pulsestorm_JavascriptInitTutorial/example":{"config":"value"} } </code></pre> <p>在 console 中会看到：</p> <pre><code>&gt; Object {"config":"value"} &gt; &lt;div id="one" class="foo"&gt;Hello World&lt;/div&gt; &gt; Object {"config":"value"} &gt; &lt;div id="one" class="foo"&gt;Goodbye World&lt;/div&gt; </code></pre> <p>通过这样的系统，Magento 鼓励开发者避免在 RequireJS 模块中硬编码 DOM nodes。The <code>x-magento-init</code> means there’s a system level path forward for building Javascript modules that rely on server side rendered JSON, and operate on any arbitrary DOM node. It’s always been possible for Magento module developers to implement their own systems for this sort of functionality, but Magento 2 provides a standard, built in way to achieve this.</p> <h2 id="data-mage-init-attribute"><a href="#data-mage-init-attribute" name="data-mage-init-attribute"></a>Data-mage-init Attribute</h2> <p>除了<code>&lt;script type="text/x-magento-init"&gt;</code>方式，还有一种方式可以对特定的 DOM　node 调用实现类似功能，就是使用<code>data-mage-init</code>属性。<br /> 将 phtml 模板替换成以下内容：</p> <pre><code>&lt;div data-mage-init='{"Pulsestorm_JavascriptInitTutorial/example": {"another":"example"}}'&gt;A single div&lt;/div&gt; </code></pre> <p><code>cache:clean</code>后重新载入页面，在console 中你应该看到：</p> <pre><code>&gt; Object {another: "example"} &gt; &lt;div&gt;A single div&lt;/div&gt; </code></pre> <p>这里，我们给特定的div 增加了一个<code>data-mage-init</code>属性。这个属性的值是一个 JSON 对象。类似于<code>x-magento-init</code>，这个对象的键是我们要调用的 RequireJS 模块或是 Magento Javascript Component，他的值是要传递给js component config 参数的 JSON 对象。</p> <p><em>注意，我们的属性中使用的是单引号</em></p> <pre><code>&lt;div data-mage-init='...'&gt;A single div&lt;/div&gt; </code></pre> <p>这是必要的，<code>data-mage-init</code>属性会严格按照 JSON 格式解析，就是说 JSON 对象必须使用双引号，所以我们的属性就只能用单引号了。</p> <h2 id="wrap-up"><a href="#wrap-up" name="wrap-up"></a>Wrap up</h2> <p>不管是用<code>&lt;script type="text/x-magento-init"&gt;</code>还是用<code>data-mage-init</code>， both these techniques provide a standard, system unified way of introducing Javascript entry points onto your page.Many of Magento’s front end and back end UI features rely on this syntax, so even if you personally eschew them, understanding how these systems work is an important part of being a Magento 2 developer.</p> <h2 id="示例代码下载"><a href="#示例代码下载" name="示例代码下载"></a>示例代码下载</h2> <p><a href="https://github.com/PiscesThankIT/JavascriptInitTutorial" target="_blank" rel="noopener">https://github.com/PiscesThankIT/JavascriptInitTutorial</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan-knockoutjs-primer-for-magento-developers/]]></link>
		<title><![CDATA[KnockoutJS Primer for Magento Developers （翻译）]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em><a href="http://alanstorm.com/knockoutjs_primer_for_magento_developers/" target="_blank">原文地址</a></em></p> <p>在我们可以继续探索 Magento 的 js 高级特性之前，我们得先补习 <a href="http://knockoutjs.com/" target="_blank">KnockoutJS</a>KnockoutJS 是一个 javaScript MVVM 系统，他是 Magento 2 中的主要 DOM 操作框架。</p> <p>本篇教程旨在帮助 Magento 开发者熟悉 KnockoutJS 的基本概念，重点介绍 Magento 使用的一些 KnockoutJS 功能。如果你打算用 KnockoutJS 创建东西的话，强烈建议你参阅<a href="http://learn.knockoutjs.com/" target="_blank">KnockoutJS 官方 tutorials</a></p> <h2 id="hello-model,view,view-model"><a href="#hello-model,view,view-model" name="hello-model,view,view-model"></a>Hello Model,View,View Model</h2> <p>首先，让我们来创建下面的 HTML 页面</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt;     &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.0/knockout-min.js"&gt;&lt;/script&gt;     &lt;script src="https://code.jquery.com/jquery-3.0.0.min.js" integrity="sha256-JmvOoLtYsmqlsWxa7mDSLMwa6dZ9rrIdtrrVYRnDRH0=" crossorigin="anonymous"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt;     &lt;h1&gt;&lt;/h1&gt;     &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>这个页面：</p> <ol> <li>从 CDN 加载 KnockoutJS 库</li> <li>从 CDN 加载 JQuery 库</li> <li>设置了一个空的 DOM 结构</li> </ol> <p>你不需要从 CDN 加载 jQuery 和 KnockoutJS，不过这样做比较容易。</p> <p>如果你用浏览器打开这个页面，你会看到一个空白页。因为你得：</p> <ol> <li>Add the javascript code that creates a view model and applies the KnockoutJS bindings</li> <li>Add the view code to the HTML page that reads from the view model</li> </ol> <p>我们先来做第一个，创建一个名为<code>ko-init.js</code>的文件</p> <pre><code>//File: ko-init.js jQuery(function(){     viewModel = {         title:"Hello World",         content:"So many years of hello world"     };     ko.applyBindings(viewModel); }); </code></pre> <p>然后在我们的页面中引入这个js 文件</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.0/knockout-min.js"&gt;&lt;/script&gt; &lt;script src="https://code.jquery.com/jquery-3.0.0.min.js" integrity="sha256-JmvOoLtYsmqlsWxa7mDSLMwa6dZ9rrIdtrrVYRnDRH0=" crossorigin="anonymous"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="ko-init.js"&gt;&lt;/script&gt; </code></pre> <p>最后，修改<code>h1</code>和<code>p</code>标签，给他们添加如下的<code>data-bind</code>属性</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;h1 data-bind="text:title"&gt;&lt;/h1&gt;     &lt;p data-bind="text:content"&gt;&lt;/p&gt; &lt;/div&gt; </code></pre> <p>现在刷新页面，你应该会看到：<br /> <img class="img-responsive" src="/wp-content/uploads/2016/11/alan-knockoutjs-first.png" alt="" /><br /> 恭喜你！你成功创建了第一 KnockoutJS view model 和 view</p> <h2 id="what-just-happened"><a href="#what-just-happened" name="what-just-happened"></a>What Just Happened</h2> <p>KnockoutJS 本身是 <strong>MVVM</strong>系统，MVVM 代表着 Model，View,View Model。Really though, KnockoutJS is better billed as a VVM system, since its agnostic about what sort of model code you use to fetch data. view 是指 HTML 页面，view model 是指带数据的 js 对象。</p> <p>让我们来看看js 代码：</p> <pre><code>//File: ko-init.js jQuery(function(){     viewModel = {         title:"Hello World",         content:"So many years of hello world"     };     ko.applyBindings(viewModel); }); </code></pre> <p>jQuery 并非必要的，只不过 KnockoutJS 不能在 DOM 还没有完成加载前进行渲染，jQuery 的 document ready 函数正可以帮助我们达到目的。<code>jQuery();</code>相当于<code>$(document).ready();</code></p> <p>这里我们创建了一个带键值对的 view model</p> <pre><code>//File: ko-init.js viewModel = {     title:"Hello World",     content:"So many years of hello world" }; </code></pre> <p>然后我们应用了 KnockoutJS 的绑定。换一种说法是我们让 KnockoutJS 用 view model 去渲染 view。再说一遍，view 是整个 HTML 页面。</p> <p>我们来看看 view 部分，注意<code>data-bind</code>属性</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;h1 data-bind="text:title"&gt;&lt;/h1&gt;     &lt;p data-bind="text:content"&gt;&lt;/p&gt; &lt;/div&gt; </code></pre> <p>当你调用<code>applyBindings</code>时，KnockoutJS 会扫描整个 HTML 页面寻找<code>data-bind</code>属性。it parses the attribute for the binding name and value, and then invokes a set of rules based on the name of the binding.</p> <p>举例来说，上面我们调用的绑定是<code>text</code>，我们传递给<code>text</code>绑定的是<code>title</code>。text 绑定应用的规则是：“从 view model 对象中使用传递过来的值作为键取出对应的值，然后将该值插入到 DOM 中，作为一个 text 节点。”如果用纯 js 来表示的话，就是：</p> <pre><code>value = viewModel['title']; textNode = document.createTextNode(value); h1.appendChild(textNode); </code></pre> <p>KnockoutJS 的第一个招数是他使开发者免于自己使用 js 创建和更新 DOM 节点。开发者通关过书写带有<code>data-bind</code>属性的 HTML 标签来给他赋值。你不仅可以使用键值对，看下面这个更复杂的 view model。</p> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {         this.getTitle = function()         {             return "Hello Method World";         }        this.content = "So many years of hello world";     }      viewModel = new viewModelConstructor;     ko.applyBindings(viewModel); }); </code></pre> <p>这里我们使用了 js 构造函数创建了一个简单的对象。这个对象有一个<code>getTitle</code>方法。如果我们修改下<code>page.html</code>来调用<code>getTitle</code>方法，你会发现效果和预期的一样。</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;h1 data-bind="text:getTitle()"&gt;&lt;/h1&gt;     &lt;p data-bind="text:content"&gt;&lt;/p&gt; &lt;/div&gt; </code></pre> <p>Another way of thinking about binding parameters is they’re a temporary, limited javascript scope to access your view model’s values and methods.</p> <h2 id="other-bindings"><a href="#other-bindings" name="other-bindings"></a>Other Bindings</h2> <p>虽然这个例子比较简单，但是从中可以开始了解到，这种简单的构建 block 是如何实现更为复杂的视图逻辑的。（While this example is simple, you can start to see how this basic building block could implement far more complicated view logic）更新DOM的事交给数据绑定来做，更新模型的事情交给non-DOM js 代码来完成。</p> <p>再举个例子了解下其他的绑定。</p> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {         this.getTitle = function()         {             return "Hello World";         }        this.content = "So many years of hello world";        this.theValue = "2";     }     viewModel = new viewModelConstructor;     ko.applyBindings(viewModel); }); </code></pre> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;h1 data-bind="text:getTitle()"&gt;&lt;/h1&gt;     &lt;p data-bind="text:content"&gt;&lt;/p&gt;     &lt;input type="text" data-bind="value:theValue"/&gt; &lt;/div&gt; </code></pre> <p>刷新页面，你会看到：</p> <p><img class="img-responsive" src="/wp-content/uploads/2016/11/alan-knockoutjs-second.png" alt="" /></p> <p>这里我们使用了一个新的 KnockoutJS 绑定</p> <pre><code>data-bind="value:theValue" </code></pre> <p>我们使用<code>value</code>绑定将值赋给表单字段。下面让我们把 input 换成 select 看看</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;h1 data-bind="text:getTitle()"&gt;&lt;/h1&gt;     &lt;p data-bind="text:content"&gt;&lt;/p&gt;     &lt;select data-bind="value:theValue"&gt;         &lt;option value=""&gt;-- Choose --&lt;/option&gt;         &lt;option value="1"&gt;First&lt;/option&gt;         &lt;option value="2"&gt;Second&lt;/option&gt;         &lt;option value="3"&gt;Third&lt;/option&gt;     &lt;/select&gt; &lt;/div&gt; </code></pre> <p>刷新页面后，你会看到已经设置 select 的值为2了。<br /> <img class="img-responsive" src="/wp-content/uploads/2016/11/alan-knockoutjs-third.png" alt="" /></p> <p>虽然这个例子很简单，背后的概念可不简单。不需要修改任何 js 程序代码，value binding 就可以让我们更改 UI</p> <h2 id="observables"><a href="#observables" name="observables"></a>Observables</h2> <p>到目前为止，我们看到还只是小招数，已经很强大了。Neat, maybe useful, but it only sets the stage for KnockoutJS’s real “knockout” feature — observables.</p> <p>下面，我们还是以例子开始。</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;p data-bind="text:theValue"&gt;&lt;/p&gt;     &lt;select data-bind="value:theValue"&gt;         &lt;option value=""&gt;-- Choose --&lt;/option&gt;         &lt;option value="1"&gt;First&lt;/option&gt;         &lt;option value="2"&gt;Second&lt;/option&gt;         &lt;option value="3"&gt;Third&lt;/option&gt;     &lt;/select&gt;     &lt;input type="text" data-bind="value:theValue"/&gt;      &lt;div&gt;     &lt;br/&gt;&lt;br/&gt;     &lt;button id="button"&gt;Do It&lt;/button&gt;     &lt;/div&gt; &lt;/div&gt; </code></pre> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {        this.theValue = ko.observable("1");     }      window.viewModel = new viewModelConstructor;     ko.applyBindings(window.viewModel); }); </code></pre> <p>重新载入页面，你会发现我们给<code>&lt;input/&gt;</code>和<code>&lt;p/&gt;</code>标签绑定了值<code>1</code>。到目前为止我们的页面没什么新变化——这和我们之前做的绑定一样。但是，你注意到在我们的 view model 中，我写了一点不一样的代码：</p> <pre><code>//File: ko-init.js this.theValue = ko.observable("1"); </code></pre> <p>我们没有给<code>theValue</code>硬编一个值或者是一个custom function，我们给他的是一个 KnockoutJS <code>observable</code><strong>An observable is a special sort of getter and setter.</strong></p> <p>打开浏览器 console ，输入<code>viewModel.theValue()</code>，你会发现我们可以像调用函数一样取得 observable 的值。（因为我们定义viewModel为全局对象window 的属性，所以我们可以通过 console 访问到他）</p> <pre><code>&gt; viewModel.theValue() &gt; "1" </code></pre> <p>我们可以给 observable 传递参数来设置他的值。</p> <pre><code>&gt; viewModel.theValue("3") //... &gt; viewModel.theValue() &gt; "3" </code></pre> <p>However, the real power of an observable is in what happens to the DOM nodes we’ve bound that observable to。试着在console 中改变 observer 的值，注意页面的变化。</p> <pre><code>&gt; viewModel.theValue("3"); &gt; viewModel.theValue("2"); &gt; viewModel.theValue("1"); &gt; viewModel.theValue("10"); </code></pre> <p>一旦你修改了 observable 的值，被绑定的 DOM 也立刻有了变化。作为开发者，我们再也不用关心怎么更新 DOM nodes 了。一旦我们给 model 中的值做了改变，他的值会立刻自动反应到用户界面上。</p> <p>看下面一个view model 带方法的例子。</p> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {         this.theValue = ko.observable("1");         var that = this;         this.pickRandomValue = function(){             var val = Math.floor(Math.random() * (3));             that.theValue(val);         };     }      window.viewModel = new viewModelConstructor;     ko.applyBindings(window.viewModel); }); </code></pre> <p>使用 KnockoutJS 的事件绑定（比如<code>click</code>）</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;button data-bind="click:pickRandomValue"&gt;Do It&lt;/button&gt; </code></pre> <h2 id="template-binding"><a href="#template-binding" name="template-binding"></a>Template Binding</h2> <p>另一个要重点理解的是 KnockoutJS 的模板绑定。考虑下面的 view model</p> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {         this.first = {             theTitle:ko.observable("Hello World"),             theContent:ko.observable("Back to Hello World")         };         this.second = {             theTitle:ko.observable("Goodbye World"),             theContent:ko.observable("We're sailing west now")         };     }      viewModel = new viewModelConstructor;     ko.applyBindings(viewModel); }); </code></pre> <p>这里我们创建了一个标准的view model 但是 data 对象是嵌套的。然后我么修改view</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="main"&gt;     &lt;div id="one" data-bind="template:{'name':'hello-world','data':first}"&gt;&lt;/div&gt;      &lt;div id="two" data-bind="template:{'name':'hello-world','data':second}"&gt;     &lt;/div&gt;      &lt;script type="text/html" id="hello-world"&gt;         &lt;h1 data-bind="text:theTitle"&gt;&lt;/h1&gt;         &lt;p data-bind="text:theContent"&gt;&lt;/p&gt;     &lt;/script&gt; &lt;/div&gt; </code></pre> <p>你将会看到：</p> <p><img class="img-responsive" src="/wp-content/uploads/2016/11/alan-knockoutjs-fourth.png" alt="" /></p> <p>template 绑定接受一个 js 对象作为参数</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div id="one" data-bind="template:{'name':'hello-world','data':first}"&gt;&lt;/div&gt; </code></pre> <p>data 参数是我们要渲染的 view model 的属性。name 是要查找和渲染的模板名称。</p> <p>添加模板最基本的做法是添加<code>&lt;script type="text/html"&gt;</code>并且给他命名。</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;script type="text/html" id="hello-world"&gt;     &lt;h1 data-bind="text:theTitle"&gt;&lt;/h1&gt;     &lt;p data-bind="text:theContent"&gt;&lt;/p&gt; &lt;/script&gt; </code></pre> <p>If you’ve never seen this before it may seem weird/foreign, but many modern javascript frameworks use non-<code>text/javascript</code> <code>&lt;script/&gt;</code> tags as a way to add non-rendered (but DOM accessible) content to a page.模板是一些带有 KnockoutJS 绑定的 HTML 片段</p> <h2 id="components"><a href="#components" name="components"></a>Components</h2> <p>下面是组件绑定。 Components are a way to package together a KnockoutJS template, and a KnockoutJS view file. This means you can have a relatively simple view。</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div data-bind="component:'component-hello-world'"&gt;&lt;/div&gt; </code></pre> <p>隐藏了注册了的组件的复杂性</p> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {         this.message = "Hello World";     }      var theTemplate = "&lt;h1 data-bind=\"text:message\"&gt;&lt;/h1&gt;";      ko.components.register('component-hello-world', {         viewModel:viewModelConstructor,         template:theTemplate     });      ko.applyBindings(); }); </code></pre> <p>component 对象的<code>register</code>方法第一个参数接受组件的名称，第二个参数接受一个 KnockoutJS component 对象。component 对象是一个有两个属性的 js 对象。<code>viewModel</code>属性接受一个 view model 构造函数，<code>template</code>属性是 KnockoutJS 模板字符串。一旦完成组件注册，你就可以通过传递组件的名称来使用它了。</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div data-bind="component:'component-hello-world'"&gt;&lt;/div&gt; </code></pre> <p>如果你不想用<code>data-bind</code>这样的语法，KnockoutJS 提供了另一种基于组件名称的自定义标签，试试看下面的代码：</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;component-hello-world&gt;&lt;/component-hello-world&gt; </code></pre> <p>这依然仅仅触及 KnockoutJS 的表面，官方文档对<a href="http://knockoutjs.com/documentation/component-overview.html" target="_blank">组件绑定</a>讲得不错，可以参阅以下。</p> <h2 id="custom-binding"><a href="#custom-binding" name="custom-binding"></a>Custom Binding</h2> <p>KnockoutJS 允许开发者创建自定义绑定。举例来说，下面我们调用了名为<code>pulseStormHelloWorld</code>的绑定，并且将viewModel中的<code>message</code>属性的值传递给他。</p> <pre><code>&lt;!-- File: page.html --&gt; &lt;div data-bind="pulseStormHelloWorld:message"&gt;&lt;/div&gt; </code></pre> <p>我们还没有实现<code>pulseStormHelloWorld</code>绑定，所以现在刷新页面是空白页。因为 KnockoutJS 忽略了它。下面修改<code>ko-init.js</code></p> <pre><code>//File: ko-init.js jQuery(function(){     var viewModelConstructor = function()     {         this.message = "Hello World";     }      ko.bindingHandlers.pulseStormHelloWorld = {         update: function(element, valueAccessor){             jQuery(element).html('&lt;h1&gt;' + valueAccessor() + '&lt;/h1&gt;');         }     };     ko.applyBindings(new viewModelConstructor); }); </code></pre> <p>创建自定义的KnockoutJS绑定，我只需要给 <code>ko.bindingHandlers</code>对象添加一个属性。这个属性的名称就是我们自定义绑定的名称。The <code>handler</code> is a JS object with an <code>update</code> method.当绑定被唤起时，KnockoutJS 就会调用<code>update</code>方法—— 不管是<code>applyBindings</code>或是通过 observable</p> <p>刷新页面，你会看到自定义绑定起作用了。当然，这只是个普通的例子，但是通过自定义绑定你可以让 KnockoutJS 做任何你想得到的事。</p> <p>如果想了解更多关于KnockoutJS自定义绑定的，请移步<a href="http://learn.knockoutjs.com/#/?tutorial=custombindings" target="_blank">官方custom binding tutorial</a></p> <h2 id="wrap-up"><a href="#wrap-up" name="wrap-up"></a>Wrap up</h2> <p>KnockoutJS 是一个强大现代的js框架。Its semantics, and disregard for traditional HTML concepts, may make some developers shy away at first, but as a tool of organizing and taming DOM complexity in a modern javascript application KnockoutJS has few peers.我们的教程是不完整的，但是希望足以引发你对KnockoutJS的兴趣，自己探索它的文档和教程。</p> <p>KncokoutJS 本身不足以构成一个完整的 JS 应用程序。下周我们会探索 Magento 中与 KnockoutJS 密切相关的框架。这样会让你更了解 Magento 核心系统是如何工作的，还有怎样在你自己的模块和应用中应用 KnockoutJS。</p> <h2 id="下载"><a href="#下载" name="下载"></a>下载</h2> <p><a href="https://github.com/PiscesThankIT/KnockoutJS-Primer-for-Magento-Developers" target="_blank">文中使用的源代码</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_2_knockoutjs_integration/]]></link>
		<title><![CDATA[Magento 2 KnockoutJS 集成]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em><a href="http://alanstorm.com/magento_2_knockoutjs_integration/" target="_blank">原文地址</a></em></p> <p>虽然 KnockoutJS 作为 MVVM 框架（model,view,view model），但是PHP开发人员会发现model部分有点瘦。KnockoutJS 本身没有 data storage 的概念，像许多现代js框架一样，it was designed to work best with a service only backend（设计为和 service only 的后端一起工作）. i.e. <a href="http://knockoutjs.com/documentation/json-data.html" target="_blank">KnockoutJS’s “Model” is some other framework making AJAX requests</a> to populate view model values.</p> <p>另外一件可能会让你意外的事情是，KnockoutJS 并不是一个“full stack”框架（and to its credit, doesn’t bill itself as such）</p> <p>KnockoutJS 没有规定你如何在项目中使用它，也没有规定你怎么组织代码。（虽然从文档可以看出KnockoutJS的团队成员是RequireJS的粉丝）。</p> <p>这对类似Magento这样的服务器端PHP框架提出了一个有趣的挑战。要使用KnockoutJS,不仅得围绕着它搭建一定程度的js“脚手架”，而且 Magento 2本身可不是一个service only的框架。Magento 2 的全新API在解决后一个问题上取得了进展，但是后端开发人员还是需要建立将业务数据对象注入 KnockoutJS 的脚手架。</p> <p>今天我们来深入Magento 2 的 KnockoutJS 集成问题。通过本教程，你将明白 Magento 2 是如何应用 KnockoutJS 绑定的，以及Magento 2 是如何初始化他的自定义绑定的。你还将明白 Magento 是如何修改核心 KnockoutJS 的某些行为的，为什么要这样做，以及这些修改带给你的模块和应用的可能性。</p> <p>本篇教程是 Alan 的 Magento 2 高级js概念系列文章中的一篇，如果你在下文遇到不理解的概念，可以翻看一下该文章的前几篇。</p> <h2 id="creating-a-magento-module"><a name="creating-a-magento-module" href="#creating-a-magento-module"></a>Creating a Magento Module</h2> <p>我们得创建一个<code>Pulsestorm KnockoutTutorial</code>模块，并且可以通过<code>http://magento.example.com/pulsestorm_knockouttutorial/</code>链接看到<code>app/code/Pulsestorm/KnockoutTutorial/view/frontend/templates/content.phtml</code>模板的渲染效果。</p> <p>Alan 没有提供示例代码，你可以自己创建，也可以去博主的 github 仓库下载。<a href="https://github.com/PiscesThankIT/Magento-2-KnockoutJS-Integration" target="_blank">示例代码下载地址</a></p> <pre><code>$ php bin/magento module:enable Pulsestorm_KnockoutTutorial $ php bin/magento setup:upgrade </code></pre> <h2 id="requirejs-initialization"><a name="requirejs-initialization" href="#requirejs-initialization"></a>RequireJS Initialization</h2> <p>在我们之前的文章以及KnockoutJS官方教程中，KnockoutJS的初始化时很简单的事情。</p> <pre><code>object = SomeViewModelConstructor(); ko.applyBindings(object); </code></pre> <p>上面的做法只是为了教程讲解。然而，如果你将所有的 view model 逻辑，自定义绑定，组件都放在一个代码块中的话，KnockoutJS 将很快变得不好管理了。</p> <p>Magento 的核心团队创建了一个<code>Magento_Ui/js/lib/ko/initialize</code> RequireJS 模块。只要将它作为依赖模块，就会执行KnockoutJS的初始化。你可以像下面这样使用它。</p> <pre><code>requirejs([&#039;Magento_Ui/js/lib/ko/initialize&#039;], function(){     //your program here }); </code></pre> <p>要注意的是这个 RequireJS 模块没有返回值，将他作为依赖模块唯一的目的就是进行 KnockoutJS 的初始化。你在实际环境中见到他，可能会感到困惑。举例来说，看下面的代码：</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/core/app.js define([     &#039;./renderer/types&#039;,     &#039;./renderer/layout&#039;,     &#039;Magento_Ui/js/lib/ko/initialize&#039; ], function (types, layout) {     &#039;use strict&#039;;      return function (data) {         types.set(data.types);         layout(data.components);     }; }); </code></pre> <p>声明了三个 RequireJS 依赖</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/core/app.js [ &#039;./renderer/types&#039;, &#039;./renderer/layout&#039;, &#039;Magento_Ui/js/lib/ko/initialize&#039; ] </code></pre> <p>但是回调函数中却只有两个参数</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/core/app.js function (types, layout) {     //... } </code></pre> <p>我还不清楚这种做法是否明智，或者是否违反了RequireJS的精神。也许都有。</p> <p>不管怎么说，你用这个模块，Magento 就会初始化 KnockoutJS 了。RequireJS 会在第一次加载模块时就缓存他们，所以之后加载的模块不会被重复载入。</p> <h2 id="knockoutjs-initialization"><a name="knockoutjs-initialization" href="#knockoutjs-initialization"></a>KnockoutJS Initialization</h2> <p>我们来看看<code>Magento_Ui/js/lib/ko/initialize</code>模块的源代码</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/initialize.js define([     &#039;ko&#039;,     &#039;./template/engine&#039;,     &#039;knockoutjs/knockout-repeat&#039;,     &#039;knockoutjs/knockout-fast-foreach&#039;,     &#039;knockoutjs/knockout-es5&#039;,     &#039;./bind/scope&#039;,     &#039;./bind/staticChecked&#039;,     &#039;./bind/datepicker&#039;,     &#039;./bind/outer_click&#039;,     &#039;./bind/keyboard&#039;,     &#039;./bind/optgroup&#039;,     &#039;./bind/fadeVisible&#039;,     &#039;./bind/mage-init&#039;,     &#039;./bind/after-render&#039;,     &#039;./bind/i18n&#039;,     &#039;./bind/collapsible&#039;,     &#039;./bind/autoselect&#039;,     &#039;./extender/observable_array&#039;,     &#039;./extender/bound-nodes&#039; ], function (ko, templateEngine) {     &#039;use strict&#039;;      ko.setTemplateEngine(templateEngine);     ko.applyBindings(); }); </code></pre> <p>我们看到这个模块相对简单，但还是包含了19个其他模块。要说清每个模块做什么，已经超出本篇的范围了。只讲重要的。</p> <p><code>ko</code>模块实际上是<code>knockoutjs/knockout</code>模块</p> <pre><code>vendor/magento/module-theme/view/base/requirejs-config.js 11:            &quot;ko&quot;: &quot;knockoutjs/knockout&quot;, 12:            &quot;knockout&quot;: &quot;knockoutjs/knockout&quot; </code></pre> <p><code>knockoutjs/knockout</code>模块实际上就是 KnockoutJS 库。<code>knockoutjs/knockout-repeat</code>,<code>knockoutjs/knockout-fast-foreach</code>, and<br /><code>knockoutjs/knockout-es5</code> 是 KnockoutJS community extras（社区插件）这些都不是正规的 RequireJS 模块。</p> <p>从<code>./bind/*</code>开始的模块是 Magento 的 KnockoutJS 自定义绑定。他们是正经的 RequireJS 模块，不过他们实际上没有返回。这些脚本给全局的<code>ko</code>对象添加绑定。我们下面会讨论<code>scope</code> 绑定。如果你对绑定实现的细节感兴趣，可以去<a href="https://github.com/magento/devdocs/issues/718" target="_blank">这里看看</a>，期待官方文档快点出来。</p> <p>这两个<code>extender</code>模块是Magento 对 KnockoutJS 功能扩展的核心模块。</p> <p><code>./template/engine</code>模块返回了一个自定义版本的 KnockoutJS 模板引擎。这是我们下面第一个要讨论的。</p> <h2 id="magento-knockoutjs-templates"><a name="magento-knockoutjs-templates" href="#magento-knockoutjs-templates"></a>Magento KnockoutJS Templates</h2> <p>KnockoutJS 系统中，模板是一些事先写好的 DOM/KnockoutJS 代码，可以通过<code>id</code>来引用他们。这些代码块以下面的形式添加到页面中：</p> <pre><code>&lt;script type=&quot;text/html&quot; id=&quot;my_template&quot;&gt;     &lt;h1 data-bind=&quot;text:title&quot;&gt;&lt;/h1&gt; &lt;/script&gt; </code></pre> <p>这是个很强大的功能，但是提出了一个问题——对于服务器端的框架来说，如何获取正确的模板并渲染到页面上呢？如何确保不用重复创建模板呢？KnockoutJS 的解决方案是使用组件绑定配合RequireJS，但是这意味着你的模板绑定在特定的view model 对象上。</p> <p>Magento 的核心工程师需要一种更好的办法来加载 KnockoutJS 模板。—— 他们使用<code>Magento_Ui/js/lib/ko/template/engine</code>模块的引擎替换掉了 KnockoutJS 原先的模板引擎。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/initialize.js define([     &#039;ko&#039;,     &#039;./template/engine&#039;,     //... ], function (ko, templateEngine) {     &#039;use strict&#039;;     //...     ko.setTemplateEngine(templateEngine);     //... }); </code></pre> <p>如果我们看一看<code>Magento_Ui/js/lib/ko/template/engine</code>这个模块。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/template/engine.js /**  * Copyright © 2016 Magento. All rights reserved.  * See COPYING.txt for license details.  */ define([     &#039;ko&#039;,     &#039;./observable_source&#039;,     &#039;./renderer&#039; ], function (ko, Source, Renderer) {     &#039;use strict&#039;;      var RemoteTemplateEngine,         NativeTemplateEngine = ko.nativeTemplateEngine,         sources = {};      //...      RemoteTemplateEngine.prototype = new NativeTemplateEngine;       //...     RemoteTemplateEngine.prototype.makeTemplateSource = function (template)     {         //...     }     //...      return new RemoteTemplateEngine; }); </code></pre> <p>Magento 创建了一个新的对象，该对象用原型法继承了 KnockoutJS 的引擎，然后修改了一些方法增加自定的行为。If you’re not up on your javascript internals, this means Magento copies the stock KnockoutJS template system, changes it a bit, and then swaps its new template engine in for the stock one.</p> <p>实现的细节超过了本篇的范围，不过最终的结果是KnockoutJS 引擎可以通过 URL 链接从Magento模板中获取模板。</p> <p>如果这样说没有让你搞懂，那么来个例子。向<code>content.phtml</code>文件中加入以下代码：</p> <pre><code>#File: app/code/Pulsestorm/KnockoutTutorial/view/frontend/templates/content.phtml &lt;div data-bind=&quot;template:&#039;Pulsestorm_KnockoutTutorial/hello&#039;&quot;&gt;&lt;/div&gt; </code></pre> <p>这里我们用了模板绑定，并且把<code>Pulsestorm_KnockoutTutorial/hello</code>字符串传递给他。现在如果你刷新页面的话(记得清空缓存)，你将会在浏览器 console 中看到如下错误信息：</p> <pre><code>&gt;Get http://127.0.0.1/pub/static/frontend/Magento/luma/en_US/Pulsestorm_KnockoutTutorial/template/hello.html 404 (Not Found) </code></pre> <p>Magento 用我们传递给他的字符串（<code>Pulsestorm_KnockoutTutorial/hello</code>）构造一个 URL ，注意看这个构造出的URL和字符串各部分的联系。</p> <p>让我们添加如下文件：</p> <pre><code>#File: app/code/Pulsestorm/KnockoutTutorial/view/frontend/web/template/hello.html &lt;p data-bind=&quot;style:{fontSize:&#039;24px&#039;}&quot;&gt;Hello World&lt;/p&gt; </code></pre> <p>重新载入页面，你会看到 Magento 已经加载了该模板并且应用了KnockoutJS绑定。</p> <p>这项功能使我们不再需要使用<code>&lt;script type=&quot;text/html&quot;&gt;</code>，有助于模板复用。（This feature allows us to avoid littering our HTML page with <code>&lt;script type=&quot;text/html&quot;&gt;</code> tags whenever we need a new template, and encourages template reuse between UI and UX features.）</p> <h2 id="no-view-model"><a name="no-view-model" href="#no-view-model"></a>No View Model</h2> <p>回到<code>initialize.js</code>模块，Magento 设置好模板引擎之后，调用了 KnockoutJS 的applyBindings 方法。这个调用开始了当前页面的渲染。看下代码，立马发现一件事情。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/initialize.js ko.setTemplateEngine(templateEngine); ko.applyBindings(); </code></pre> <p>Magento 调用<code>applyBindings</code>没有传递任何 view model。虽然这是一个有效的 KnockoutJS 调用——让 KnockoutJS 应用绑定，但没有数据或view model 逻辑，这么做看起来一点意义也没有。What is a view without data going to be good for?</p> <p>在标准的 KnockoutJS 系统中，这样做确实一点意义也没有。要理解这一步Magento在做什么，我就得回到 KnockoutJS 的初始化。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/initialize.js define([     //...     &#039;./bind/scope&#039;,     //... ], </code></pre> <p>Magento 的 KnockoutJS 团队创建了一个名为<code>scope</code>的自定义绑定。下面是一<code>scope</code>绑定应用的例子，代码是 Magento 2 主页中用到的。</p> <pre><code>&lt;li class=&quot;greet welcome&quot; data-bind=&quot;scope: &#039;customer&#039;&quot;&gt;     &lt;span data-bind=&quot;text: customer().fullname ? $t(&#039;Welcome, %1!&#039;).replace(&#039;%1&#039;, customer().fullname) : &#039;Default welcome msg!&#039;&quot;&gt;&lt;/span&gt; &lt;/li&gt; </code></pre> <p>当你向下面这样调用<code>scope</code>的时候，</p> <pre><code>data-bind=&quot;scope: &#039;customer&#039;&quot; </code></pre> <p>Magento 将会对该节点及其子节点应用<strong>customer</strong> view model</p> <p>你可能会想——见鬼，<strong>customer</strong> view model 是什么玩意儿？</p> <p>如果你查看主页的源代码，再往下看一点(源代码在105行)，你应该会看到如下标签。</p> <pre><code>&lt;script type=&quot;text/x-magento-init&quot;&gt; {     &quot;*&quot;: {         &quot;Magento_Ui/js/core/app&quot;: {             &quot;components&quot;: {                 &quot;customer&quot;: {                     &quot;component&quot;: &quot;Magento_Customer/js/view/customer&quot;                 }             }         }     } } &lt;/script&gt; </code></pre> <p>我们本系列的第一篇文章讲过，Magento 遇到<code>text/x-magento-init</code>script 标签，属性为<code>*</code>，它将：</p> <ol> <li>初始化<code>Magento_Ui/js/core/app</code>RequireJS 模块。</li> <li>调用<code>Magento_Ui/js/core/app</code>模块的返回方法，并将后面的数据对象传递给他。</li> </ol> <p><code>Magento_Ui/js/core/app</code>模块 <strong>instantiates KnockoutJS view models</strong> to use with the scope attribute.（实例化 scope 自定义绑定要用的view model）。这是怎么实现的超出本篇文章的范围了，不过总的来说，Magento will instantiate a new javascript object for each individual RequireJS module configured as a <code>component</code>, and that new object becomes the view model.</p> <p>下面我们用<code>x-magento-init</code>举个例子，Magento查找<code>components</code>键，该键对应的是一个键值对。</p> <pre><code>&quot;customer&quot;: {     &quot;component&quot;: &quot;Magento_Customer/js/view/customer&quot; } </code></pre> <p>对<code>customer</code>键，Magneto 会执行类似下面的代码：</p> <pre><code>//gross over simplification var ViewModelConstructor = requirejs(&#039;Magento_Customer/js/view/customer&#039;); var viewModel = new ViewModelConstructor; viewModelRegistry.save(&#039;customer&#039;, viewModel); </code></pre> <p>如果某些组件对象有额外的数据</p> <pre><code>&quot;customer&quot;: {     &quot;component&quot;: &quot;Magento_Customer/js/view/customer&quot;,     &quot;extra_data&quot;:&quot;something&quot; } </code></pre> <p>Magento 会将这些数据一并放入view model</p> <p>一旦上述代码执行完毕，view model registry 就会拥有一个名为<code>customer</code>的view model。Magento 对<code>data-bind=&quot;scope: &#039;customer&#039;&quot;</code>应用的绑定就是这个view model。</p> <p>如果我们查看<code>scope</code>自定义绑定的实现代码的话，</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/bind/scope.js define([     &#039;ko&#039;,     &#039;uiRegistry&#039;,     &#039;jquery&#039;,     &#039;mage/translate&#039; ], function (ko, registry, $) {     &#039;use strict&#039;;      //...         update: function (el, valueAccessor, allBindings, viewModel, bindingContext) {             var component = valueAccessor(),                 apply = applyComponents.bind(this, el, bindingContext);              if (typeof component === &#039;string&#039;) {                 registry.get(component, apply);             } else if (typeof component === &#039;function&#039;) {                 component(apply);             }         }     //...  }); </code></pre> <p><code>registry.get(component, apply);</code>行从 view model registry 处获得那个view model，之后的代码实际上是应用该 view model</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/ko/bind/scope.js  //the component variable is our viewModel function applyComponents(el, bindingContext, component) {     component = bindingContext.createChildContext(component);      ko.utils.extend(component, {         $t: i18n     });      ko.utils.arrayForEach(el.childNodes, ko.cleanNode);      ko.applyBindingsToDescendants(component, el); } </code></pre> <p><code>registry</code>变量来自于<code>uiRegistry</code>模块，该模块实际上是<code>Magento_Ui/js/lib/registry/registry</code>。</p> <pre><code>vendor/magento/module-ui/view/base/requirejs-config.js 17:            uiRegistry:     &#039;Magento_Ui/js/lib/registry/registry&#039;, </code></pre> <p>如果感觉脑子不够用了，别担心。如果你想看看某个scope绑定中可用的数据，下面的debugging 代码会很有帮助。</p> <pre><code>&lt;li class=&quot;greet welcome&quot; data-bind=&quot;scope: &#039;customer&#039;&quot;&gt;     &lt;pre data-bind=&quot;text: ko.toJSON($data, null, 2)&quot;&gt;&lt;/pre&gt;     &lt;!-- ... --&gt; &lt;/li&gt; </code></pre> <p>如果你对 Magento如何创建 view model 的真实实现细节感兴趣的话（上面的简化伪代码不能满足你的好奇心），你可以从<code>Magento_Ui/js/core/app</code>模块下手。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/core/app.js define([     &#039;./renderer/types&#039;,     &#039;./renderer/layout&#039;,     &#039;Magento_Ui/js/lib/ko/initialize&#039; ], function (types, layout) {     &#039;use strict&#039;;      return function (data) {         types.set(data.types);         layout(data.components);     }; }); </code></pre> <p>这个模块依赖<code>Magento_Ui/js/core/renderer/layout</code>模块，正是这个模块创建了 view model，并将他们添加到view model registry 中。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/core/renderer/layout.js </code></pre> <p>你可去上面的文件研究 view model 是怎么创建出来的。</p> <h2 id="a-component-by-any-other-name"><a name="a-component-by-any-other-name" href="#a-component-by-any-other-name"></a>A component by Any Other Name</h2> <p>One sticky wicket in all this is the word <code>component</code>. <code>scope</code>绑定加上<code>x-magento-init</code> is basically a different take on <a href="http://knockoutjs.com/documentation/component-binding.html" target="_blank">the native KnockoutJS component system</a>.</p> <p>Magento 使用了和 KnockoutJS 相同的<code>component</code>这一术语，他们实际上不是一回事情，这下简直开启了一个混乱的新世界。即使是<a href="http://devdocs.magento.com/guides/v2.0/javascript-dev-guide/javascript/js_overview.html" target="_blank">Magento官方文档</a>，看起来也没有说清楚什么是<code>component</code>什么不是。Such is life on a large software team where the left hand doesn’t know what the right hand is doing — and the rest of the body is freaking out about a third hand growing out of its back.(哈哈，翻不出味道，自己领会一下，挺幽默的！)</p> <p>当你和同事讨论这些特性或者是在社区提问时，区分 KnockoutJS components 和Magento components 是很重要的哦。</p> <h2 id="changes-in-the-2.1-release-candidate"><a name="changes-in-the-2.1-release-candidate" href="#changes-in-the-2.1-release-candidate"></a>Changes in the 2.1 Release Candidate</h2> <p>今天的总结，我们要讨论一下 Magento 2.1 版本的一些改变。从概念上讲，系统仍然是相同的，只是细节有一点变化。</p> <p>第一，KnockoutJS 的初始化现在发生在<code>Magento_Ui/js/lib/knockout/bootstrap</code>RequireJS 模块。</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/knockout/bootstrap.js define([     &#039;ko&#039;,     &#039;./template/engine&#039;,     &#039;knockoutjs/knockout-es5&#039;,     &#039;./bindings/bootstrap&#039;,     &#039;./extender/observable_array&#039;,     &#039;./extender/bound-nodes&#039;,     &#039;domReady!&#039; ], function (ko, templateEngine) {     &#039;use strict&#039;;      ko.uid = 0;      ko.setTemplateEngine(templateEngine);     ko.applyBindings(); }); </code></pre> <p>Magento 核心开发团队将所有的 binding loading 移到<code>Magento_Ui/js/lib/knockout/bindings/bootstrap</code>模块，该模块位于：</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/lib/knockout/bindings/bootstrap.js </code></pre> <p>最后，the “Magento Javascript Component” returned by <code>Magento_Ui/js/core/app</code> has a changed method signature that includes a merge parameter, and the arguments to the <code>layout</code> function make it clear <code>layout‘s</code> signature has changed as well.</p> <pre><code>#File: vendor/magento/module-ui/view/base/web/js/core/app.js define([     &#039;./renderer/types&#039;,     &#039;./renderer/layout&#039;,     &#039;../lib/knockout/bootstrap&#039; ], function (types, layout) {     &#039;use strict&#039;;      return function (data, merge) {         types.set(data.types);         layout(data.components, undefined, true, merge);     }; }); </code></pre> <p>超越实现细节，这些更改揭露出一个事实，Magento 的 js 模块和框架在频繁变动中，不同于PHP代码，Magento 的 RequireJS 模块没有<code>@api</code>标识来表示稳定性。</p> <p>Unless you absolutely need to, it’s probably best to steer clear of dynamically changing the behavior of these core modules, and keep your own javascript as separate as possible。</p> <h2 id="下载"><a name="下载" href="#下载"></a>下载</h2> <p><a href="https://github.com/PiscesThankIT/Magento-2-KnockoutJS-Integration" target="_blank">实例代码下载</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_the-curious-case-of-magento-2-mixins/]]></link>
		<title><![CDATA[The Curious Case of Magento 2 Mixins]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><a href="https://alanstorm.com/the-curious-case-of-magento-2-mixins/">原文地址</a></p> <p>这篇要说的是 Magento 2 的 Mixins 。说它奇怪是因为 Mixins 这个命名不正确，有歧义，他其实是 RequireJS monkey patching 。（Monkey Patching 指的是在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在代码运行时发挥作用，不会修改源码。）</p> <p>本文的目标是教会大家用 Magento 2 js 方法安全地 overwrite js method。这已经超过了平常 RequireJS 工具的范畴。</p> <p>我们将快速过一下几个概念，然后说一说 Magento js 系统相关的一些特性，最后讨论这个名称奇怪的 mixins 系统。</p> <h2 id="什么是-mixin-？"><a href="#什么是-mixin-？" name="什么是-mixin-？"></a>什么是 Mixin ？</h2> <p>Mixin 从某种角度看，是传统的类集成的替代方法。</p> <p>传统的面向对象编程中，你可能像下面这样定义三个类：</p> <pre><code>class A {     public function foo()     {     } }  class B extends A {     public function bar()     {     } }  class C extends B {     public function baz()     {     } }  $object = new C; </code></pre> <p>这样 <code>$object</code> 对象拥有 <code>baz</code> <code>bar</code> 和 <code>foo</code> 方法。</p> <p>Mixins 提供了另一种方式。通过 Mixins ，你可以组合类的方法到你的类中。伪代码看起来是这样的：</p> <pre><code>class A {     public function foo()     {     } }  class B {     public function bar()     {     } }  class C {     mixin A;     mixin B;      public function baz()     {     } } $object = new C; </code></pre> <p>注意这里没有继承，class C 从 class A 和 class B 中获得方法。</p> <p><a href="http://php.net/manual/en/language.oop5.traits.php">PHP 的 Traits</a>就是一种简单的 mixin 系统。在 PHP 中，你必须显示地声明 traits ，然后在你地类中组合这些 traits 。Traits 自身不能被实例化，php 类也不能被当成 traits 用。</p> <p><a href="http://ruby-doc.com/docs/ProgrammingRuby/html/tut_modules.html">Ruby</a>通过 “include” 来组合别的模块的方法。</p> <p>有些语言比如 Python 则通过多重继承来实现 Mixin</p> <h2 id="javascript-and-mixins,-sitting-in-a-tree"><a href="#javascript-and-mixins,-sitting-in-a-tree" name="javascript-and-mixins,-sitting-in-a-tree"></a>Javascript and Mixins, Sitting in a Tree</h2> <p>和 classes 不同，不同语言关于 mixin 的语法应该怎么写并没有形成共识。有些语言有明确的 mixins 而另一些语言只有事实上的 mixins</p> <p>Javascript 就是后者。js 不是基于类的语言，他是一种基于原型的语言。（所以可以说 js 没有类）</p> <p>通过 underscore.js 的 <code>extend</code> 方法，你可以获得 mixin-like 的行为。像下面这样：</p> <pre><code>var a = {     foo:function(){         //...     } };  var b = {     bar:function(){         //...     }  }  c = _.extend(a, b); </code></pre> <p>这样 c 对象拥有 foo 和 bar 方法。</p> <p>比较有迷惑性的是，underscore.js 也有一个方法叫 <a href="https://underscorejs.org/#mixin">mixin</a> 不过这个方法是用来往 underscore js 对象自身加方法的。</p> <h2 id="magento-uiclass-objects"><a href="#magento-uiclass-objects" name="magento-uiclass-objects"></a>Magento uiClass Objects</h2> <p>如果你已经阅读了 Alan Storm 的 <a href="https://alanstorm.com/category/magento-2/#magento-2-ui">UI Component 系列</a>，那么你已经熟悉 <a href="https://alanstorm.com/magento_2_uiclass_data_features/">Magento’s uiClass objects</a> 了。 这些对象也有一个 <code>extend</code> 方法。这个方法看起来和 underscore.js 的 <code>extend</code> 方法一样。</p> <pre><code>var b = {     bar:function(){         //...     }  } UiClass = requirejs('uiClass');  // class NewClass extends uiClass var NewClass = UiClass.extend(b);  // class AnotherNewClass extends NewClass var AnotherNewClass = NewClass.extend({});  var object = new NewClass; object.bar(); </code></pre> <p>不过，<code>uiClass extend</code> 方法的用途有点不一样。<code>uiClass extend</code> 的目的是在原来的 js constructoer function 的基础上创建一个新的 js constructor function。所以上面的 <code>NewClass</code> 没有 <code>bar</code> 方法，但是他实例化出来的对象有。</p> <p>这看起来更像是直接继承，但是考虑到 <code>uiClass</code> 的实现细节，可能有些人就觉得叫 mixin 挺合适的。</p> <p>下面我们要切换一个话题。</p> <h2 id="magento-2-requirejs-mixins"><a href="#magento-2-requirejs-mixins" name="magento-2-requirejs-mixins"></a>Magento 2 RequireJS Mixins</h2> <p>Magento 2 的 <code>requirejs-config.js</code> 文件有一个 <code>mixin</code> 用法。<code>mixin</code> 这个名字跟我们编程语言中的 mixin 的内涵没啥关系，暂时把他理解成一个名字就好。</p> <p>虽然我们一直在吐槽这个名字取得不好，但是这功能本身还是很好很重要的哦。Magento 2 RequireJS mixins 让你监听任意 RequireJS module 的实例化，并且让你在实例化返回对象前可以修改他。</p> <p>下面实验一下，首先我们弄一个空的模块来做实验。</p> <p>可以通过 alan 的工具 <a href="https://github.com/astorm/pestle">pestle commands</a> 来创建一个空模块</p> <pre><code>$ pestle.phar generate_module Pulsestorm RequireJsRewrite 0.0.1 $ php bin/magento module:enable Pulsestorm_RequireJsRewrite $ php bin/magento setup:upgrade </code></pre> <p>如果你想手动创建模块的话，看这里 <a href="https://www.hellomagento2.com/alan-magento-2-mvvm-mvc/">Magento 2 简介 —— 不再是 MVC</a></p> <p>下面创建一个 <code>requirejs-config.js</code> 文件</p> <pre><code>//File: app/code/Pulsestorm/RequireJsRewrite/view/base/requirejs-config.js var config = {     'config':{         'mixins': {             'Magento_Customer/js/view/customer': {                 'Pulsestorm_RequireJsRewrite/hook':true             }         }     } }; </code></pre> <p>然后创建下面的</p> <pre><code>//File: app/code/Pulsestorm/RequireJsRewrite/view/base/web/hook.js define([], function(){     'use strict';     console.log("Called this Hook.");     return function(targetModule){         targetModule.crazyPropertyAddedHere = 'yes';         return targetModule;     }; }); </code></pre> <p>下面打开 Magento 首页，你会在浏览器 console 中看到：</p> <pre><code>Called this Hook </code></pre> <p>在浏览器的 console 中我们来看看这个模块 <code>Magento_Customer/js/view/customer</code>，我们会发现这个家伙已经有了一个新的属性 <code>crazyPropertyAddedHere</code></p> <pre><code>&gt; module = requirejs('Magento_Customer/js/view/customer'); &gt; console.log(module.crazyPropertyAddedHere) "yes" </code></pre> <p>也就是说上面的代码，我们修改了 <code>Magento_Customer/js/view/customer</code> 返回的对象。</p> <p>如果合理使用的话，这个功能可是非常强大呢。</p> <h2 id="what-just-happened?"><a href="#what-just-happened?" name="what-just-happened?"></a>What Just Happened?</h2> <pre><code>//File: app/code/Pulsestorm/RequireJsRewrite/view/base/requirejs-config.js var config = {     'config':{         'mixins': {             'Magento_Customer/js/view/customer': {                 'Pulsestorm_RequireJsRewrite/hook.js':true             }         }     } }; </code></pre> <p><code>requirejs-config.js</code> 文件让每个 Magento module 都可以给 RequireJS 加配置。可以查看这里 <a href="https://www.hellomagento2.com/alan-magento-2-and-requirejs/">Magento 2 and RequireJS </a></p> <p><code>mixins</code> 这个配置不是 RequireJS 里面的，<a href="https://magento.stackexchange.com/questions/142826/how-are-the-things-magento-2-calls-mixins-implemented">这是 Magento 引入的</a>。这一段就是告诉 Magento ，请你监听 <code>Magento_Customer/js/view/customer</code> 模块，然后让 <code>Pulsestorm_RequireJsRewrite/hook</code> 干活。</p> <p>然后我们就定义了 <code>Pulsestorm_RequireJsRewrite/hook</code> 模块</p> <pre><code>//File: app/code/Pulsestorm/RequireJsRewrite/view/base/web/hook.js define([], function(){     'use strict';     console.log("Called this Hook.");     return function(targetModule){         targetModule.crazyPropertyAddedHere = 'yes';         return targetModule;     }; }); </code></pre> <p>如果你不清楚 RequireJS 模块名字和 URL 之间的关系，请阅读 <a href="https://alanstorm.com/category/magento-2/#magento-2-mvc">Magento 2 for PHP MVC Developers 系列</a></p> <p>“listener/hook” 的模块都是标准的 RequireJS 模块。他们需要返回一个 callable object (比如 js 的 function)。上面返回的 function 就是模块 loading 后要执行的。他有一个参数 （targetModule），这个参数代表 <code>Magento_Customer/js/view/customer</code> 返回的东东。</p> <p>不管咱们的 <code>Pulsestorm_RequireJsRewrite/hook</code> 返回什么，它都被当作跟原来一样的东东。这就是为啥 <code>Magento_Customer/js/view/customer</code> 拥有了 <code>crazyPropertyAddedHere</code> 属性。</p> <h2 id="class-rewrites-for-javascript"><a href="#class-rewrites-for-javascript" name="class-rewrites-for-javascript"></a>Class Rewrites for Javascript</h2> <p>上面我们增加了新的属性，我们还可以替换掉原来模块的方法。</p> <pre><code>define([], function(){     'use strict';     console.log("Called this Hook.");     return function(targetModule){         targetModule.someMethod = function(){             //replacement for `someMethod         }         return targetModule;     }; }); </code></pre> <p>如果我们监听的模块返回的是基于 <code>uiClass</code> 的对象呢？你可以用 <code>uiClass</code> 的 <code>extend</code> 方法，但是用 <code>uiClass</code> 的 <code>_super()</code> 调用其父类的方法。</p> <pre><code>define([], function(){     'use strict';     console.log("Called this Hook.");     return function(targetModule){         //if targetModule is a uiClass based object         return targetModule.extend({             someMethod:function()             {                 var result = this._super(); //call parent method                  //do your new stuff                  return result;             }         });     }; }); </code></pre> <p>这个功能很强大，但是跟 Magento 1 的 class rewrite 和 Magento 2 的 <code>&lt;preference&gt;</code> 一样，这个是“赢家通吃”的。比如多个开发修改同一个 function ，那么最终只有一个人的代码生效。</p> <p>好在 Magento 应对这种情况还是有解决办法的，那就是使用 <code>mage/utils/wrapper</code></p> <h2 id="wrapping-function-calls"><a href="#wrapping-function-calls" name="wrapping-function-calls"></a>Wrapping Function Calls</h2> <p><code>mage/utils/wrapper</code> 类似 <a href="https://alanstorm.com/magento_2_object_manager_plugin_system/">Magento 2 backend around plugin</a></p> <p>下面举个例子：</p> <pre><code>var example = {}; example.foo = function (){     console.log("Called foo"); }  var wrapper = requirejs('mage/utils/wrapper');  var wrappedFunction = wrapper.wrap(example.foo, function(originalFunction){         console.log("Before");     originalFunction();     console.log("After"); });  //call wrapped function wrappedFunction();  //change method definition to use wrapped function example.foo = wrappedFunction; </code></pre> <p>如果你找个 magento 的站点实验下，那么我们可以看到下面这样的输出：</p> <pre><code>Before Called foo After </code></pre> <p><code>wrap</code> 方法接受两个参数。第一个是原来的 function （拿饺子打比方，就是饺子馅），第二个参数是你要增加的东西（饺子皮）。<code>originalFunction</code> 指代 example.foo 。</p> <p>wrapper 模块的作用是不用改原有的代码，就把一个已有的 function 和新的代码包在一起。</p> <p>wrapper 带来的好处还有，如果好几个人 wrap 同一段代码，那么他们都是有效的，而不会出现像上面那样 “赢家通吃” 的局面。</p> <pre><code>var wrappedFunction2 = wrapper.wrap(wrappedFunction, function(originalFunction){     console.log("Before 2");     originalFunction();     console.log("After 2"); });  wrappedFunction2(); </code></pre> <p>结果如下：</p> <pre><code>Before 2 VM502:9 Before VM502:3 Called foo VM502:11 After VM545:4 After 2 </code></pre> <p>所以上面我们“赢家通吃”的代码可以改进为：</p> <pre><code>define(['mage/utils/wrapper'], function(wrapper){     'use strict';     console.log("Called this Hook.");     return function(targetModule){          var newFunction = targetModule.someFunction;         var newFunction = wrapper.wrap(newFunction, function(original){             //do extra stuff              //call original method             var result = original();              //do extra stuff              //return original value             return result;         });          targetModule.someFunction = newFunction;         return targetModule;     }; }); </code></pre> <h2 id="why-call-this-a-mixin"><a href="#why-call-this-a-mixin" name="why-call-this-a-mixin"></a>Why Call this a Mixin</h2> <p>不纠结，不翻译，嘿嘿。。</p> <h2 id="相关参考"><a href="#相关参考" name="相关参考"></a>相关参考</h2> <p><a href="https://www.hellomagento2.com/alan_magento-2s-base-javascript-class/">Magento 2’s Base Javascript Class</a><br /> <a href="https://www.hellomagento2.com/alan_magento_2_simplest_ui_knockout_component/">Magento 2: Simplest UI Knockout Component</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-javascript-init-ways/]]></link>
		<title><![CDATA[<code>&lt;script type="text/x-magento-init"&gt;</code>]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>我们在 magento 2 的 phtml 中经常会看到 <code>&lt;script type="text/x-magento-init"&gt;</code> 和 <code>data-mage-init</code> ，那么这两个标签是用来做什么的？本篇将给出解释，并说明这样设计的用意。</p> <h2 id="magento-2-的自定义设计"><a href="#magento-2-的自定义设计" name="magento-2-的自定义设计"></a>Magento 2 的自定义设计</h2> <p><em>首先 <code>&lt;script type="text/x-magento-init"&gt;</code> 是 Magento 2 的自定义设计。</em></p> <p>我们新建一个 html 文件：</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt;     alert('common'); &lt;/script&gt; &lt;script type="text/x-magento-init"&gt;     alert('magento'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>然后从浏览器中访问他，我们会看到 <code>common</code> 的 alert 但不会看到 <code>magento</code> 的 alert 。这是因为浏览器不认识 <code>type="text/x-magento-init"</code> 的这个 <code>&lt;script&gt;</code>，所以会直接忽略它。</p> <h2 id="创建一个演示模块"><a href="#创建一个演示模块" name="创建一个演示模块"></a>创建一个演示模块</h2> <p>我们还是以 <code>ThankIT_HelloWorld</code> 为基础。</p> <h3 id="创建-controller"><a href="#创建-controller" name="创建-controller"></a>创建 Controller</h3> <p>File:app\code\ThankIT\HelloWorld\Controller\Javascript\Example.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Javascript;  class Example extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         return $this-&gt;resultPageFactory-&gt;create();     } } </code></pre> <h3 id="创建-layout"><a href="#创建-layout" name="创建-layout"></a>创建 layout</h3> <p>File:app\code\ThankIT\HelloWorld\view\frontend\layout\helloworld_javascript_example.xml</p> <pre><code>&lt;?xml version="1.0" ?&gt; &lt;page layout="1column" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;body&gt;         &lt;referenceContainer name="content"&gt;             &lt;block class="ThankIT\HelloWorld\Block\Javascript\Example" name="Javascript.Example" template="ThankIT_HelloWorld::javascript/example.phtml"/&gt;         &lt;/referenceContainer&gt;     &lt;/body&gt; &lt;/page&gt; </code></pre> <h3 id="创建-block"><a href="#创建-block" name="创建-block"></a>创建 Block</h3> <p>File:app\code\ThankIT\HelloWorld\Block\Javascript\Example.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Javascript;  class Example extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         return $this-&gt;resultPageFactory-&gt;create();     } } </code></pre> <h3 id="创建-template"><a href="#创建-template" name="创建-template"></a>创建 template</h3> <p>File:app\code\ThankIT\HelloWorld\view\frontend\templates\javascript\example.phtml</p> <p>内容为空</p> <p>然后刷新缓存，访问 url <code>http://example/helloworld/javascript/example</code><br /> 我们就会看到带 header 和 footer 的页面，内容为空。</p> <p>这里没有什么稀奇的，只是一个准备工作，预热一下。</p> <h2 id="创建一个-requirejs-模块"><a href="#创建一个-requirejs-模块" name="创建一个-requirejs-模块"></a>创建一个 requirejs 模块</h2> <p>我们先关闭掉 fpc (Full page caching)，这样不用每次清缓存看结果。</p> <p>我们先在 <code>File:app\code\ThankIT\HelloWorld\view\frontend\templates\javascript\example.phtml</code> 中填入以下内容</p> <pre><code>&lt;script type="text/javascript"&gt;     console.log('hello');     jQuery(function($){         alert("Hello World");     }); &lt;/script&gt; </code></pre> <p>然后我们刷新页面，查看控制台，会发现：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/jquery-is-not-defined.png" alt="jQuery is not defined" /></p> <p>这是因为 Magento 2 使用 RequireJS 做基础，对 JS 进行模块化，默认不会使用全局命名空间，<code>jQuery</code> 也不再暴露到全局空间。我们应该使用 <code>RequireJS</code> 的方式来访问 js 模块。</p> <p>Magento 2 本身就是集成了 <code>jQuery</code> 的，所以我们可以这样访问：</p> <pre><code>&lt;script type="text/javascript"&gt;     requirejs(['jquery'], function($) {         alert("Hello World");     }); &lt;/script&gt; </code></pre> <p>关于 <code>RequireJS</code> 可以参阅 <a href="https://www.hellomagento2.com/alan-magento-2-and-requirejs/" target="_blank" rel="noopener">Magento 2 and RequireJS (翻译)</a></p> <p>我们现在创建以下文件：<br /> File: app\code\ThankIT\HelloWorld\view\frontend\web\example.js</p> <pre><code>define([], function(){     alert("A simple RequireJS module");     var mageJsComponent = function()     {         alert("A simple magento component.");     };     return mageJsComponent; }); </code></pre> <p>这样我们就定义了一个简单的 RequireJS module，这个模块的位置是 <code>app\code\ThankIT\HelloWorld\view\frontend\web\example.js</code>，那么他的模块名，在没有重新命名的情况下，就是 <code>ThankIT_HelloWorld/example</code>。</p> <p>然后我们来更改 phtml</p> <pre><code>&lt;script type="text/javascript"&gt;     requirejs(['ThankIT_HelloWorld/example'], function($) {         alert("Hello World");     }); &lt;/script&gt; </code></pre> <p>刷新网页，然后我们会先看到弹出框 A simple RequireJS module，然后是 Hello World。就是我们先加载 <code>ThankIT_HelloWorld/example</code> 然后执行 <code>alert("Hello World");</code></p> <p>好，这样看来，我们已经会给 Magento 2 加 js module ，并且在 phtml 中使用它了。</p> <p>要了解更详细的解释，请参阅 <a href="https://www.hellomagento2.com/alan-magento-2-javascript-init-scripts/" target="_blank" rel="noopener">Magento 2 Javascript Init Scripts（翻译）</a></p> <h2 id="&#96;&#96;"><a href="#&#96;&#96;" name="&#96;&#96;"></a><code>&lt;script type="text/x-magento-init"&gt;</code></h2> <p>让我们来修改 phtml 为以下内容：</p> <pre><code>&lt;script type="text/x-magento-init"&gt;     {         "*": {             "ThankIT_HelloWorld/example":{}         }     } &lt;/script&gt; </code></pre> <p><code>example</code> 的内容不变：</p> <pre><code>define([], function(){     alert("A simple RequireJS module");     var mageJsComponent = function()     {         alert("A simple magento component.");     };     return mageJsComponent; }); </code></pre> <p>这时候刷新页面（有时也需要情况浏览器缓存），我们会发现，这次先弹出 <code>A simple RequireJS module</code> 然后弹出 <code>A simple magento component.</code></p> <p>上面我们用 <code>requirejs</code> 的方法，并没有弹出 <code>A simple magento component.</code> 也就是说，<code>&lt;script type="text/x-magento-init"&gt;</code> 方式不仅会使用 <code>requirejs</code> 的方式加载该模块，而且还湖调用它。</p> <h2 id="传参"><a href="#传参" name="传参"></a>传参</h2> <p>phtml 改成：</p> <pre><code>&lt;div id="text"&gt;&lt;/div&gt; &lt;script type="text/x-magento-init"&gt;     {         "#text": {             "ThankIT_HelloWorld/example":{"config":{"text":"Hello Magento 2, Hello ThankIT ..."}}         }     } &lt;/script&gt; </code></pre> <p><code>example</code> 改成:</p> <pre><code>define(['jquery'], function($){     var setText = function(config, node) {         console.log(config);         console.log(node);         $(node).html(config.config.text);     }     return setText; }); </code></pre> <p>清空浏览器缓存，刷新页面，这时候，我们的页面会是这样的：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/node-config-results.png" alt="magento 2 x-magento-init" /><br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/console.log_.results.png" alt="magento 2 x-magento-init console log" /></p> <p>不过这里<code>console.log</code> 出的结果有点奇怪，按照我的理解，输出的 node 不应该含有 <code>Hello Magento 2, Hello ThankIT ...</code> 内容。。。有清楚的朋友请给我留个言吧，感谢！</p> <p><em>通过上面这个例子，我们知道 <strong> <code>&lt;script type="text/x-magento-init"&gt;</code> 方式可以传递要作用的节点，可以传递配置参数，并且之后被调用执行。</strong>通过这样的设计，Magento 鼓励开发者避免在 RequireJS 模块中硬编码 DOM 节点。传递的配置参数可以由服务器端生成。这进一步分离的会让代码更清晰。</em></p> <h2 id="data-mage-init"><a href="#data-mage-init" name="data-mage-init"></a>data-mage-init</h2> <p>这个方式实际上和 <code>&lt;script type="text/x-magento-init"&gt;</code> 是一样的。<br /> 我们把 phtml 改成下面这样：</p> <pre><code>&lt;div data-mage-init='{"ThankIT_HelloWorld/example": {"config":{"text":"Hello Magento 2, Hello ThankIT ... use data-mage-init ..."}}}'&gt;A single div&lt;/div&gt; </code></pre> <p>刷新页面，是不是先看到 <code>A single div</code> ，随后被替换成了 <code>Hello Magento 2, Hello ThankIT ... use data-mage-init ...</code></p> <p><em>注意，我们的属性中使用的是单引号</em></p> <pre><code>&lt;div data-mage-init='...'&gt;A single div&lt;/div&gt; </code></pre> <p>这是必要的，<code>data-mage-init</code> 属性会严格按照 JSON 格式解析，就是说 JSON 对象必须使用双引号，所以我们的属性就只能用单引号了。</p> <h2 id="关于如何实现的-type="><a href="#关于如何实现的-type=" name="关于如何实现的-type="></a>关于如何实现的 type=”text/x-magento-init”</h2> <p>The code that uses them is located in <code>lib/web/mage/apply/scripts.js</code></p> <p>参考 <a href="https://magento.stackexchange.com/questions/89187/in-magento2-what-is-script-type-text-x-magento-init" target="_blank" rel="noopener">In Magento2 what is<code>&lt;script type=“text/x-magento-init”&gt;</code>?</a></p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="https://www.hellomagento2.com/alan-magento-2-and-requirejs/" target="_blank" rel="noopener">Magento 2 and RequireJS (翻译)</a><br /> <a href="https://www.hellomagento2.com/alan-magento-2-javascript-init-scripts/" target="_blank" rel="noopener">Magento 2 Javascript Init Scripts（翻译）</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-and-konockoutjs/]]></link>
		<title><![CDATA[Magento 2 and konockoutjs]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇将通过实验来介绍 ko 的模版绑定、自定义绑定和组件绑定，然后在此基础上介绍 magento 2 对 ko 的扩展。最后通过一个例子来介绍如何在 magento 2 中使用 ko 绑定。</p> <h2 id="准备"><a href="#准备" name="准备"></a>准备</h2> <p>在 <code>ThankIT_HelloWorld</code> 模块的基础上，我们来创建一个页面，用来做实验。</p> <p>File: app\code\ThankIT\HelloWorld\Controller\Knockoutjs\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Knockoutjs;  class Index extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         return $this-&gt;resultPageFactory-&gt;create();     } } </code></pre> <p>File:app\code\ThankIT\HelloWorld\view\frontend\layout\helloworld_knockoutjs_index.xml</p> <pre><code>&lt;?xml version="1.0" ?&gt; &lt;page layout="1column" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;body&gt;         &lt;referenceContainer name="content"&gt;             &lt;block class="ThankIT\HelloWorld\Block\Knockoutjs\Index" name="knockoutjs.index" template="ThankIT_HelloWorld::knockoutjs/index.phtml"/&gt;         &lt;/referenceContainer&gt;     &lt;/body&gt; &lt;/page&gt; </code></pre> <p>File:app\code\ThankIT\HelloWorld\Block\Knockoutjs\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Block\Knockoutjs;  use Magento\Framework\View\Element\Template;  class Index extends Template {  } </code></pre> <p>File:app\code\ThankIT\HelloWorld\view\frontend\templates\knockoutjs\index.phtml</p> <pre><code>&lt;p&gt;First name: &lt;strong data-bind="text:firstName"&gt;todo&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Last name: &lt;strong data-bind="text:lastName"&gt;todo&lt;/strong&gt;&lt;/p&gt; </code></pre> <p><em>注意：Magento 2 的 js 框架部分变化比较频繁，2.0 和 2.1 之间有较大差异，本文使用的是 2.1.7</em></p> <p>然后我们清空缓存，刷新页面，打开调试面板，会看到：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/ko-uncaught-reference-error.png" alt="ko" /></p> <p>假设我们在普通的页面中，我们尚未应用 <code>ko.applyBindings(obj)</code>，那么 <code>data-bind</code> 应该被浏览器忽略，我们是不会看到这样的错误的。</p> <p>所以 Magento 2 页面中自动调用了 <code>ko.applyBindings(obj)</code></p> <p>调用 <code>ko.applyBindings()</code> 部分的实现位于 <code>Magento_Ui/js/lib/knockout/bootstrap</code> 具体的文件位置位于 <code>vendor\magento\module-ui\view\base\web\js\lib\knockout\bootstrap.js</code>，文件内容如下：</p> <pre><code>/**  * Copyright © 2013-2017 Magento, Inc. All rights reserved.  * See COPYING.txt for license details.  */ /** Loads all available knockout bindings, sets custom template engine, initializes knockout on page */  define([     'ko',     './template/engine',     'knockoutjs/knockout-es5',     './bindings/bootstrap',     './extender/observable_array',     './extender/bound-nodes',     'domReady!' ], function (ko, templateEngine) {     'use strict';      ko.uid = 0;      ko.setTemplateEngine(templateEngine);     ko.applyBindings(); }); </code></pre> <p>至于他是怎样实现页面加载后，自动调用 <code>ko.applyBindings()</code> 的，此处先挖坑，留着以后填。</p> <p>这里先明白，Magento 2 对 ko 做了自定义，他会让 ko 自动进行初始化。</p> <h2 id="template-binding"><a href="#template-binding" name="template-binding"></a>template binding</h2> <p>我们先来看一个 ko 的模版绑定，看看 ko 原来的用法是怎样的。</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;ko&lt;/title&gt;     &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Participants&lt;/h2&gt; Here are the participants: &lt;div data-bind="template: { name: 'person-template', data: buyer }"&gt;&lt;/div&gt; &lt;div data-bind="template: { name: 'person-template', data: seller }"&gt;&lt;/div&gt; &lt;script type="text/html" id="person-template"&gt;     &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt;     &lt;p&gt;Credits: &lt;span data-bind="text: credits"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt;      function MyViewModel() {          this.buyer = { name: 'Franklin', credits: 250 };          this.seller = { name: 'Mario', credits: 5800 };      }      ko.applyBindings(new MyViewModel()); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>效果：<br /> <img class="img-resoponsive" src="/wp-content/uploads/2017/09/template-binding.png" alt="ko 模版绑定" /></p> <p>下面我们来看看 Magento 2 对 ko 模版引擎的改造后的用法。<br /> 将 phtml 改成以下内容：<br /> File:app\code\ThankIT\HelloWorld\view\frontend\templates\knockoutjs\index.phtml</p> <pre><code>&lt;div data-bind="template:'ThankIT_HelloWorld/hello'"&gt;&lt;/div&gt; </code></pre> <p>然后我们创建以下文件：<br /> File:app\code\ThankIT\HelloWorld\view\frontend\web\template\hello.html</p> <pre><code>&lt;p data-bind="style:{color:'red'}"&gt;Hello World&lt;/p&gt; </code></pre> <p>然后我们刷新页面，效果如下：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/magento2-ko-template-engine.png" alt="m2 模版引擎" /></p> <p>Magento 2 对 ko 模版引擎的改造让我们不需要用 <code>&lt;script type="text/html"&gt;</code> 来声明模版，把模版也从 <code>phtml</code> 文件中分离到独立的 <code>html</code> 文件中，有利于模版的复用。</p> <h2 id="ko-自定义绑定"><a href="#ko-自定义绑定" name="ko-自定义绑定"></a>ko 自定义绑定</h2> <p>我们先来看看 ko 的自定义绑定是怎样的：</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;ko&lt;/title&gt;     &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js"&gt;&lt;/script&gt;     &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;label&gt;&lt;input type="checkbox" data-bind="checked: giftWrap" /&gt; Gift wrap&lt;/label&gt; &lt;div data-bind="slideVisible: giftWrap, slideDuration:600, test:'just for test'"&gt;You have selected the option&lt;/div&gt; &lt;script type="text/javascript"&gt;     var viewModel = {         giftWrap: ko.observable(true)     };     ko.bindingHandlers.slideVisible = {     update: function(element, valueAccessor, allBindings) {         // console.log(element);         // First get the latest data that we're bound to         var value = valueAccessor();         // console.log(value);         // Next, whether or not the supplied model property is observable, get its current value         var valueUnwrapped = ko.unwrap(value);         // console.log(valueUnwrapped);         // console.log(allBindings);         // Grab some more data from another binding property         var duration = allBindings.get('slideDuration') ]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/requirejs-modularity-async/]]></link>
		<title><![CDATA[关于 RequireJS]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>文章没有什么特别之处，算是对 <a href="/alan-magento-2-and-requirejs/#requirejs-and-jquery-plugins">Magento 2 and RequireJS (翻译)</a>一点补充，主要是为了记录备查。</p> <p>RequireJS 主要做的就是模块化异步加载 JS</p> <p>Js 模块化为了便于维护和团队协作。</p> <p>参考：<br /> <a href="http://foio.github.io/requireJS/">RequireJS结构分析，实现自己的模块加载系统</a><br /> 这篇文章提到 RequireJS 通过 script dom element 方法来异步加载 js 模块。RequireJS 在代码层面控制模块的加载顺序（依赖）</p> <p>js 异步加载，是为了解决 js 加载时阻塞网页上其他资源的下载的问题，为了让页面内容更早展现在用户面前。</p> <p>参考:<br /> <a href="http://supersamchow.github.io/2016/05/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%92%8C%E6%97%A0%E9%98%BB%E5%A1%9E%E5%8A%A0%E8%BD%BD%E8%84%9A%E6%9C%AC%E7%9A%84%E7%90%86%E8%A7%A3/">浏览器线程阻塞和无阻塞加载脚本的理解</a><br /> <a href="http://www.cnblogs.com/giggle/p/5513769.html">JavaScript阻塞剖析与改善</a><br /> <a href="http://foio.github.io/javascript-async/">在网页中异步加载javascript</a></p> <p>例子</p> <pre><code>&lt;!-- File: require-example.html --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;My Sample Project&lt;/title&gt;         &lt;!-- data-main attribute tells require.js to load              scripts/main.js after require.js loads. --&gt;         &lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;My Sample Project&lt;/h1&gt;     &lt;/body&gt; &lt;/html&gt; </code></pre> <p>那么 require.js 会首先加载 <code>scripts/main.js</code></p> <pre><code>&lt;!-- File: scripts/main.js --&gt; console.log('load main'); require.config({     paths: {         "hello": "helper/world"     }, }); requirejs(['hello'], function(helper_world) {     var message = helper_world.getMessage();     console.log("I am second");     alert(message); }); </code></pre> <pre><code>//File: scripts/helper/world.js define([], function(){     var o = {};     o.getMessage = function()     {         return 'Hello Module World';     }     console.log("I am first load");     return o; }); </code></pre> <p>那么在控制台我们应该看到的是：</p> <pre><code>main.js:5  load main world.js:8 I am first load main.js:13 I am second </code></pre> <p><img src="/wp-content/uploads/2017/05/requirejs-dom.png" alt="" /></p> <p>验证通过 script dom element 异步加载。</p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-js-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/]]></link>
		<title><![CDATA[Magento 2 JS 开发入门]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>默认情况下，Magento 2 使用 RequireJS （可参考 <a href="https://www.hellomagento2.com/alan-magento-2-and-requirejs/#requirejs-and-jquery-plugins" target="_blank" rel="noopener">Magento 2 and RequireJS (翻译)</a> 和 <a href="https://www.hellomagento2.com/requirejs-modularity-async/" target="_blank" rel="noopener">关于 RequireJS</a>）来异步加载 js 模块，管理模块依赖。在这个大前提下，Magento 2 中使用的主要 JS 库是 jQuery 和 KnockoutJS （简称 ko），还使用了 AngularJS （used for the web based installer）和 Underscore (This provides some useful Javascript functions to manipulate Javascript arrays, functions, objects and collections.)</p> <p>另外 Magento 做了许多自定义的设置，比如对 ko 模版引擎的改造，让我们不需要用 <code>&lt;script type="text/html"&gt;</code> 来声明模版，也把模版从 phtml 文件中分离到独立的 html 文件中，有利于模版的复用。比如，创建了 ko 的自定义绑定 <code>scope</code> 。上面提到的可以参考 <a href="https://www.hellomagento2.com/magento-2-and-konockoutjs/" target="_blank" rel="noopener">Magento 2 and konockoutjs</a>。还有，<code>&lt;script type="text/x-magento-init"&gt;</code> 也是 Magento 2 的自定义设计（可参考 <a href="https://www.hellomagento2.com/magento-2-javascript-init-ways/" target="_blank" rel="noopener"><code>&lt;script type="text/x-magento-init"</code>&gt;</a>）。</p> <p>既然用到了 jQuery ，那么 jQuery 丰富的插件就绝对是绕不过去的话题。但是 jQuery 的插件并不都是符合 AMD 规范的，所以，我们需要用到 requireJS 的 <code>shim</code> ，参考 <a href="https://www.hellomagento2.com/requirejs-%E7%9A%84-shim-%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">RequireJS 的 shim 用法</a>。</p> <p><em>RequireJS 的 shim 解决的是加载非 AMD 规范模块的问题，并不限于 jQuery 的插件</em></p> <p>我们中文语境中的<strong> jQuery 插件</strong>，可能指的是 jQuery Plugin 或者是 jQuery widget。但是这两者是有差别的，参考 <a href="/jquery-plugin-and-widget" target="_blank">jQuery Plugin and Widget</a>。下面介绍 Magento 2 中的几个术语，是比较容易混淆的概念。</p> <table class="table table-hover"> <thead> <tr> <th>术语</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td>JavaScript component (JS component)</td> <td>Any separate .js file decorated as AMD module。 符合 AMD 规范的 JS 模块，通常都是一个文件一个模块</td> </tr> <tr> <td>Ui component</td> <td>JS component located in the Magento_Ui module, in the app/code/Magento/Ui/view directory. 他是 Magento_Ui 模块中的一组 JS ，位于 app/code/Magento/Ui/view 目录下</td> </tr> <tr> <td>jQuery UI widget</td> <td>A JS component/widget provided by jQuery UI library used in Magento. jQuery UI 中包含的组件，参考 <a href="http://jqueryui.com/" target="_blank" rel="noopener">jQuery UI</a></td> </tr> <tr> <td>jQuery widget</td> <td>Custom widget created using jQuery UI Widget Factory and decorated as AMD module. Many Magento JS components are jQuery widget. 使用 jQuery UI Widget Factory 创建并且符合 AMD 规范的 js 模块， Magento 中许多 js 组件都是 jQuery widget ，参考 <a href="http://devdocs.magento.com/guides/v2.0/javascript-dev-guide/widgets/jquery-widgets-about.html" target="_blank" rel="noopener">Magento jQuery widgets</a></td> </tr> </tbody> </table> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="http://devdocs.magento.com/guides/v2.0/javascript-dev-guide/javascript/js_overview.html" target="_blank" rel="noopener">JavaScript</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/jquery-plugin-and-widget/]]></link>
		<title><![CDATA[jQuery Plugin and Widget]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="创建-jquery-plugin"><a href="#创建-jquery-plugin" name="创建-jquery-plugin"></a>创建 jQuery Plugin</h2> <h3 id="方法一-在-jquery-命名空间上添加方法"><a href="#方法一-在-jquery-命名空间上添加方法" name="方法一-在-jquery-命名空间上添加方法"></a>方法一 在 jQuery 命名空间上添加方法</h3> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;jQuery plugin&lt;/title&gt;     &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt;     $.sayHello = function() {         console.log('Hello');     };       $.extend({         sayHi: function(name) {             console.log('Hi,' + (name ? name : 'ThankIT') + '!');         }     });     $.sayHello();     $.sayHi(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>效果：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/10/jquery-plugin-1.png" alt="jquery plugin" /></p> <p>此种方法扩展了 jQuery 本身，但它不能选中 DOM 元素。</p> <h3 id="方法二-在-&#96;$.fn&#96;-上添加方法"><a href="#方法二-在-&#96;$.fn&#96;-上添加方法" name="方法二-在-&#96;$.fn&#96;-上添加方法"></a>方法二 在 <code>$.fn</code> 上添加方法</h3> <p>在写插件之前，我们先了解下 jQuery 是怎么工作的。</p> <pre><code>$( "a" ).css( "color", "red" ); </code></pre> <p>这是很基础的 jQuery 代码。当你用 <code>$</code> 选中元素的时候，它会返回 jQuery 对象，返回的这个 jQuery 对象就包含 <code>css()</code> 方法，还有被选中的元素。 jQuery 对象是从 <code>$.fn</code> (jQuery.prototype 的别名)对象获得方法的。所以，我们可以在 <code>$.fn</code> 方法上添加方法来扩展 jQuery object</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;jQuery plugin&lt;/title&gt;     &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="hello"&gt;Hello&lt;/h1&gt; &lt;script type="text/javascript"&gt;     // case 1     $.sayHello = function() {         console.log('Hello');     };     $.extend({         sayHi: function(name) {             console.log('Hi,' + (name ? name : 'ThankIT') + '!');         }     });     $.sayHello();     $.sayHi();      // 在 jQuery 上扩展的方法无法选中元素     // Uncaught TypeError: $(...).sayHi is not a function     // $( "h1" ).sayHi();      // case 2     // 需要返回 this 以支持链式调用     $.fn.greenify = function() {         return this.css( "color", "green" );     };     $.fn.extend({         italic: function() {             return this.css("font-style","italic");         }     });      $( "h1" ).greenify();     $( "h1" ).italic();  &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>效果：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/10/jquery-plugin-2.png" alt="jquery plugin" /></p> <p>参考官方文档 <a href="http://learn.jquery.com/plugins/">jquery plugins</a></p> <h3 id="安全的插件结构"><a href="#安全的插件结构" name="安全的插件结构"></a>安全的插件结构</h3> <pre><code>;(function($,window,document,undefined){     // 插件代码 })(jQuery,window,document); </code></pre> <p>用自调用匿名函数包裹代码，形成一个作用域，避免对全局命名空间的污染。<br /> 使用 <code>;</code> 是为了避免：前面的代码没有以分号结尾，引入我们的 js 后，导致报错无法执行。</p> <p>比如：</p> <pre><code>var foo=function(){     //别人的代码 }//注意这里没有用分号结尾  //开始我们的代码。。。 (function(){     //我们的代码。。     alert('Hello!'); })(); </code></pre> <p>参考 <a href="http://www.cnblogs.com/Wayou/p/jquery_plugin_tutorial.html">jQuery插件开发精品教程，让你的jQuery提升一个台阶</a></p> <h2 id="创建-jquery-widget"><a href="#创建-jquery-widget" name="创建-jquery-widget"></a>创建 jQuery Widget</h2> <p><a href="http://learn.jquery.com/jquery-ui/">jQuery UI 官方文档</a><br /> 大部分 jQuery 插件是无状态的，完成某个动作就结束了。但是有些插件是有状态的，他们有生命周期和状态，widget factory 定义了如何创建和销毁他们，如何获取和设置选项，调用方法以及监听小部件触发的事件。这样的规范会让使用者更容易使用。</p> <p>例子：</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;jQuery plugin&lt;/title&gt;     &lt;link href="https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.css" rel="stylesheet"&gt;     &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.js"&gt;&lt;/script&gt;     &lt;script src="https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;   &lt;div id="my-widget1"&gt;color me&lt;/div&gt;   &lt;div id="my-widget2"&gt;color me&lt;/div&gt;   &lt;div id="my-widget3"&gt;color me&lt;/div&gt;   &lt;button id="disable"&gt;Toggle disabled option&lt;/button&gt;   &lt;button id="green"&gt;Go green&lt;/button&gt; &lt;/div&gt; &lt;style&gt;   .custom-colorize {     font-size: 20px;     position: relative;     width: 75px;     height: 75px;   }   .custom-colorize-changer {     font-size: 10px;     position: absolute;     right: 0;     bottom: 0;   }   &lt;/style&gt; &lt;script type="text/javascript"&gt; $( function() {     // the widget definition, where "custom" is the namespace,     // "colorize" the widget name     $.widget( "custom.colorize", {       // default options       options: {         red: 255,         green: 0,         blue: 0,          // Callbacks         change: null,         random: null       },        // The constructor       _create: function() {         this.element           // add a class for theming           .addClass( "custom-colorize" );          this.changer = $( "&lt;button&gt;", {           text: "change",           "class": "custom-colorize-changer"         })         .appendTo( this.element )         .button();          // Bind click events on the changer button to the random method         this._on( this.changer, {           // _on won't call random when widget is disabled           click: "random"         });         this._refresh();       },        // Called when created, and later when changing options       _refresh: function() {         this.element.css( "background-color", "rgb(" +           this.options.red +"," +           this.options.green + "," +           this.options.blue + ")"         );          // Trigger a callback/event         this._trigger( "change" );       },        // A public method to change the color to a random value       // can be called directly via .colorize( "random" )       random: function( event ) {         var colors = {           red: Math.floor( Math.random() * 256 ),           green: Math.floor( Math.random() * 256 ),           blue: Math.floor( Math.random() * 256 )         };          // Trigger an event, check if it's canceled         if ( this._trigger( "random", event, colors ) !== false ) {           this.option( colors );         }       },        // Events bound via _on are removed automatically       // revert other modifications here       _destroy: function() {         // remove generated elements         this.changer.remove();          this.element           .removeClass( "custom-colorize" )           .enableSelection()           .css( "background-color", "transparent" );       },        // _setOptions is called with a hash of all options that are changing       // always refresh when changing options       _setOptions: function() {         // _super and _superApply handle keeping the right this-context         this._superApply( arguments );         this._refresh();       },        // _setOption is called for each individual option that is changing       _setOption: function( key, value ) {         // prevent invalid color values         if ( /red]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/requirejs-%E7%9A%84-shim-%E7%94%A8%E6%B3%95/]]></link>
		<title><![CDATA[RequireJS 的 shim 用法]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<h2 id="综述"><a href="#综述" name="综述"></a>综述</h2> <p>RequireJS 遵循 <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD 规范</a>（异步模块定义）。理论上来说，RequireJS 加载的模块必须符合 AMD 规范，使用 define() 函数定义。但是，由于历史原因，大量的 js 库并不符合规范。这样加载非规范的模块，就需要用到 <code>shim</code></p> <p>比如 underscore 和 backbone 都不符合 AMD 规范，如果要加载他们，就要像这样使用：</p> <pre><code>require.config({ 　　　　shim: { 　　　　　　'underscore':{ 　　　　　　　　exports: '_' 　　　　　　}, 　　　　　　'backbone': { 　　　　　　　　deps: ['underscore', 'jquery'], 　　　　　　　　exports: 'Backbone' 　　　　　　} 　　　　} 　　}); </code></pre> <p><code>exports</code> 是模块的返回值，该值一定要与库暴露的全局变量名称一致。<br /> <code>deps</code> 表明模块的依赖，如果 A 模块依赖于 B 模块，而 A 模块不符合 AMD 规范，使用全局变量，那么 B 模块也必须使用全局变量，不然 A 模块会找不到 B 模块的依赖对象而报错。</p> <h2 id="准备"><a href="#准备" name="准备"></a>准备</h2> <p>下面开始做实验。<br /> File: test.html</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;shim&lt;/title&gt;     &lt;script src="https://cdn.bootcss.com/require.js/2.3.5/require.min.js" data-main="main.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;  &lt;/body&gt; &lt;/html&gt; </code></pre> <p>File: a.js</p> <pre><code>// 立即执行函数，不暴露私有成员 (function(window){     var a = {};     a.sayHello = function(){         alert("Hello this is A");         return 'Hello';     }     window.a = a; })(window) </code></pre> <p>File: main.js</p> <pre><code>require(['a'],function(a) {     console.log(a); }); </code></pre> <p>载入文档，在 console 中我们会看到，输出 <code>undefined</code><br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/shim-1.png" alt="a is not defined" /></p> <p>但是我们查看浏览器的 element 和 network 会发现，实际上 a.js 已经被加载进来了。<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/shim-2.png" alt="a.js has been loaded" /><br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/shim-3.png" alt="a.js has been loaded network" /></p> <p>下面我们在 console 中输入:</p> <pre><code>a.sayHello(); </code></pre> <p><img src="/wp-content/uploads/2017/09/shim-4.gif" alt="console 中输入命令" /></p> <p>可以看出实际上 a.js 中暴露的全局变量还是存在的。</p> <h2 id="使用-&#96;shim&#96;"><a href="#使用-&#96;shim&#96;" name="使用-&#96;shim&#96;"></a>使用 <code>shim</code></h2> <p>下面我们用 <code>shim</code> 让 RequireJS 可以获得暴露的全局变量作为返回值。</p> <p>修改 <code>main.js</code></p> <pre><code>requirejs.config({     shim: {         a:{             deps:[],             exports: 'a'         }     } }); require(['a'],function(a) {     console.log(a); }); </code></pre> <p>然后刷新文档，这次肯定是输出内容了。<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/shim-5.png" alt="exports 有效" /></p> <p>如果我们把 <code>exports: 'a'</code> 改成 <code>exports: 'something'</code> 那么再刷新，一定会发现又输出 <code>undefined</code></p> <p><em>所以，<code>exports</code> 是模块的返回值，该值一定要与库暴露的全局变量名称一致。</em></p> <h2 id="使用-&#96;deps&#96;"><a href="#使用-&#96;deps&#96;" name="使用-&#96;deps&#96;"></a>使用 <code>deps</code></h2> <p>下面来实验 <code>deps</code> 的用法，假设 a.js 依赖于 b.js</p> <h3 id="正确的写法"><a href="#正确的写法" name="正确的写法"></a>正确的写法</h3> <p>File: b.js</p> <pre><code>var b = {};  console.log('b');  b.string = 'Hello, this is a string from b.js'; b.getString = function() {     return this.string; } b.setString = function(string) {     this.string = string; } </code></pre> <p>File: a.js</p> <pre><code>// 立即执行函数，不暴露私有成员 (function(window){     console.log('a');      var a = {};     a.sayHello = function(){         alert("Hello this is A");         return 'Hello';     }     a.getBString = function() {         alert(b.getString());     }     window.a = a; })(window) </code></pre> <p>File:main.js</p> <pre><code>requirejs.config({     shim: {         a:{             deps:['b'],             exports: 'a'         },         b: {             deps:[],             exports: 'b'         }     } }); require(['a'],function(aAlias) {      aAlias.getBString();  }); </code></pre> <p>效果如下：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/shim-6.png" alt="depes 用法效果" /></p> <p>这是标准的写法，下面我们来实验一个不好的写法。</p> <h3 id="错误的写法"><a href="#错误的写法" name="错误的写法"></a>错误的写法</h3> <p>将 main.js 改成</p> <pre><code>requirejs.config({     shim: {         a:{             deps:[],             exports: 'a'         },         b: {             deps:[],             exports: 'b'         }     } }); require(['a','b'],function(aAlias, bAlias) {      aAlias.getBString();  }); </code></pre> <p>我们并没有声明 a.js 依赖 b.js 而是在使用的时候将 b.js require 进来了。这样在本例中也是正常的。但仅仅是因为本例太简单，对执行的先后顺序没有要求而已，换个场景可能就失效了。</p> <p><code>require(['a','b'],function(aAlias, bAlias)</code> 仅仅表示 a b 都加载完成后，执行回调函数，但是 加载的顺序是不固定的。执行的顺序是固定的，按照依赖声明的先后顺序执行。</p> <p>在上面我们埋了 <code>console.log('a)</code> 和 <code>console.log('b')</code> 那么在不好的写法中，控制台中打印的顺序是不固定的，有时候是 <code>a b</code> 有时候是 <code>b a</code> ，而正确的例子中，指定顺序是固定的，一定是 <code>b a</code></p> <p>下面是错误的写法，多次刷新的结果，可以看出，顺序是有变化的。<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/shim-7.gif" alt="执行顺序不一定" /></p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="http://blog.csdn.net/aitangyong/article/details/44225859" target="_blank" rel="noopener">使用requireJS加载不符合AMD规范的js文件：shim的使用方式和实现原理</a><br /> <a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan-magento-2-mvvm-mvc/]]></link>
		<title><![CDATA[Magento 2 简介 —— 不再是 MVC （翻译）]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em>前言：Alan Storm 的文章以其深度和专业性给博主留下了深刻的印象，而且他非常注意通过代码实例来讲解。在博主眼中 Alan 绝对是大师级的 Magento 专家，所以博主决定翻译他关于 Magento 2 的文章。本篇<a href="http://alanstorm.com/magento_2_mvvm_mvc" target="_blank">原文地址</a></em></p> <p>今天我们来做个 Magento 2 的“Hello World”示例。我们会设置一个新的 URL ,并向你展示如何为这个 URL 创建 phtml 模版。在这个过程中我们要说一说<strong>设计模式</strong>以及 Magento 是怎样的设计模式。不过，这篇文章的核心部分是简单地、可以跟着做的步骤，它会帮助你入门 Magento 2 的模块开发。</p> <p>等不及的可以去github上下载 <a href="https://github.com/astorm/magento2-hello-world">Alan 的本篇完整模块代码</a>，但是我们强烈建议你自己完成创建的过程。</p> <p>对 Magento 1 的开发者来说，一个大的惊喜是 Magento 2 不是一个 Model，View，Controller 的系统。Magento 2 是近似 Model,View,ViewModel(MVVM)的系统，然而他的架构师们还没有给它起一个特定的称呼。</p> <p>Magento 2 中，当你请求一个URL</p> <p><code>http://magento.example.com/hello_mvc/hello/world</code></p> <p>系统会将请求路由到 Controller 类的 execute method，类似于 MVC 系统将请求路由到 Controller 类的 action method。但是，和传统的 MVC 系统不一样的是，这个 Controller 类只负责如下事情：</p> <ul> <li>决定使用哪个 page layout</li> <li>Handling saving data from <code>POST</code> requests</li> <li>下面两件事情之一： <ul> <li>让系统 render HTTP response</li> <li>将用户重定向到下一页或上一页</li> </ul> </li> </ul> <p>你会发现我们都没提在 View 中设置变量。这是因为每个 View 要自己负责从 model layer, request object,或其他外部系统中取得自己的信息。Magento 将 HTML 页面分解成许多片段，称之为 containers 。每个 container 包含嵌套的对象树，叫做 blocks。每个 block 对象拥有一个 phtml 模板文件，用来指定该 block 对象要展现的 HTML 。按照 MVVC 的说法，Magento 的 block 对象就是 View Model。block 对象将会完成所有对 CRUD models, request object, 外部系统等的数据读入。phtml 模板文件是 View （MVVM 中的 View），他只和 ViewModel 交互（block 对象）</p> <p>作为模块开发者，如果你想在 Magento 中创建一个新的 URL ，你需要做如下事情：</p> <ul> <li>Configure a module to tell Magento which controller it should use for a URL</li> <li>Configure a module to tell Magento which Block objects should be added to the system</li> </ul> <p>看到这里有点招架不住了吧，不要担心。本篇介绍文章的剩余部分会带领你完成建立一个 Magento 2 “Hello World” 模块的所有必要步骤。多练习几次，你就会开始掌握新的术语，以及什么代码应该放在哪里。</p> <h2 id="关于“cache-clearing”的注意点"><a href="#关于“cache-clearing”的注意点" name="关于“cache-clearing”的注意点"></a>关于“Cache Clearing”的注意点</h2> <p>像大多数现代框架一样，Magento 2 使用了很多不同的缓存文件来加快会拖慢速度的操作。这些缓存目的是使系统在生产环境中跑地更快 —— 但是这经常会导致 Magento 没有用最新的配置或源文件，所以看不到变化。</p> <p>当你在 Magento 2 系统中创建新功能的时候，常常是很有必要清空你的缓存的。你可以通过<code>bin/magento</code>的 CLI 命令(<code>cache:clean</code>)，后台的<code>System -&gt; Cache Management</code>，或者通过删除缓存文件(一般在<code>var/cache</code>文件下，如果你用了缓存引擎则另当别论)来清空缓存。</p> <p>为让速度飞起来，除了缓存文件，Magneto 2 还生成很多 boilerplate classes。这些文件放在<code>var/generation</code>路径下。当你修改了某些配置或代码文件后，通常有必要重新生成这些文件。目前，没有任何方法(CLI或者后台)可以帮你重新生成。唯一的方法是手动删除<code>var/generation</code>下的文件。</p> <p>我们会尽量在需要清空缓存和重新生成代码文件的时候给你提个醒的，不过要是你遇到应该起作用却没有起作用的情况时，试试看这样做：先清除缓存和生成的代码文件，然后重新载入页面或是重新运行命令。</p> <p>这些命令可以帮助你快速地回到正确的道路上。</p> <pre><code>rm -rf /path/to/magento/var/generation/* rm -rf /path/to/magento/var/cache/* </code></pre> <h2 id="magento-2-hello-world-module"><a href="#magento-2-hello-world-module" name="magento-2-hello-world-module"></a>Magento 2 Hello World Module</h2> <p>今天我们的目标是：</p> <pre><code>访问这个URL http://magento.example.com/hello_mvc/hello/world 返回 Magento2 默认主题下的 “Hello World” 信息。 </code></pre> <p>从更高的角度来说，我们要完成这个目标的步骤如下：</p> <ul> <li>创建一个 Magento 2 的 Module</li> <li>Configure this module with a route for a URL</li> <li>Create a class for our controller object</li> <li>Create a full action name layout handle XML file</li> <li>Use the full action name layout handle XML file to add a new block to the content container</li> <li>Create a template for our block</li> </ul> <p>上面一些术语我们有的已经提到过了，有的还没有。对熟悉 Magento 1的人来说，有些看起很熟悉，但是改变又很多，你可能想忘记 Magento 1 是怎么工作的了呢。虽然Magento 1 的许多知识在 Magento 2 的许多地方依然是非常宝贵的，但是设想 Magento 2 像 Magneto 1 一样的工作是不能帮助你寻找结果。</p> <h2 id="创建一个-magento-2-的-module"><a href="#创建一个-magento-2-的-module" name="创建一个-magento-2-的-module"></a>创建一个 Magento 2 的 Module</h2> <p>Magento 2 中，Module 让程序员可以以模块化地方式向系统中增加新的代码。当你通过 Module 向系统增加代码时，系统才会知道去哪里找你的代码。Module 还定义了使用PHP 命名空间的规则，这样可以避免和其他开发者的代码冲突。Module 是Magento 2 系统的“头等公民”——核心团队也是使用 Module 来实现前后端功能的哦。</p> <p>Module 需要被放在<code>app/code</code>文件夹下。Magento 2中所有的 module 都有唯一的名字，这个名字由两部分组成。第一部分是描述创建者（公司、个人或者小组）的单词。有时候称之为 vendor namespace。第二部分，是描述该模块功能的单词。</p> <p>举例来说，Magento 2 自带的一个模块叫 <code>Magento_Contact</code>。这个第一部分 Magento 描述的是该模块的创建者（Magneto 核心团队）。第二部分 Contact 说的是这个模块干什么事情（给 Magento 增加 Contact form）</p> <p>我们这个入门教程，就来创建一个叫<code>Pulsestorm_HelloWorldMVVM</code>的 module 吧。要创建这个模块，请你创建相应的文件，把内容复制进去。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/etc/module.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../lib/internal/Magento/Framework/Module/etc/module.xsd"&gt;     &lt;module name="Pulsestorm_HelloWorldMVVM" setup_version="0.0.1" /&gt; &lt;/config&gt; </code></pre> <p>module 一般放在<code>app/code</code>文件夹下，根据 module 的名字我们给他创建文件结构。（Pulsestorm_HelloWorldMVVM 对应 Pulsestorm/HelloWorldMVVM）</p> <p>Magento 2 的 module 将包含许多 XML 配置文件，这些配置文件放在 <code>etc</code> 文件夹下。刚刚创建的<code>module.xml</code>是 module 的主要配置文件。这个文件正是 Magento 核心代码搜索系统的模块时要找的文件。</p> <p><code>&lt;config/&gt;</code> 根节点就是样板，不用管他，照抄就行。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/etc/module.xml --&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../lib/internal/Magento/Framework/Module/etc/module.xsd"&gt; </code></pre> <p>Magento 2 使用 XSD schema 文件来验证所有 module 配置文件的内容。拷贝就行了，不会有变化。</p> <p>这个配置文件我们感兴趣的部分是：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/etc/module.xml --&gt; &lt;module name="Pulsestorm_HelloWorldMVVM" setup_version="0.0.1" /&gt; </code></pre> <p><code>&lt;module/&gt;</code> 节点告诉 Magento 我们想要给系统添加一个 module。<code>name</code>属性告诉 Magneto module 的名字是什么。<code>setup_version</code>告诉 Magento 我们 module 的版本是什么。这个 version 节点对 Magento 的 setup-resource/migration 系统很重要，不过今天我们不展开说。</p> <p>上面的事情做好后，下面我们向<code>app/etc/config.php</code>文件的全局 module 列表中添加我们的 module。</p> <pre><code>#File: app/etc/config.php &lt;?php return array (   'modules' =&gt;   array (     'Magento_Store' =&gt; 1,     'Magento_AdvancedPricingImportExport' =&gt; 1,     'Magento_Directory' =&gt; 1,     //...   ), ); </code></pre> <p>你看这是一个长长的 module 列表。这个文件是为了让核心代码不用每次请求时都去逐个扫描<code>app/code/*</code>文件。把我们的模块也加入到数组的最后。</p> <pre><code>#File: app/etc/config.php &lt;?php return array (   'modules' =&gt;   array (     'Magento_Store' =&gt; 1,     'Magento_AdvancedPricingImportExport' =&gt; 1,     'Magento_Directory' =&gt; 1,     //...     'Pulsestorm_HelloWorldMVVM'=&gt; 1   ), ); </code></pre> <p>Magento Merchant Beta 版本后的更新：beta 版本后核心团队增加了 <code>registration.php</code> 文件，现在每个 module 都需要他。</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/registration.php &lt;?php \Magento\Framework\Component\ComponentRegistrar::register(     \Magento\Framework\Component\ComponentRegistrar::MODULE,     'Pulsestorm_HelloWorldMVVM',     __DIR__ ); </code></pre> <p>上面的文件，除了<code>Pulsestorm_HelloWorldMVVM</code>不同，其他所有的 module 内容都是一样的。第二个参数是你的 module 的全名。</p> <p>Why is this here here? It’s part of how Magento identifies which modules are installed into a system. This replaces the old Magento 1 app/etc/module files, and takes the ultimate source of truth for module presence away from app/etc/config.php.</p> <h2 id="安装疑难解答"><a href="#安装疑难解答" name="安装疑难解答"></a>安装疑难解答</h2> <p>有几种不同的方法来检查 module 是否正确安装好了。其中一种是使用 CLI 命令<code>module:status</code></p> <pre><code>$ php bin/magento module:status List of enabled modules: Magento_Store Magento_AdvancedPricingImportExport //... Pulsestorm_HelloWorldMVVM  List of disabled modules: //... </code></pre> <p>这个命令会列出系统中所有安装了的和没有安装的 module</p> <p>另一种方式是进入后台，在<em>Stores -&gt; Configuration -&gt; Advanced -&gt; Advanced -&gt; Disable Modules Output</em> 查看。</p> <p>关于module 的创建最后要提醒的是，安装一个新的 module 可能会看到如下错误提示：</p> <pre><code>Please upgrade your database: Run "bin/magento setup:upgrade"  from the Magento root directory.  The following modules are outdated: //... </code></pre> <p>这里不去深究错误原因，这是 Magento setup resource migration system 发出的警告。他告诉你模块的版本和上次setup resource migration scripts 执行的 module 版本不相符。</p> <p>别管他，从 CMD 运行如下命令，警告就会消失了：</p> <pre><code>$ php bin/magento setup:upgrade </code></pre> <h2 id="添加-controller-action"><a href="#添加-controller-action" name="添加-controller-action"></a>添加 controller action</h2> <p>我们已经创建了 module，接下来为我们的 URL 配置好路由，并创建一个控制器类。在这之前，我们来做个事情。</p> <p>Magneto 2 社区版本吸收了许多原来企业版才有的特性。其中就包括 full page caching。这对生产环境来说是非常棒的，然而要是你开着全页缓存，开发一个新的 URL 的话，会有点痛苦。你可以登录后台，到<em>System -&gt; Cache Management</em> 中关了它。如果你让他开着，那么每次请求都要删除缓存，缓存文件在<code>var/page_cache</code>目录下。</p> <p>之前提到的两个缓存文件夹是<code>var/cache</code> 和<code>var/generation</code></p> <p>关闭全页缓存后，我们就可以继续前进了。</p> <h2 id="magnento-2-的路由"><a href="#magnento-2-的路由" name="magnento-2-的路由"></a>Magnento 2 的路由</h2> <p>我们要让 Magento 2 响应如下 URL</p> <pre><code>http://magento.example.com/index.php/hello_mvvm/hello/world </code></pre> <p><code>index.php</code>部分是可以不要的。如果你启用了<code>mod_rewrite</code>（或者是web 服务器其他对应的组建），那么上面的 URL 等价于下面的：</p> <pre><code>http://magento.example.com/hello_mvvm/hello/world </code></pre> <p>在Magento 2 系统中，每个独立的 module 都可以声明一个 <strong>front name</strong>，这个<strong>front name</strong>就是URL 中的第一段，对应我们的URL，就是<code>hello_mvvm</code>。如果一个 module 申明了一个 front name，那么相当于他告诉系统：</p> <pre><code>Magneto system code 你好，如果你看见任何以 /hello_mvvm 开头的URL，我有他们的控制器。 </code></pre> <p>要让我们的模块声明<code>hello_mvvm</code>的front name，请增加如下配置文件。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/etc/frontend/routes.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../lib/internal/Magento/Framework/App/etc/routes.xsd"&gt;     &lt;router id="standard"&gt;         &lt;route id="hello_mvvm" frontName="hello_mvvm"&gt;             &lt;module name="Pulsestorm_HelloWorldMVVM" /&gt;         &lt;/route&gt;     &lt;/router&gt; &lt;/config&gt; </code></pre> <p>这个新创建的<code>routes.xml</code>文件告诉 Magento 我们要声明一个 front name。注意这个文件放在子目录<code>frontend</code>下面。Magnento 2 系统允许开发者创建多个<strong>application areas</strong>。 areas 控制的事情有载入哪个session，检查哪个 access control rule，以及载入那个配置文件。<code>frontend</code> area 就是前台购物应用。如果这里没有看明白也不用担心，乖乖放在指定位置就没事了。</p> <p><code>&lt;router/&gt;</code>节点包含了我们所有的routes</p> <pre><code>&lt;router id="standard"&gt;     &lt;!-- ... --&gt; &lt;/router&gt; </code></pre> <p>这里<code>id="standard"</code> 有点让人困惑。如果你为frontend area 设置 URL ，你就得用<code>standard</code>。如果你是为后台应用设置 URL 的话，你就得用<code>id="admin"</code>。这个原因是历史遗留问题，如果有机会的话，后续的文章会讲到原因。</p> <p>在<code>&lt;router/&gt;</code>内，我们会看到<code>&lt;route/&gt;</code>标签。</p> <pre><code>&lt;route id="hello_mvvm" frontName="hello_mvvm"&gt;     &lt;module name="Pulsestorm_HelloWorldMVVM" /&gt; &lt;/route&gt; </code></pre> <p>每个单独的<code>&lt;route/&gt;</code>节点告诉 Magento 我们想要声明一个特定的 front name。<code>frontName</code>的属性值是 URL 第一部分的文本值。比方说<code>frontName="hello_mvvm"</code>告诉 Magento 我们想要声明的 URL 长下面这样：</p> <pre><code>http://magento.example.com/hello_mvvm/* </code></pre> <p><code>node</code>节点的<code>id</code>属性唯一确定该节点。该<code>id</code>有时候也称为 route 的名称。按照惯例，99.9%的时候，该<code>id</code>的值应该都是和<code>frontName</code>一样的。如果你不知道为什么是这样的——你其实不需要知道。只要让他们一样就好了。</p> <p>在<code>route</code>节点内，你会看到：</p> <pre><code>&lt;module name="Pulsestorm_HelloWorldMVVM" /&gt; </code></pre> <p><code>name</code>属性节点应该是你 module 的名称。上面这些都弄好了以后，我们可以继续去创建控制器文件了。</p> <h2 id="新建控制器文件"><a href="#新建控制器文件" name="新建控制器文件"></a>新建控制器文件</h2> <p>Magento 2 使用传统的PHP“将 URL 转化为控制器类名”的方法。让我们再来看看我们的URL</p> <pre><code>http://magento.example.com/hello_mvvm/hello/world </code></pre> <p>要找出控制器的类名，Magento 2 将会查看 URL 第二和第三部分（<code>hello</code>和<code>world</code>）</p> <ol> <li>因为我们声明了<code>Pulsestorm_HelloWorldMVVM</code>的 front name 为<code>hello_mvvm</code>，所以控制器的名称以<code>Pulsestorm\HelloWorldMVVM</code>为开头。</li> <li>因为我要定义一个控制器，所以接下来增加一个<code>Controller</code>（<code>Pulsestorm\HelloWorldMVVM\Controller</code>）</li> <li>接下来 Magento 把 URL 的第二部分(hello)添加进去，首字母大写。（<code>Pulsestorm\HelloWorldMVVM\Controller\Hello</code>）</li> <li>然后 Magento 把 URL 的第三部分（world）添上去，首字母大写。（Pulsestorm\HelloWorldMVVM\Controller\Hello\World）</li> </ol> <p>现在我们有控制器的全名了<code>Pulsestorm\HelloWorldMVVM\Controller\Hello\World</code>。现在创建这个文件吧。</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/Controller/Hello/World.php &lt;?php namespace Pulsestorm\HelloWorldMVVM\Controller\Hello; class World extends \Magento\Framework\App\Action\Action {     public function execute()     {         echo '&lt;p&gt;You Did It!&lt;/p&gt;';         var_dump(__METHOD__);     } } </code></pre> <p>控制器文件的位置和他的全名是对应的（PSR-0标准）</p> <pre><code>Class Name: Pulsestorm\HelloWorldMVVM\Controller\Hello\World;    app/code/Pulsestorm/HelloWorldMVVM/Controller/Hello/World.php </code></pre> <p><code>Magento\Framework\App\Action\Action</code>是前端控制器的基类。(Action 这个名字源于历史名称”action controller”)</p> <p>在 Magnento 2 系统中，每个控制器有且仅有一个入口，就是<code>execute</code>方法。Magento 2 的设计师这样设计是为了帮助避免冲突，在一个大的开发团队中很多人都修改同一个控制器文件实现不同的功能，如果入口还不同是很容易冲突的。</p> <p>上面的工作都完成后，载入这个 URL 试试看吧。（当然记得先清空生成的缓存）</p> <pre><code>http://magento.example.com/hello_mvvm/hello/world </code></pre> <p>假如你正确地跟着上面的步骤做了，那你应该看到如下输出：</p> <pre><code>You Did It string 'Pulsestorm\HelloWorldMVVM\Controller\Hello\World::execute' (length=57) </code></pre> <p>恭喜你！你已经创建了自己的第一个 Magneto 2 controller</p> <h2 id="passing-off-to-the-view"><a href="#passing-off-to-the-view" name="passing-off-to-the-view"></a>passing off to the view</h2> <p>前面我们说到控制器的任务有：</p> <ul> <li>决定使用哪个 page layout</li> <li>Handling saving data from <code>POST</code> requests</li> <li>下面两件事情之一： <ul> <li>让系统 render HTTP response</li> <li>将用户重定向到下一页或上一页</li> </ul> </li> </ul> <p>今天我们只示范控制器让系统 render HTTP response。Magento 2 系统中，如果你想让控制器渲染（render）一个 HTML　Page，你得让控制器返回一个”page” objec。这是一个三步的过程：</p> <ol> <li>You need to inject a “page factory” object via automatic constructor dependency injection</li> <li>使用上面的 page factory 对象来创建一个 page 对象</li> <li>返回上面创建的 page 对象。</li> </ol> <p>实际上没有听起来这么复杂。修改你的控制器文件让他像下面这样：</p> <pre><code>&lt;?php namespace Pulsestorm\HelloWorldMVVM\Controller\Hello; use Magento\Framework\View\Result\PageFactory; use Magento\Framework\App\Action\Context;  class World extends \Magento\Framework\App\Action\Action {     protected $pageFactory;     public function __construct(Context $context, PageFactory $pageFactory)     {         $this-&gt;pageFactory = $pageFactory;         return parent::__construct($context);     }      public function execute()     {         var_dump(__METHOD__);         $page_object = $this-&gt;pageFactory-&gt;create();;         return $page_object;     } } </code></pre> <p>清空缓存以及<code>var/generation</code>里的内容，然后重新载入你的页面。你可能会困惑，因为你只看到<code>var_dump</code>输出的方法名：</p> <pre><code>string 'Pulsestorm\HelloWorldMVVM\Controller\Hello\World::execute' (length=57) </code></pre> <p>但是，如果你查看网页的源代码，你应该看到类似下面的代码：</p> <pre><code>&lt;html &gt; &lt;head &gt; &lt;meta charset="utf-8"/&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;meta name="description" content="Default Description"/&gt; &lt;meta name="keywords" content="Magento, Varien, E-commerce"/&gt; </code></pre> <p>这里的问题并不是代码有误——这是因为我们还没有告诉layout system 它需要给<code>http://magento.example.com/hello_mvvm/hello/world</code>页面做点什么。正因为如此，Magento 渲染了 HTML 的结构，但是没有填入内容。接下来我们会了解怎么告诉 layout system 做事，但是首先我们得解释一下上面我们做了什么。</p> <p>下面两行改变</p> <pre><code>use Magento\Framework\View\Result\PageFactory; use Magento\Framework\App\Action\Context; </code></pre> <p>严格来说并非必须的，但他让我们下面可以使用<code>PageFactory</code>和<code>Context</code>短的类名，如果你对PHP的命名空间不是很熟悉，可以参考<a href="http://alanstorm.com/php_namespace_primer/" target="_blank">short primer is a great place to start</a></p> <p>接着是我们的constructor</p> <pre><code>protected $pageFactory; public function __construct(Context $context, PageFactory $pageFactory) {     $this-&gt;pageFactory = $pageFactory;     return parent::__construct($context); } </code></pre> <p>这是 Magento 2 的依赖注入（automatic constructor dependency injection）起作用——如果你对这个不是很熟悉，你可以参考<a href="http://alanstorm.com/category/magento/#magento_2_object_system" target="_blank">our object manager series</a>。简单说来，Magento 有一些神奇的代码，当你在构造函数参数中写下某个类后，它就会自动帮你构造这个类的对象。所以，就这样我们创建了<code>PageFactory</code>的对象，并且把他赋给<code>pageFactory</code>属性。</p> <p>即使你对依赖注入很熟悉，上面的<code>$context</code>变量可能也会使你很困惑。 This is here because it’s also in the parent object’s (<code>Magento\Framework\App\Action\Action</code>) constructor, and we need to call <code>parent::__construct</code> to make sure any work in the parent constructor still happens.</p> <p>最后，一切都到了<code>execute</code>方法中</p> <pre><code>public function execute() {     var_dump(__METHOD__);     $page_object = $this-&gt;pageFactory-&gt;create();;     return $page_object; } </code></pre> <p>在这里我们使用<code>PageFactory</code>对象创建一个page 对象，并且把他返回出去。</p> <h2 id="creating-the-view"><a href="#creating-the-view" name="creating-the-view"></a>creating the view</h2> <p>对最终程序员用户（我们），Magento 的 Page Layout 系统是通过 XML based domain specific language 来控制的。直白一点，这意味着我们可以通过创建包含指令的 XML 文件来告诉layout system 干什么。完整讲解 layout 系统已经超出本文的范围了（另开一篇也讲不完），如果你有问题，请在 Alan 的博客下评论，或者去 Stack Exchange 提问。</p> <p>先做下面的事情，创建下面的文件：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/layout/hello_mvvm_hello_world.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" layout="1column" xsi:noNamespaceSchemaLocation="../../../../../../../lib/internal/Magento/Framework/View/Layout/etc/page_configuration.xsd"&gt;     &lt;referenceBlock name="content"&gt;         &lt;block             template="content.phtml"             class="Pulsestorm\HelloWorldMVVM\Block\Main"             name="pulsestorm_helloworld_mvvm"/&gt;     &lt;/referenceBlock&gt; &lt;/page&gt; </code></pre> <p>之后创建下面的 php <code>Block</code> 类</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/Block/Main.php &lt;?php namespace Pulsestorm\HelloWorldMVVM\Block; use Magento\Framework\View\Element\Template;  class Main extends Template {     protected function _prepareLayout()     {      } } </code></pre> <p>最后，创建如下<code>phtml</code>模板</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/templates/content.phtml &lt;h1&gt;Hello World&lt;/h1&gt; </code></pre> <p>上面都做好了以后，清空缓存和生成的代码（<code>var/generation</code>）重新载入页面，你现在应该看到<em>Hello World</em>标题被 Magento 的设计包围着。</p> <h3 id="what-just-happened"><a href="#what-just-happened" name="what-just-happened"></a>what just happened</h3> <p>接下来的几个小节我们会解释上面做的事情——上面一个小节可能是本篇文章中最让人困惑的部分了。我们正在引入新的术语，重新定义 Magento 1 的术语。你不需要完全理解这些部分才能继续，不过这是深入了解 Magento 核心代码的伟大起点。</p> <p>Even if the next few sections are a little over your head, you’ll definitely want to skip ahead to the View/View Model section near the end.</p> <h3 id="the-full-action-name-layout-handle-xml-file"><a href="#the-full-action-name-layout-handle-xml-file" name="the-full-action-name-layout-handle-xml-file"></a>The Full Action Name Layout Handle XML File</h3> <p>让我们从创建的 XML 文件说起</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/layout/hello_mvvm_hello_world.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" layout="1column" xsi:noNamespaceSchemaLocation="../../../../../../../lib/internal/Magento/Framework/View/Layout/etc/page_configuration.xsd"&gt;     &lt;referenceBlock name="content"&gt;         &lt;block             template="content.phtml"             class="Pulsestorm\HelloWorldMVVM\Block\Main"             name="pulsestorm_helloworld_mvvm"/&gt;     &lt;/referenceBlock&gt; &lt;/page&gt; </code></pre> <p>这个文件被称为<code>full action name layout handle XML file</code>。之前我们提到，开发者通过 XML 文件中的指令告诉 Magneto Page Layout 系统做什么事情。这就是那个 XML 文件。<strong>Layout handle</strong> 就像是 Page Layout 系统的事件或是消息。每个 page 会触发某些 handles，这些 handles 告诉 Magento 哪些 Layout Handle XML Files 应该被加载。</p> <p>每个控制器页面触发一个<code>full action name</code>handle。一个 full action name 是一个组合了<code>&lt;route/&gt;</code> ID （<code>hello_mvvm</code>通常唯一确定front name）以及URL第二和第三部分（<code>hello</code> 和 <code>world</code>）的字符串。在我们的例子中，full acton name 就是<code>hello_mvvm_hello_world</code></p> <p>所以，当我们创建名为<code>hello_mvvm_hello_world</code>的文件时，相当于告诉 Magento：</p> <pre><code>如果触发了hello_mvvm_hello_world handle，请使用这个文件中的布局指令。 </code></pre> <p>至于该文件在模块文件夹中的层次位置：</p> <pre><code>app/code/Pulsestorm/HelloWorldMVVM/view/frontend/layout/hello_mvvm_hello_world.xml </code></pre> <p>Magento 的每个模块都有一个<code>view</code>文件夹，用来放视图相关的文件。在<code>view</code>目录下是为单独的application area 准备的子文件夹（上面的例子application area 指的是<code>frontend</code>），在<code>area</code>文件夹下是为特定的文件类型准备的文件夹（<code>layout</code>文件，<code>template</code>文件等）</p> <p>最后，layout 文件中的指令是这样的：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/layout/hello_mvvm_hello_world.xml --&gt; &lt;referenceBlock name="content"&gt;     &lt;block         template="content.phtml"         class="Pulsestorm\HelloWorldMVVM\Block\Main"         name="pulsestorm_helloworld_mvvm"/&gt; &lt;/referenceBlock&gt; </code></pre> <p>这些 XML 指令大致相当于下面的伪代码：</p> <pre><code>//pseudo code -- does not work $our_view_block = $layout-&gt;createNewBlockWithClass('Pulsestorm\HelloWorldMVVM\Block\Main') $our_view_block-&gt;setName('pulsestorm_helloworld_mvvm'); $out_view_block-&gt;setTemplate('content.phtml'); $layout-&gt;addBlockToContentContainer($our_view_block); </code></pre> <p>大白话来说就是：</p> <pre><code>Magento，请你用Pulsestorm\HelloWorldMVVM\Block\Main 类实例化一个block 对象，这个对象要使用 content.phtml 模板进行渲染，并且给这个block 对象一个全局唯一的名字叫pulsestorm_helloworld_mvvm </code></pre> <p>block 的名字应该是全局唯一的字符串，这样block 对象就可以被其他代码引用了。</p> <h3 id="creating-a-block-class"><a href="#creating-a-block-class" name="creating-a-block-class"></a>creating a block class</h3> <p>之前提到过，Magento 2 的 page layout 是嵌套的container 和 block 的聚集。上面，我们使用full action name handle XML 文件告诉 Magento 我们要插入一个<code>Pulsestorm\HelloWorldMVVM\Block\Main</code> block 对象。我们创建了这样的 block 类：</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/Block/Main.php &lt;?php namespace Pulsestorm\HelloWorldMVVM\Block; use Magento\Framework\View\Element\Template;  class Main extends Template {     protected function _prepareLayout()     {      } } </code></pre> <p>Magento 的 block 类负责渲染 HTML 片段。上面 block 的基类是<code>Magento\Framework\View\Element\Template</code>，他是 Magento 的基本模板类。继承该类的block 会渲染他模板文件中的 HTML 内容。我们在layout handle XML 文件中设置了这个模板(content.phtml)</p> <p>block 文件的路径和 Magento 系统中的所有 PHP 类一样，遵循 PSR-0 autoloader（<a href="/about-psr/" target="_blank">关于psr</a>）</p> <pre><code>app/code/Pulsestorm/HelloWorldMVVM/Block          Pulsestorm\HelloWorldMVVM\Block </code></pre> <h3 id="creating-a-template-file"><a href="#creating-a-template-file" name="creating-a-template-file"></a>creating a template file</h3> <p>Magento 2 系统中的大多数 block 是 template block，这意味着他们渲染<code>phtml</code>模板。当我们添加了如下属性：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/layout/hello_mvvm_hello_world.xml --&gt; &lt;block &lt;!-- ... --&gt;     template="content.phtml" &lt;!-- ... --&gt; </code></pre> <p>就相当于我们告诉 Magento 我们希望 block 使用<code>content.phtml</code>模板文件。</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/templates/content.phtml &lt;h1&gt;Hello World&lt;/h1&gt; </code></pre> <p>模板文件被认为是view assets，所以他们属模块的<code>view</code>文件夹。像routes 和 layout 文件一样，他们有特定的 area(这里是frontend)，他们又属于<code>template</code>子文件夹。</p> <p>如果你想的话也可以把模板放在<code>template</code>的子目录下</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/layout/hello_mvvm_hello_world.xml --&gt; &lt;block &lt;!-- ... --&gt;     template="some/sub/folder/content.phtml" &lt;!-- ... --&gt; </code></pre> <h2 id="view/view-model"><a href="#view/view-model" name="view/view-model"></a>view/view model</h2> <p>到目前为止，我们已经完成所有的事项了。但是，还有最后一件要说。之前我们把 Magento 描述成 Model, View, View Model 系统，Magento blocks 是 View Model，phtml 模板是 View。下面说他们是怎么工作的。</p> <p>打开 block 类，把下面的代码添加到<code>_prepareLayout</code>方法中</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/Block/Main.php protected function _prepareLayout() {     $this-&gt;setMessage('Hello Again World'); } </code></pre> <p>然后再你的<code>phtml</code>文件中，添加如下代码：</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/templates/content.phtml &lt;h1&gt;&lt;?php echo $this-&gt;escapeHtml($this-&gt;getMessage()); ?&gt;&lt;/h1&gt; </code></pre> <p>重新载入页面，这次你应该看到的是<em>Hello Again World</em>信息。</p> <p>作为视图开发者，你需要自己获取或计算模板需要的数据。你可以通过模式方法<code>set</code>和<code>get</code>来完成工作，或者可以通过在 block 中直接定义方法，然后在phtml 模板中调用该方法来完成工作。</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/Block/Main.php public function getGoodbyeMessage() {     return 'Goodbye World'; }  #File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/templates/content.phtml &lt;h2&gt;&lt;?php echo $this-&gt;escapeHtml($this-&gt;getGoodbyeMessage()); ?&gt;&lt;/h2&gt; </code></pre> <p>block 对象还允许你访问 request object —— 试着载入如下 URL</p> <pre><code>http://magento-2-july-8.dev/hello_mvvm/hello/world/name/bill </code></pre> <p>和其他 PHP 框架类似，URL 第三部分以后的键值对被认为是参数。添加如下代码：</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/Block/Main.php protected function _prepareLayout() {     $this-&gt;setMessage('Hello');     $this-&gt;setName($this-&gt;getRequest()-&gt;getParam('name')); } </code></pre> <p>修改 template</p> <pre><code>#File: app/code/Pulsestorm/HelloWorldMVVM/view/frontend/templates/content.phtml &lt;h1&gt;     &lt;?php echo $this-&gt;escapeHtml($this-&gt;getMessage()); ?&gt;     &lt;?php echo $this-&gt;escapeHtml($this-&gt;getName()); ?&gt; &lt;/h1&gt;  &lt;h2&gt;&lt;?php echo $this-&gt;escapeHtml($this-&gt;getGoodbyeMessage()); ?&gt;&lt;/h2&gt; </code></pre> <p>传统的PHP MVC 系统在控制器中设置视图中的变量值，Magneto 的做法和传统的有点不一样。Magento 2 使用 Model, View, View Model 分离了业务逻辑和模板逻辑。</p> <p>对于大型的开发团队来说，每个人的职责明确，Magento 的这一改动对他们很可能是更有利的，但对全栈工程师来说不是很好，全站工程师需要考虑更多的抽象层次了。</p> <p>Magento 1 是可以用<code>MVVM</code>模式的，但是1的<code>Zend Framework</code>roots(and its too many chefs problem)导致了对传统的 MVC 方式的极大偏爱，使用全局注册或者在调用loadLayout 后直接设置 block 的属性值。在Magento 2 中你再也不能直接设置block 对象的属性值了，不过注册对象还是存在的，不过非官方的推荐做法是避免用这个注册对象。</p> <h2 id="总结"><a href="#总结" name="总结"></a>总结</h2> <p>Regardless of whether Magento 2’s patterns elicit a “finally PHP gets it”, or a “WTF is this”, you’ve just successfully created a new landing page and application entry point in Magento 2. You’ve also been exposed to core Magento 2 concepts like clearing the cache, clearing generated files, and the hierarchy of configuration and view files in a Magento 2 module. You’re well on your way to unlocking the mysteries of Magento 2, and all the opportunities that will open for you in the future.</p> <h2 id="相关源文件下载"><a name="相关源文件下载" href="#相关源文件下载"></a>相关源文件下载</h2> <p><a href="https://github.com/PiscesThankIT/HelloWorldMVVM" target="_blank">https://github.com/PiscesThankIT/HelloWorldMVVM</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan-magento-2-and-requirejs/]]></link>
		<title><![CDATA[Magento 2 and RequireJS (翻译)]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em><a href="http://alanstorm.com/magento_2_and_requirejs/" target="_blank">原文地址</a></em></p> <p>既然我们已经探讨过向 Magento 2 中引入 javaScript 和 CSS 的基本知识了，现在我们要开始探索 Magento 引入的现代前端工具和库了。</p> <p>Magento 引入现代前端科技处于有点 tricky 的位置。Magento 是一个软件平台，其次才是在该平台上的电子商务系统。有些机构的市场营销项目在启用6个月后就会被抛弃，有些原型工作在产品发布一年后就会贬值，Magento 和他们不同，作为电商平台需要专注于稳定、成熟的技术，要接受时间的考验。</p> <p>今天，我们将探讨<a href="http://requirejs.org/">RequireJS</a>—— 他是 Magento 2 系统中几乎所有 javaScript 的基础。</p> <p>在我们说到 Magento 2 的 RequireJS 实现之前，我们先要快速地了解下 RequireJS 是做什么的。</p> <h2 id="requirejs"><a href="#requirejs" name="requirejs"></a>RequireJS</h2> <p>RequireJS 是一个 javaScript 模块系统。他实现的是 AMD 标准（<a href="https://en.wikipedia.org/wiki/Asynchronous_module_definition" target="_blank">Asynchronous module definition</a>）（相关的另一个标准叫 CMD）</p> <p>AMD 标准中，javaScript 模块提供做以下事情的方法：</p> <ol> <li>运行 javaScript 程序默认不会用全局命名空间。</li> <li>模块间共享代码和数据（Share javascript code and data between named modules and programs）</li> </ol> <p>这就是 RequireJS 的全部职责。你可能会使用 RequireJS 的模块实现某个功能，但是这个功能不是 RequireJS 本身提供的。 RequireJS 只是确保你获得那个功能的工具。</p> <p><a href="http://requirejs.org/docs/start.html">RequireJS 的 start page</a>就有不错的例子解释 RequireJS 是怎么工作的。我们直接扣过来，再加点说明。</p> <p>首先，下载 <a href="http://requirejs.org/docs/download.html#requirejs" target="_blank">RequireJS 的源文件</a>把它保存到一个名为<code>scripts</code>的文件夹下。</p> <p>然后，创建如下文件：</p> <pre><code>&lt;!-- File: require-example.html --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt;     &lt;head&gt;         &lt;title&gt;My Sample Project&lt;/title&gt;         &lt;!-- data-main attribute tells require.js to load              scripts/main.js after require.js loads. --&gt;         &lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;My Sample Project&lt;/h1&gt;     &lt;/body&gt; &lt;/html&gt; </code></pre> <p>下面的代码让这个页面加载 RequireJS</p> <pre><code>&lt;!-- File: require-example.html --&gt; &lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt; </code></pre> <p><code>src</code>用法我们是熟悉的，除了它，还有另一个custom <code>data-main</code>属性。这个属性告诉 RequireJS 使用<code>scripts/main</code>模块作为程序的入口。这个<code>scripts/main</code>对应文件<code>scripts/main.js</code></p> <p>创建这么个文件：</p> <pre><code>//File: scripts/main.js requirejs([], function() {     alert("Hello World"); }); </code></pre> <p>这个文件创建好后，重新载入你的页面，这时候你应该看到弹出框弹出“Hello World”。恭喜你，你已经创建了第一个 RequireJS 程序。</p> <p>用jQuery 的<code>document ready</code>也可以做到，RequireJS 没有比它多做什么。</p> <pre><code>jQuery(function(){     alert("Hello World"); }); </code></pre> <p>RequireJS 特别在他的模块化。举个例子，假设我们想要用一个叫<code>helper/world</code>的模块，那么修改我们的<code>main.js</code>文件：</p> <pre><code>requirejs(['helper/world'], function(helper_world) {     var message = helper_world.getMessage();     alert(message); }); </code></pre> <p>这里，我们将要载入的模块组织成一个数组，并将该数组作为第一个参数传递给<code>requirejs</code>方法。然后，RequireJS 将<code>helper/world</code>的输出作为<code>helper_world</code>参数传递给 function。</p> <p>当然，如果你现在运行的话会得到一个 javascript 错误。这是因为我们还没有定义<code>helper/world</code>模块。要定义这个模块，将模块的名字转化为文件的路径，并创建如下内容：</p> <pre><code>//File: scripts/helper/world.js define([], function(){     var o = {};     o.getMessage = function()     {         return 'Hello Module World';     }     return o; }); </code></pre> <p>模块定义和我们之前的主程序定义差不多，差别在于这里使用的是<code>define</code>而不是<code>requirejs</code>。<code>define</code>的第一个参数是你模块需要使用的 RequireJS 模块数组。（我们的例子里，这里是空的）第二个参数是javaScript 的函数/闭包，定义你模块的返回值。</p> <p>RequireJS 不规定模块应该返回或者输出什么。模块可以返回字符串，可以返回仅有一个方法的 javaScrinpt 对象（上面这个例子就是）。他还可以载入一个 javaScript 库（比如PrototypeJS）然后返回一个PrototypeJS 对象。RequireJS 只提供通过模块共享代码的系统，剩下的取决于项目开发者。</p> <p>在我们开始 Magento 的 RequireJS 实现之前，有两个主题需要先谈谈：Require JS file loading 和 RequireJS module naming</p> <h2 id="requirejs-file-loading"><a href="#requirejs-file-loading" name="requirejs-file-loading"></a>RequireJS File Loading</h2> <p>默认情况下，RequireJS 会将模块名转换成 HTTP(S)路径。比如<code>helper/world</code>转化成：</p> <pre><code>http://example.com/scripts/helper/world.js https://example.com/scripts/helper/world.js //example.com/helper/scripts/world.js </code></pre> <p>模块名被转化为以<code>.js</code>结尾的文件路径。默认情况下，RequireJS 会使用<code>require.js</code>脚本所在的文件夹作为基础路径。（上面的例子中就是<code>/script</code>）</p> <p>但是，RequireJS 允许你设置不同的基础路径。在 RequireJS 程序开始前，添加以下代码：</p> <pre><code>require.config({     baseUrl: '/my-javascript-code', }); </code></pre> <p>添加这段代码后，RequireJS 要加载<code>helper/world</code>模块的时候，就会从下面的路径去找：</p> <pre><code>http://example.com/my-javascript-code/helper/world.js https://example.com/my-javascript-code/helper/world.js //example.com/my-javascript-code/helper/world.js </code></pre> <p>这个功能让你爱把 js 脚本放哪里就放哪里。</p> <h2 id="requirejs:module-naming"><a href="module-naming" name="requirejs:module-naming"></a>RequireJS:Module Naming</h2> <p>到目前为止，我们的例子中，RequireJS 模块名和他的物理路径是绑定的。换句话说，<code>helper/world</code>模块始终对应路径<code>helper/world.js</code></p> <p>RequireJS 允许你通过配置来做点变化。例如，假如你希望你的<code>helper/world</code>模块被称为<code>hello</code>，只要在程序开始前添加如下配置代码：</p> <pre><code>require.config({     paths: {         "hello": "helper/world"     }, }); </code></pre> <p><code>path</code>给你的模块重命名或者说是给他一个别名。<code>paths</code>对象的键代表着你想要的别名（hello），键对应的值表示模块的实际名称(helper/world)</p> <p>上面的代码放好后，</p> <pre><code>requirejs(['hello'], function(hello) {     alert("Hello World"); }); </code></pre> <p>这段代码就会从<code>helper/world.js</code>路径来加载<code>hello</code>模块。</p> <p>还有很多其他的配置指令来控制 RequireJS 从哪里加载模块，不过这超出本篇的范围了，了解更多，请参考<a href="http://requirejs.org/docs/api.html#jsfiles" target="_blank">“Load Javascript Files”</a></p> <p>对日常的 javaScript 开发来说，你本不需要关注模块是如何通过 HTPP 加载的。你只需要在用到某模块时，就能得到那个模块，这就够了。当你需要添加新模块，添加某些不兼容的代码，或者查找某个模块的源代码（为了弄清他做什么的）时，就要关注 RequireJS 是怎么加载文件的了。</p> <h2 id="magento-2-and-requirejs"><a href="#magento-2-and-requirejs" name="magento-2-and-requirejs"></a>Magento 2 and RequireJS</h2> <p>Magento 自带了 RequireJS 库，引入了一些配置，并且提供了让你添加自己的配置的机制。</p> <p>Magento 2 使用了上面提到的 <code>baseUrl</code>。如果你查看 Magento 的页面源文件，你会看到如下代码：</p> <pre><code>&lt;script type="text/javascript"&gt;     require.config(         {"baseUrl":"http://magento.example.com/static/adminhtml/Magento/backend/en_US"}     ); &lt;/script&gt; </code></pre> <p>这意味着，遇到<code>helper/world</code>模块的时候，他将会从类似下面的URL找文件：</p> <pre><code>http://magento.example.com/static/adminhtml/Magento/backend/en_US/helper/world.js </code></pre> <p>如果你阅读过 Alan 这个系列的前几篇文章，你可能认出这个URL是从模块加载前端静态的文件的URL了。这意味着你可以在你的模块中放一个RequireJS模块定义文件，例如在下面这个位置：</p> <pre><code>app/code/Package/Module/view/base/web/my_module.js </code></pre> <p>这样你就有了一个名为</p> <pre><code>Package_Module/my_module </code></pre> <p>的RequireJS 模块。<br /> 可以从以下URL加载他：</p> <pre><code>http://magento.example.com/static/adminhtml/Magento/backend/en_US/Package_Module/my_module.js </code></pre> <p>这意味着你可以立刻开始在<code>phtml</code>模板中使用该模块了，就像这样：</p> <pre><code>&lt;script type="text/javascript"&gt;     requirejs('Package_Module/my_module', function(my_module){         //...program here...     }); &lt;/script&gt; </code></pre> <p>或者使用单独的javaScript 文件来使用它。</p> <h2 id="congiguring-requirejs-via-modules"><a href="#congiguring-requirejs-via-modules" name="congiguring-requirejs-via-modules"></a>Congiguring RequireJS via Modules</h2> <p>前面，我们说过RequireJS 的两个配置指令——<code>baseUrl</code>和<code>path</code>。随着你步入高级开发阶段，你将接触并使用到许多 RequireJS 的其他配置指令。</p> <p>每个 Magento 模块都可以通过一个名为<code>requirejs-config.js</code>的文件来添加 RequireJS 配置指令。</p> <pre><code>app/code/Package/Module/view/base/requirejs-config.js app/code/Package/Module/view/frontend/requirejs-config.js app/code/Package/Module/view/adminhtml/requirejs-config.js </code></pre> <p>This is a special javascript file that Magento will automatically load on every page load using the area hierarchy. 让我们来试试看。首先我们要创建一个名为<code>Pulsestorm_RequireJsTutorial</code>的Magento 模块。<br /> 创建好后启用该模块：</p> <pre><code>$ php bin/magento module:enable Pulsestorm_RequireJsTutorial $ php bin/magento setup:upgrade </code></pre> <p>如果你不会创建Magento 模块的话，请参考<a href="/alan-magento-2-mvvm-mvc/" target="_blank">Magento 2 简介 —— 不再是 MVC</a></p> <p>模块创建好后，请增加如下文件：</p> <pre><code>//File: app/code/Pulsestorm/RequireJsTutorial/view/base/requirejs-config.js alert("Hello"); </code></pre> <p>清空缓存，载入 Magento 系统的任意页面（包括后台），你应该会看到<code>alert</code>被调用的弹出框了。恭喜你，你已经成功得给模块增加了一个<code>requirejs-config.js</code>文件。</p> <h2 id="the-purpose-of-requirejs-config.js"><a href="#the-purpose-of-requirejs-config.js" name="the-purpose-of-requirejs-config.js"></a>The Purpose of requirejs-config.js</h2> <p>虽然你可以使用<code>requirejs-config.js</code>运行任意的js，但是他的主要任务是：</p> <ol> <li>让 end-user-programmers 向 Magento 的 RequireJS 系统中增加<code>require.config</code>选项。</li> <li>让 end-user-programmers 对自己的 js 代码进行配置或初始化。</li> </ol> <p>要了解 RequireJS 是怎么做的，我们需要看看 Magento 实际上是怎么处理这些<code>requirejs-config.js</code>文件的。如果你查看 Magento 的任意页面的源代码，你会看到类似下面的代码：</p> <pre><code>&lt;script  type="text/javascript"  src="http://magento.example.com/static/_requirejs/adminhtml/Magento/backend/en_US/requirejs-config.js"&gt;&lt;/script&gt; </code></pre> <p>这是在<code>setup:di:compile</code>（production 模式）过程中，或者运行时（developer 和 default模式）生成的一个特殊的 javaScript 文件。如果你不太了解 Magento 的模式对前端文件加载的影响，你可以查看 Alan 的文章<a href="http://alanstorm.com/magento-2-frontend-files-serving/" target="_blank">Magento 2: Serving Frontend Files</a>。在接下来的文章中，我们都假设你是<code>developer</code>模式的。</p> <p>如果你在浏览器中查看下<code>requirejs-config.js</code>文件，你会看到你的<code>alert</code>表达式出现在像下面的代码中</p> <pre><code>(function() {     alert("Hello World");     require.config(config); })(); </code></pre> <p>虽然它不是100%明显，Magento 2 通过从<code>requirejs-config.js</code>生成上述代码块来让我们给系统添加额外的 RequireJS 初始化。</p> <p>我们通过一个具体的例子来进一步了解上面的意思。让我们修改<code>requirejs-config.js</code>变成下面这样：</p> <pre><code>var config = {     paths:{         "my_module":"Package_Module/my_module"     } };  alert("Done"); </code></pre> <p>这里我们定义了一个<code>config</code>变量，并且修改了<code>alert</code>的值。现在你再一次载入页面，看看<code>requirejs-config.js</code>文件，你应该就知道 Magento 到底干了什么。</p> <pre><code>(function() { var config = {     paths:{         "my_module":"Package_Module/my_module"     } };  alert("Done"); require.config(config); })(); </code></pre> <p>对每个<code>requirejs-config.js</code>文件，Magento 都创建了一个类似下面的代码块：</p> <pre><code>(function() {     //CONTENTS HERE     require.config(config); })(); </code></pre> <p><code>requirejs-config.js</code>的内容替换了<code>//CONTENTS HERE</code></p> <pre><code>var config = {     paths:{         "my_module":"Package_Module/my_module"     } };  alert("Done"); </code></pre> <p>这意味着，如果我们在<code>requirejs-config.js</code>文件中定义一个<code>config</code>变量，Magento 最终会将该变量传递给<code>require.config</code>。这将使得 Magento 的模块开发者可以使用 <code>RequireJS</code>的一些特性，比如：<code>shim</code>,<code>paths</code>,<code>baseUrl</code>,<code>map</code>以及其他<a href="http://requirejs.org/docs/api.html#config" target="_blank">RequireJS’s configuration directives</a></p> <h2 id="understanding-lazy-loading"><a href="#understanding-lazy-loading" name="understanding-lazy-loading"></a>Understanding Lazy Loading</h2> <p>另一个要理解的重点是RequireJS 的模块是延迟加载的（lazy load）。</p> <p>换句话说，加入我们使用了下面的配置：</p> <pre><code>var config = {     paths:{         "my_module":"Package_Module/my_module"     } }; </code></pre> <p>默认情况下，Magento 是不会加载<code>Package_Module/my_module.js</code>文件的。Magento 只会在你要用它的时候加载他。</p> <pre><code>requirejs(['my_module'], function(my_module){  });  requirejs(['Package_Module/my_module'], function(my_module){  });  define(['Package_Module/my_module'], function(my_module){  }); </code></pre> <p>记住，RequireJS 的日常开发时是不需要考虑如何请求源文件的细节的。延迟加载帮助用户节约了带宽，有时候某些页面用不着某些js 文件，这样就不用下载他们了。</p> <p>但是，在不那么理想的情况下，延迟加载的行为可能和一些比较早的 js 框架或是库配合不好。下面我们在讲到一些<code>jQuery gotchas</code>时，我们会探讨一个例子。</p> <h2 id="global-jquery-object"><a href="#global-jquery-object" name="global-jquery-object"></a>Global jQuery Object</h2> <p>即使你决定不用 RequireJS，你坚持用 plain old jQuery。你还是需要知道 RequireJS 是怎样与 AMD 标准前的 js 库交互的。</p> <p>在 Magento 2 中，jQuery 以 RequireJS 模块的方式被加载进来。这意味着，如果你尝试使用如下代码：</p> <pre><code>&lt;script type="text/javascript"&gt;     jQuery(function(){         //your code here     }); &lt;/script&gt; </code></pre> <p>你的浏览器会报错说<code>jQuery</code> is undefined。这是因为jQuery 全局对象并不存在，你得以 RequireJS 模块的方式使用jQuery。如果你习惯写上面这种类型的代码，你得这样做：</p> <ol> <li>Replace it with code that kicks off execution of a RequireJS program</li> <li>Configure that program to use the jquery module as a dependency</li> </ol> <p>换句话说，像下面这样：</p> <pre><code>requirejs(['jquery'], function(jQuery){     jQuery(function(){         //your code here     }); }); </code></pre> <p>通过<code>requirejs</code>函数调用开始，传递给他所依赖的模块的数组，并且以匿名函数作为程序的main entry point。</p> <p><code>requirejs</code>的第一个参数是他所依赖的模块的数组列表。举例来说，下面的代码相当于告诉 RequireJS “我的程序是依赖jQuery模块的”。</p> <pre><code>requirejs(['jquery'], </code></pre> <p><code>requirejs</code>的第二个参数是一个匿名函数，RequireJS 会加载你声明的依赖模块，并将他的返回值传递给匿名函数并调用它。</p> <p>jQuery 的新版本会检测自己是否被包含在 RequireJS/AMD 的环境中，如果是就会定义一个模块，并且返回全局的 jQuery 对象。</p> <pre><code>/ File: http://code.jquery.com/jquery-1.12.0.js // Register as a named AMD module, since jQuery can be concatenated with other // files that may use define, but not via a proper concatenation script that // understands anonymous AMD modules. A named AMD is safest and most robust // way to register. Lowercase jquery is used because AMD module names are // derived from file names, and jQuery is normally delivered in a lowercase // file name. Do this after creating the global so that if an AMD module wants // to call noConflict to hide this version of jQuery, it will work.  // Note that for maximum portability, libraries that are not jQuery should // declare themselves as anonymous modules, and avoid setting a global if an // AMD loader is present. jQuery is a special case. For more information, see // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon  if ( typeof define === "function" &amp;&amp; define.amd ) {     define( "jquery", [], function() {         return jQuery;     } ); } </code></pre> <h2 id="requirejs-and-jquery-plugins"><a href="#requirejs-and-jquery-plugins" name="requirejs-and-jquery-plugins"></a>RequireJS and jQuery Plugins</h2> <p>There’s another gotcha to using jQuery and RequireJS together. jQuery 库早于 RequireJS 和 AMD 标准好多年，他形成了自己的庞大的插件系统。那时候还没有模块化，js 默认用的全局变量，这个插件系统也配合得蛮好的，插件开发者通过修改全局的 jQuery 对象来创建他们的插件。</p> <p>对 RequireJS 来说这样就带来一个问题 —— 就像之前我们提到的，全局的 <code>jQuery</code> 对象是不存在的，你得在<code>requirejs</code>匿名函数中使用<code>jQuery</code>模块。这意味着以前下面这种引入 jQuery 插件的方式会在用到<code>jQuery</code>或者<code>$</code>别名时会出错。</p> <pre><code>&lt;script src="http://magento.example.com/js/path/to/jquery/plugin/jquery.cookie.js"&gt; </code></pre> <pre><code>//File: http://magento.example.com/js/path/to/jquery/plugin/jquery.cookie.js var config = $.cookie = function (key, value, options) { </code></pre> <p>如果你想在 Magento 2 的系统中使用 jQuery 插件，你得通过 RequrieJS。幸运的是，过程还是相对直接的。</p> <p>首先，你得通过<code>path</code>给该插件一个别名</p> <pre><code>var config = {     paths:{         "jquery.cookie":"Package_Module/path/to/jquery.cookie.min"     } }; </code></pre> <p>上面的代码创建了一个名为<code>jquery.cookie</code>的模块，该模块的位于<code>Package_Module</code>模块，是一个jQuery cookie 插件。</p> <p>现在，你可能认为我们可以用下面的代码来使用它了。</p> <pre><code>requirejs(['jquery','jquery.cookie'], function(jQuery, jQueryCookie){     //my code here }); </code></pre> <p>毕竟，我们列出的依赖模块有<code>jQuery</code>和<code>jquery.cookie</code>，这应该会触发对他们的加载。</p> <p>你是对的——<strong>但只是有时候</strong>。RequireJS 是异步加载模块源文件的，但它可不保证加载的顺序。这意味着它可能会先加载jQuery 库，但是，有时候页面上的其他脚本或者网络情况可能会导致jQuery cookie 插件反而先被加载了。如果jQuery cookie 先被加载了，他就会因为找不到 jQuery 对象而出错。</p> <p>这样看来，RequireJS 的设计可不太好。但是你得知道 RequireJS 和 AMD 标准是用来避免全局变量的污染的。RequireJS 和 jQuery 这样的库不能无缝对接，这一点都不奇怪。 Even though jQuery is responsible about its use of global state (one global jQuery object), it still uses global state, and RequireJS isn’t going to get in the business of deciding who does and doesn’t use global state responsibly.</p> <p>关于加载顺序，RequireJS 提供了<code>shim</code>配置指令来让我们指定依赖模块的加载顺序。<br /> 你可以告诉 RequireJS :</p> <pre><code>Hey RequireJS，当你加载jquery.cookie的时候，请你确保jquery 模块已经完全加载了。 </code></pre> <p>配置就像这样：</p> <pre><code>var config = {     paths:{         "jquery.cookie":"Package_Module/path/to/jquery.cookie.min"     },     shim:{         'jquery.cookie':{             'deps':['jquery']         }     } }; </code></pre> <p>我们定义了一个名为<code>shim</code>的配置属性，这个属性是一个键值对js对象。键表示模块的名字，值是js另一个对象，他定义该模块的<code>shim</code>配置。</p> <p><code>shim</code>还有很多其他配置选项。上面我们用的<code>deps</code>确保 RequireJS 在加载jquery.cookie 前先加载数组中的模块([jquery])。</p> <p><code>dep</code>配置选项只显示了<code>shim</code>能够做的一小部分，想了解更多细节，请参阅<a href="http://requirejs.org/docs/api.html#config-shim" target="_blank">the shim documentation</a></p> <p>有了上面的配置，你现在可以安全地创建依赖 jquery cookie 插件的 RequireJS 程序了。</p> <h2 id="require-vs-requirejs"><a href="#require-vs-requirejs" name="require-vs-requirejs"></a>Require vs RequireJS</h2> <p>在总结前还有一件事要注意。整个 RequireJS 的文档，你可以看到两个函数：</p> <pre><code>require() requirejs(); </code></pre> <p>这两个函数有什么不同吗？哦，他们没有什么不同，他们是同一个函数。</p> <p>AMD 标准命名为 require，但是，RequireJS 意识到一些在用的代码已经定义了 require 函数，为了保证 RequirejS 可以同那些定义了 require 函数的代码一起使用，所以提供了一个 别名叫 requirejs</p> <h2 id="wrap-up"><a href="#wrap-up" name="wrap-up"></a>Wrap Up</h2> <p>本篇已经带你初步了解了 Magento 对 javaScript 以及现代前端库的使用。但是，所有这些都有赖于 RequireJS 。If you start there, you should be able to track back any javascript based feature to its inclusion via RequireJS, and through that figure out what’s going on. As always, knowing what a specific library does is always useful — but knowing how the framework your code lives in works is the key to becoming a more productive and rational programmer.</p> <h2 id="相关源文件下载"><a name="相关源文件下载" href="#相关源文件下载"></a>相关源文件下载</h2> <p><a href="https://github.com/PiscesThankIT/RequireJS-tutorial" target="_blank">https://github.com/PiscesThankIT/RequireJS-tutorial</a></p> <p><a href="https://github.com/PiscesThankIT/RequireJsTutorial" target="_blank">https://github.com/PiscesThankIT/RequireJsTutorial</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-request-flow/]]></link>
		<title><![CDATA[Magento 2 的请求处理流程]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>Magento 2 的入口是 index.php，有两个：</p> <ul> <li><code>&lt;your Magento install dir&gt;/index.php</code></li> <li><code>&lt;your Magento install dir&gt;/pub/index.php</code></li> </ul> <p>简化后的入口像这样：</p> <pre><code>require __DIR__ . &#039;/app/bootstrap.php&#039;; $bootstrap = \Magento\Framework\App\Bootstrap::create(BP, $_SERVER); $app = $bootstrap-&gt;createApplication(&#039;Magento\Framework\App\Http&#039;); $bootstrap-&gt;run($app); </code></pre> <p>第一句，就是将<code>&lt;your Magento install dir&gt;/app/bootstrap.php</code> 包含进来。这个<code>bootstrap.php</code>文件主要做了一件事情，就是将<code>&lt;your Magento install dir&gt;/app/autoload.php</code> 和<code>&lt;your Magento install dir&gt;/app/functions.php</code>包含进来。<code>autoload.php</code>负责了Magneto 系统中所有类的自动加载。<code>functions.php</code>负责翻译用的。</p> <p>第二句，调用静态方法，返回实例给<code>$bootstrap</code></p> <p>第三句，调用<code>$bootstrap</code>的<code>createApplication</code>方法，该方法调用 Object Manager 创建了<code>Magento\Framework\App\Http</code> 实例。</p> <p>第四句，将上一步骤的实例传递给<code>$bootstrap-&gt;run()</code></p> <p>下面进入<code>\Magento\Framework\App\Bootstrap -&gt; run</code> 看一看，简化后的方法如下：</p> <pre><code>public function run(\Magento\Framework\AppInterface $application) {     //PART-2-1     $this-&gt;initErrorHandler();     $this-&gt;initObjectManager();     $this-&gt;assertMaintenance();     $this-&gt;assertInstalled();     //PART-2-2     $response = $application-&gt;launch();     //PART-2-3     $response-&gt;sendResponse(); } </code></pre> <p>PART-2-1 handles the sort of housekeeping bits. It initializes the<br />custom error handler, initializes the object manager, checks if our application is in maintenance mode, and checks that it is installed.</p> <p>PART-2-2 部分调用<code>Magento\Framework\App\Http -&gt; launch()</code> 暂时把<code>$response</code>看作是<code>\Magento\Framework\App\Response\Http</code>类</p> <p>PART-2-3 调用<code>\Magento\Framework\App\Response\Http</code> 实例的<code>sendResponse</code>方法，该方法在该类的父类<code>\Magento\Framework\HTTP\PhpEnvironment\Response</code>中。这个父类继承自<code>\Zend\Http\PhpEnvironment\Response</code> 不继续深入了。总之，到这个类为止，真正开始输出数据了。</p> <p>总结一下，到目前为止的流程是：</p> <ul> <li>index.php</li> <li>\Magento\Framework\App\Bootstrap -&gt; run</li> <li>\Magento\Framework\App\Http -&gt; launch</li> <li>\Magento\Framework\App\Response\Http -&gt; sendResponse</li> </ul> <p>来看<code>\Magento\Framework\App\Http -&gt; launch</code><br />简化后是这样的：</p> <pre><code>public function launch() {     // PART-3-1     $frontController = $this-&gt;_objectManager-&gt;get(&#039;Magento\Framework\App\FrontControllerInterface&#039;);      // PART-3-2     $result = $frontController-&gt;dispatch($this-&gt;_request);     if ($result instanceof \Magento\Framework\Controller\ResultInterface) {         // PART-3-3         $result-&gt;renderResult($this-&gt;_response);     } elseif ($result instanceof \Magento\Framework\App\Response\HttpInterface {         $this-&gt;_response = $result;     } else {         throw new \InvalidArgumentException(&#039;Invalid return type&#039;);     }      // PART-3-4     return $this-&gt;_response; } </code></pre> <p>PART-3-1 创建一个实现<code>\Magento\Framework\App\FrontControllerInterface</code>接口的类的实例，具体是哪个接口，需要查看di.xml 文件。这个类一般是<code>Magento\Framework\App\FrontController</code>。</p> <p>PART-3-2 <code>Magento\Framework\App\FrontController -&gt; dispatch</code> 具体的稍后再看。他的返回值一般<code>$result</code> 是<code>\Magento\Framework\Controller\ResultInterface</code>，一般是<code>\Magento\Framework\View\Result\Page</code>类</p> <p>PART-3-3 执行<code>$result-&gt;renderResult($this-&gt;_response)</code>这一步没有输出，只是对<code>$this-&gt;_response</code>的修改，之后 PART-3-4 把<code>$this-&gt;response</code>返回出去。</p> <p>再总结一下，流程现在是：</p> <ul> <li>index.php</li> <li>\Magento\Framework\App\Bootstrap -&gt; run</li> <li>\Magento\Framework\App\Http -&gt; launch</li> <li>\Magento\Framework\App\FrontController -&gt; dispatch</li> <li>\Magento\Framework\View\Result\Page -&gt; renderResult</li> <li>\Magento\Framework\App\Response\Http -&gt; sendResponse</li> </ul> <p><code>\Magento\Framework\App\FrontController -&gt; dispatch</code> 需要更深入一下。简化后的方法是这样的：</p> <pre><code>public function dispatch(\Magento\Framework\App\RequestInterface $request) {     // PART-4-1     while (!$request-&gt;isDispatched() &amp;&amp; $routingCycleCounter++ &lt; 100) {         //PART-4-2         foreach ($this-&gt;_routerList as $router) {             try {                 //PART-4-3                 $actionInstance = $router-&gt;match($request);                 if ($actionInstance) {                     $request-&gt;setDispatched(true);                     //PART-4-4                     $result = $actionInstance-&gt;dispatch($request);                     break;                 }             } catch (\Magento\Framework\Exception \NotFoundException $e) {}         }     }     // PART-4-5     return $result; } </code></pre> <p>PART-4-1 和 PART-4-2 给每个<code>$router</code> 100次机会找出匹配项，避免死循环。<br />routers 有以下类型：</p> <ul> <li>Magento\Framework\App\Router\Base</li> <li>Magento\UrlRewrite\Controller\Router</li> <li>Magento\Cms\Controller\Router</li> <li>Magento\Framework\App\Router\DefaultRouter</li> </ul> <p>他们都实现了<code>\Magento\Framework\App\RouterInterface</code> 以确保他们都实现了<code>match</code>方法。<code>match</code>返回的<code>$actionInstance</code>是一个实现了<code>\Magento\Framework\App\ActionInterface</code>接口的类的实例。</p> <p>PART-4-4 <code>$actionInstance</code>（比如 controller）继承自<code>\Magento\Framework\App\Action\Action</code> 类，返回<code>\Magento\Framework\App\ResponseInterface</code>。在<code>dispatch</code>方法中会执行<code>controller</code>的<code>execute</code> 方法。</p> <p>流程现在变成：</p> <ul> <li>index.php</li> <li>\Magento\Framework\App\Bootstrap -&gt; run</li> <li>\Magento\Framework\App\Http -&gt; launch</li> <li>\Magento\Framework\App\FrontController -&gt; dispatch</li> <li>\Magento\Framework\App\Router\Base -&gt; match</li> <li>\Magento\Framework\App\Action\Action -&gt; dispatch</li> <li>\Magento\Framework\View\Result\Page -&gt; renderResult</li> <li>\Magento\Framework\App\Response\Http -&gt; sendResponse</li> </ul> <p>总结，对前端开发者来说，controller 返回 Page 类型的对象后，会自动调用该page的 renderResult 方法。<br /><strong>Page</strong> and <strong>Layout</strong> is where all the theme translations, layout, and template loading are triggering</p> <h2 id="参考文档"><a name="参考文档" href="#参考文档"></a>参考文档</h2> <p>Magento 2 Developer’s Guide by Branko Ajzele<br /><a href="http://inchoo.net/magento-2/routing-in-magento-2/" target="_blank">Routing in Magento 2</a><br /><a href="http://brideo.co.uk/magento2/Request-Flow-In-Magento-2/" target="_blank">Request Flow in Magento 2</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-layout/]]></link>
		<title><![CDATA[Magento Layout]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>假设读者朋友们已经会自己创建简单的模块，并且使用过 layout xml 来展示某个页面了。那么本篇将对 magento layout 做一个总结，从概念上理顺 magento layout 是什么，它是为了解决什么问题，并串联与之相关的一些知识。</p> <p>如果你还不会创建模块，请参阅 <a href="https://www.hellomagento2.com/%E5%88%9B%E5%BB%BA-magento-2-hello-world-simple-module/" target="_blank">创建 Magento 2 Hello World Simple Module</a><br /> 如果还没有使用过 layout ，请参阅 <a href="https://www.hellomagento2.com/magento-2-%E4%B8%AD%E7%9A%84-controller/" target="_blank">Magento 2 中的 Controller</a></p> <h2 id="magento-layout-是什么"><a href="#magento-layout-是什么" name="magento-layout-是什么"></a>magento layout 是什么</h2> <p><em>A Layout is a collection of blocks in a tree structure</em></p> <p>Layout 是 block 的集合，这些 block 是树形结构组织的。</p> <p>那么 magento block 是什么？</p> <p><em>A Magento block is an object with a toHtml method defined. When this toHtml method is called, it returns the string which should be output to the screen.</em></p> <p>可以认为，Magento block 是对象，这个对象拥有方法 <code>toHtml()</code> ，调用这个方法会返回 html 片段的字符串。</p> <p>早期的 php 开发是 html 和 php 代码混淆在一起的，但是这样很难维护和分工，所以将 html 分离出来，成为模版层。</p> <p>我们知道 block 都会对应一个 phtml 模版。当 block 的 <code>toHtml()</code> 被调用时，phtml 文件会被 <code>include</code> （就是 php 内置的 <code>include</code>）进去。（详情请参考 <a href="https://www.hellomagento2.com/magento-2-templates-use-block-or-this/">Magento 2 Templates: Use $block or $this</a> 中 <code>Magento\Framework\View\TemplateEngine\Php</code> 的 <code>render</code> 方法。）</p> <p>phtml 是可以 override 的，参考 <a href="http://devdocs.magento.com/guides/v2.1/frontend-dev-guide/themes/theme-inherit.html" target="_blank">Theme inheritance</a></p> <p>layout 可以 extend 也可以 override 。参考 <a href="http://devdocs.magento.com/guides/v2.1/frontend-dev-guide/layouts/layout-extend.html" target="_blank">Extend a layout</a> 和 <a href="http://devdocs.magento.com/guides/v2.1/frontend-dev-guide/layouts/layout-override.html" target="_blank">Override a layout</a></p> <h2 id="嵌套结构"><a href="#嵌套结构" name="嵌套结构"></a>嵌套结构</h2> <p>layout xml 的内容如下：</p> <pre><code>&lt;page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;referenceContainer name="customer.login.container"&gt;         &lt;block class="ThankIT\SocialLogin\Block\SocialBlock" name="thankit_social_block" ifconfig="thankit_sociallogin/general/enable" template="ThankIT_SocialLogin::login/socialblock.phtml" cacheable="false" after="customer.new"&gt;             &lt;block class="ThankIT\SocialLogin\Block\Buttons" name="thankit_login_buttons" template="ThankIT_SocialLogin::login/buttons.phtml" /&gt;         &lt;/block&gt;     &lt;/referenceContainer&gt; &lt;/page&gt; </code></pre> <p>可以看出我们的 block 中嵌套了一个 block ，那么最外面的 block 对应的 <code>ThankIT_SocialLogin::login/socialblock.phtml</code> 模版内容如下：</p> <pre><code>$helper = $this-&gt;helper('ThankIT\SocialLogin\Helper\Data'); if($helper-&gt;hasButtons()) : ?&gt;     // ... 省略内容     &lt;?php echo $block-&gt;getChildHtml('thankit_login_buttons'); ?&gt; &lt;?php endif; ?&gt; </code></pre> <p>注意此处<code>$block-&gt;getChildHtml('thankit_login_buttons');</code> 我们调用了 block 的 <code>getChildHtml</code> 方法，该方法来自 class <code>Magento\Framework\View\Element\AbstractBlock</code> ，他将取他的 child block ，并调用其 <code>toHtml</code> 方法。</p> <p>所以我们的 block 可以有序组织起来，形成嵌套的结构。</p> <p><code>getChildHtml()</code> 如果不给参数，则 render all child blocks 。</p> <h2 id="controller-中直接创建-block"><a href="#controller-中直接创建-block" name="controller-中直接创建-block"></a>controller 中直接创建 block</h2> <p>我们在 <code>ThankIT_HelloWorld</code> 模块的基础上，创建以下 controller</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Create;  class Block extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         $resultPage = $this-&gt;resultPageFactory-&gt;create();         // var_dump(get_class($resultPage-&gt;getConfig()-&gt;getTitle()));         $resultPage-&gt;getConfig()-&gt;getTitle()-&gt;set(__('create block directly and fpc'));          $block = $resultPage-&gt;getLayout()             -&gt;createBlock('ThankIT\HelloWorld\Block\Index\Index')             -&gt;setTemplate('ThankIT_HelloWorld::index/index.phtml')             -&gt;toHtml();         $this-&gt;getResponse()-&gt;setBody($block);     } } </code></pre> <p>那么我们会得到一些字符串，连 html 结构都没有。此处仅仅为了说明是如何调用 <code>toHtml</code> 来得到 html 片段的。</p> <p>关于 <a href="https://www.hellomagento2.com/magento-2-controller-and-fpc/" target="_blank">Magento 2 Controller and FPC</a></p> <h2 id="layout-xml-要解决的问题"><a href="#layout-xml-要解决的问题" name="layout-xml-要解决的问题"></a>layout xml 要解决的问题</h2> <p>layout xml 要解决的是让主题开发人员也可以控制 HTML 的输出。其实就是又一层抽象，让主题开发人员不需要去改 php 。</p> <p>博主个人认为，layout xml 带来的好处是他的分散性，可以很方便的进行扩展、更改、维护。如果我们要在 controller 中控制 block 的输出，那么我们都要去改 controller ，这就很难维护了。</p> <h2 id="magento-2-layout-文件类型"><a href="#magento-2-layout-文件类型" name="magento-2-layout-文件类型"></a>Magento 2 layout 文件类型</h2> <p>参考 <a href="https://www.hellomagento2.com/magento-2-layout-types/" target="_blank">Magento 2 layout 文件类型</a></p> <h2 id="magento-2-layout-使用"><a href="#magento-2-layout-使用" name="magento-2-layout-使用"></a>Magento 2 layout 使用</h2> <p>关于指令：<br /> <a href="https://www.hellomagento2.com/layout-instruction-之-argument-和-action" target="_blank">Layout instruction 之 argument 和 action</a></p> <p>后台的使用<br /> <a href="https://www.hellomagento2.com/layout-update-place-block/" target="_blank">Using a Layout Update</a></p> <h2 id="获得-layout-的工具"><a href="#获得-layout-的工具" name="获得-layout-的工具"></a>获得 layout 的工具</h2> <p><a href="https://www.hellomagento2.com/debug-tool-how-to-get-all-xml-layout/" target="_blank">调试工具：如何得到页面的布局文件</a></p> <p>可进一步挖掘，获得想要的 layout 文件。</p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p>《No Frills Magento Layout》 by Alan Storm 2011</p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_2_object_manager/]]></link>
		<title><![CDATA[Magento 2 Object Manager]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><a href="https://alanstorm.com/magento_2_object_manager/">原文网址</a></p> <p>原文发布时间：2015年7月10日</p> <p>Magento 2 相比较 1 有很多变化，尽管你还能看到 1 的影子（EAV, areas, blocks 等），但是 Magento 2 核心团队经过几年努力，已经将 1 的核心换成了更成熟的，“enterprise-java” 类型的系统，更多的类、更多的对象、更多的设计模式。</p> <p>尽管有些人可能会认为 Magento 2 代码复杂性增加了，Magento 2 核心团队还是花了很多时间来简化和澄清 Magento 1 中的设计。Magento 1 中 rewrite 系统（home grown class rewrite system ——  based around blocks, models, and helpers）已经由以来注入容器/对象管理器（Kiev grown dependency injection container/object-manager system）代替了。</p> <p>如果你对 Magento 1 的开发方法，一直是复制粘贴，菜谱式（cookbook style）的，那么 Magento 2 对你来说就是一个新的框架，你以前的方法恐怕不管用了。</p> <p>但是，如果你对 1 的开发，是带着理解设计模式的实现、培养阅读源码的能力进行的，那么跟上 Magento 2 就只是小小的“颠簸”——而且，许多方面，这个“颠簸”是为了让开发更加稳定、可预测。</p> <p>本文是 Alan 解释 Magento 2 object manager/dependency-injection system 系列中的第一篇。我们将探索程序员在 Magento 2 中是怎样创建对象的，探索 Magento 2 的 object system 带来的额外特性，顺便讨论下相比较 Magento 1 的变化，探索 Magento 2 中的惯例。</p> <h2 id="magento-2-命令行框架"><a name="magento-2-命令行框架" href="#magento-2-命令行框架"></a>Magento 2 命令行框架</h2> <p>Magento 2 的体系结构转变带来的巨大变化之一就是命令行框架。这不是从 Magento 1 中来的简单框架。相反，Magento 2 自带 <a href="http://symfony.com/doc/current/components/console.html">Symfony’s Console component</a>的完整实现。</p> <p>安装完 Magento 2 后，打开终端，输入 <code>php bin/magento</code>，我们会看到很多系统自带的命令。</p> <p>你应该会看到类似下面的输出：</p> <pre><code>Magento CLI version 0.74.0-beta16  Usage:  command [options] [arguments]  Options:  --help (-h)           Display this help message  --quiet (-q)          Do not output any message  --verbose (-v]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_2_introducing_ui_components/]]></link>
		<title><![CDATA[Magento 2 的 UI Components 介绍（翻译）]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><em><a href="http://alanstorm.com/magento_2_introducing_ui_components/" target="_blank">原文地址</a></em></p> <p>原作发布于 2016年7月10日</p> <p>UI 组件是 Magento 2 中构建用户界面元素的新方法，管理后台很多地方都是基于它的。</p> <p>今天我们的教程将带领大家，站在比较高的角度理解 UI 组件的目标是什么，并在尽可能高的层面介绍他的实现细节。最后我们创建一个 网格/列表 UI 组件做总结。</p> <h2 id="the-positive-spin-（积极的一面）"><a href="#the-positive-spin-（积极的一面）" name="the-positive-spin-（积极的一面）"></a>The Positive Spin （积极的一面）</h2> <p>要了解 UI 组件的目标，最简单的方法的是从 Magento 1 的生成后台用户界面的代码说起。下面是 Magento 1 layout update XML 一部分代码，我们以他为例：</p> <pre><code>&lt;!-- #File: app/design/adminhtml/default/default/layout/catalog.xml --&gt; &lt;adminhtml_catalog_product_new&gt; &lt;update handle="editor"/&gt; &lt;reference name="content"&gt; &lt;block type="adminhtml/catalog_product_edit" name="product_edit"&gt;&lt;/block&gt; &lt;/reference&gt; &lt;reference name="left"&gt; &lt;block type="adminhtml/catalog_product_edit_tabs" name="product_tabs"&gt;&lt;/block&gt; &lt;/reference&gt; &lt;reference name="js"&gt; &lt;block type="adminhtml/catalog_product_edit_js" template="catalog/product/js.phtml" name="catalog_product_js"&gt;&lt;/block&gt; &lt;block type="core/template" template="catalog/wysiwyg/js.phtml"/&gt; &lt;/reference&gt; &lt;/adminhtml_catalog_product_new&gt; </code></pre> <p>这四个 layout 添加了一个产品编辑表， 考虑到 <code>&lt;update handle="editor"/&gt;</code> 部分</p> <pre><code>&lt;!-- #File: app/design/adminhtml/default/default/layout/main.xml --&gt; &lt;editor&gt; &lt;reference name="head"&gt; &lt;action method="setCanLoadExtJs"&gt;&lt;flag&gt;1&lt;/flag&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;mage/adminhtml/variables.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;mage/adminhtml/wysiwyg/widget.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;lib/flex.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;lib/FABridge.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;mage/adminhtml/flexuploader.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;mage/adminhtml/browser.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addJs"&gt;&lt;script&gt;prototype/window.js&lt;/script&gt;&lt;/action&gt; &lt;action method="addItem"&gt;&lt;type&gt;js_css&lt;/type&gt;&lt;name&gt;prototype/windows/themes/default.css&lt;/name&gt;&lt;/action&gt; &lt;action method="addCss"&gt;&lt;name&gt;lib/prototype/windows/themes/magento.css&lt;/name&gt;&lt;/action&gt; &lt;/reference&gt; &lt;/editor&gt; </code></pre> <p>你会发现给页面添加一个编辑表单是很复杂的事情。</p> <p>UI 组件的意图是隐藏这种复杂性。Magento 在 layout handle xml 文件中引入了新的<code>&lt;uiComponent/&gt;</code>标签。(Magento 2 handle XML files 类似 Magento 1 的 layout update XML files)在 Magento 2 中，你可以通过下面的代码给页面添加一个产品编辑表单。</p> <pre><code>&lt;uiComponent name="product_form"/&gt; </code></pre> <p>通过引入<code>&lt;uiComponent/&gt;</code>，Magento 2 让开发者更容易在不同位置重用不同的组件。While It was possible to drop different Magento 1 UI forms and grids in different areas, you needed to know which blocks and javascript files made up a particular component. Magento 1’s approach made it easy to accidentally setup a grid listing or a form so the component almost worked.</p> <p>Magento 2 的 UI 组件正是用来解决这一问题的，它也极大地简化了每个人的 layout handle xml 文件。</p> <h2 id="the-actual-spin-（实际情况）"><a href="#the-actual-spin-（实际情况）" name="the-actual-spin-（实际情况）"></a>The Actual Spin （实际情况）</h2> <p>我们刚刚所说的的确是真的，不过 UI 组件系统比美丽的构想更模糊。这是因为 UI 组件还有很多其他目标，这些目标带来了相当的复杂性。</p> <p>就我所知，UI 组件系统：</p> <ul> <li>简化了 Layout Handle XML 文件</li> <li>使得后台用户界面元素的构建从 HTML+Javascript 变成了纯 js 的自定义小部件系统。</li> <li>可以由较小的组件构造出更复杂的 UI 组件。</li> <li>Pre-renders data for UI components as JSON, binding closely to Magento backend data objects</li> <li>使用 ajax 来更新组件的数据</li> <li>Introduce a new DSL for creating all of the above</li> </ul> <p>UI 组件系统是雄心勃勃的一个系统，和 Magento 2中的许多东西一样，它还没有完全出炉（没有稳定）。一方面你可能想要远离还不太完美的系统，另一方面大多数的网格和表单使用 UI 组件系统来构建界面，还有一些使用传统的 block 渲染加 js 文件。如果你想构建一个全功能的模块，你需要使用 UI 组件系统。</p> <p>下文代表着我（Alan）对当前的（Magento 2.1）UI组件的理解.其中的细节将来很可能会有变化，但是希望核心的概念保持不变。</p> <p>没有为想要开发后台 UI 界面的开发人员准备的标准实践课程——像往常一样，最好的做法是看看核心团队对他们自己的组件做了什么，模仿他们，并且在 Magento 版本更新的时候，密切注意自己的模块/扩展代码。</p> <p>如果你对复杂的实现细节没有兴趣，你可以跳到文章末尾，使用 Pestle 创建 UI 组件部分。</p> <h2 id="pure-javascript-（纯-js）js"><a href="#pure-javascript-（纯-js）js" name="pure-javascript-（纯-js）js"></a>Pure Javascript （纯 JS）</h2> <p>如果你后台进入 <strong>Content -&gt; Block</strong>，你会看到你 Magento 系统中的所有 CMS Blocks 列在一张表格中。如果你对 Blocks 不是很了解，他们是创建可重用的 HTML 代码块的一种方式。Block information is stored in Magento’s backend using <a href="http://alanstorm.com/magento_2_crud_models_for_database_access/" target="_blank">CRUD Models</a>。</p> <p>你看到的列表就是一个 UI 组件，是通过以下 layout handle xml 配置的。</p> <pre><code>&lt;!-- File: vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.xml --&gt; &lt;!-- ... --&gt; &lt;referenceContainer name="content"&gt; &lt;uiComponent name="cms_block_listing"/&gt; &lt;/referenceContainer&gt; &lt;!-- ... --&gt; </code></pre> <p>如果你对 layout xml 完全陌生，上面的代码解释一下就是：</p> <pre><code>获得名为 content 的 container 的引用，把 cms_block_listing UI 组件加进去。 </code></pre> <p>如果你查看 HTML 源代码，你会发现<code>&lt;uiComponent/&gt;</code>标签渲染出了如下 HTML 代码：</p> <pre><code>&lt;div class="admin__data-grid-outer-wrap" data-bind="scope: 'cms_block_listing.cms_block_listing'"&gt; &lt;div data-role="spinner" data-component="cms_block_listing.cms_block_listing.cms_block_columns" class="admin__data-grid-loading-mask"&gt; &lt;div class="spinner"&gt; &lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt; &lt;script type="text/x-magento-init"&gt; {"*": {"Magento_Ui/js/core/app": {...very large js object...}}} &lt;/script&gt; &lt;/div&gt; </code></pre> <p>如果你阅读过 Magento 2 高级 js 系列的文章，尤其是<a href="/alan-magento-2-javascript-init-scripts/" target="_blank">Magento 2 Javascript Init Scripts</a>，你就知道 <code>x-magento-init</code> 标签将会调用 <code>Magento_Ui/js/core/app</code> RequireJS 模块，并将<code>large js object</code>作为参数传递给他。</p> <p>不涉及更深入的实现细节（实现细节 some of which you can read about in <a href="http://magento.stackexchange.com/questions/120447/how-does-magento-2-apply-knockoutjs-bindings/120730#120730" target="_blank">these</a> Stack Exchange <a href="http://magento.stackexchange.com/questions/120221/magento-2-how-where-is-the-gettemplate-knockout-function-bound/120508#120508" target="_blank">answers</a>），this javascript code ends up creating a series of javascript constructor objects that Magento will use as KnockoutJS view models（创建了一个用于 view model 的对象）</p> <p>浏览器中界面元素的实际呈现由 KnockoutJS 处理。外面的 div 框架使用了<a href="http://magento.stackexchange.com/questions/120447/how-does-magento-2-apply-knockoutjs-bindings/120730" target="_blank">Magento’s custom KnockoutJS scope binding</a>，绑定由<code>text/x-magento-init</code>创建的view model。</p> <pre><code>&lt;div ... data-bind="scope: 'cms_block_listing.cms_block_listing'"&gt; &lt;/div&gt; </code></pre> <p>然后渲染 UI 组件通过 KnockoutJS 的 “tag-less” template binding 完成。</p> <pre><code>&lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt; </code></pre> <p>对<code>getTemplate</code>的调用实际上启动了一系列嵌套的模板渲染——从一个名为<code>collection.html</code>的文件开始。你可以通过浏览器的 XHR 调试窗口查找所有<code>.html</code>的模板文件。如果你这里有较多疑惑，你可以参阅<a href="/alan_magento_2_knockoutjs_integration/" target="_blank">Magento 2 KnockoutJS 集成</a>。另外，记住Magento 的核心团队<a href="http://magento-quickies.alanstorm.com/post/147052601955/magentos-knockoutjs-templates-arent-knockoutjs" target="_blank">使用了一些自定义的标签和属性来增强KnockoutJS的模板</a>，这可能会带给你一些迷惑。</p> <p>总的来说，Magento 1 用 HTML 来渲染，用 js 增强用户界面的功能。Magento 2 依然会使用一些 HTML 搭建结构，但是用户界面元素的大部分渲染工作转由 RequireJS 模块和 KnockoutJS 模板来做。</p> <h2 id="sub-components-（子组件）"><a href="#sub-components-（子组件）" name="sub-components-（子组件）"></a>Sub Components （子组件）</h2> <p>如果仔细审视一下<code>x-magento-init</code>的 JSON 对象，你会发现他有很多嵌套的子对象。</p> <pre><code>{ "*": { "Magento_Ui/js/core/app": { "types": /*...*/ "components": { "cms_block_listing": { "children": { "cms_block_listing": { /*...*/ "children": { "listing_top": { "type": "container", "name": "listing_top", "children": { "bookmarks": {/*...*/}, "columns_controls": {/*...*/}, "fulltext": {/*...*/}, "listing_filters": {/*...*/}, "listing_massaction": {/*...*/}, "listing_paging": {/*...*/} }, </code></pre> <p>Older developers will be bemused to note the return of nodes named <code>children</code> — a practice we thought was left behind in Magento 1. These child element are each, themselves, fully featured UI Components. <code>cms_block_listing</code> 是由 <code>listing_top</code>, <code>bookmarks</code>, 等组件构成的。</p> <p>前文我们提到，<code>getTemplate</code>的调用以渲染许多子组件告终。<code>collection.html</code>作为第一个 KnockoutJS 模板，他的命名也体现了这是由许多 UI 组件构成的<code>collection</code>。很遗憾，今天的教程没有时间完整梳理这个渲染流程。</p> <p>今天我们要讲的是 PHP 开发者如何控制渲染的 js tree。我们回到<code>&lt;uiComponent/&gt;</code>标签。</p> <pre><code>&lt;!-- #File: vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.xml --&gt; &lt;uiComponent name="cms_block_listing"/&gt; </code></pre> <p>Magento 使用<code>uiComponent</code>的<code>name</code>查找名为<code>cms_block_listing.xml</code>的 XML 文件。</p> <pre><code>#File: vendor/magento//module-cms/view/adminhtml/ui_component/cms_block_listing.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- /** * Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details. */ --&gt; &lt;listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;item name="js_config" xsi:type="array"&gt; &lt;item name="provider" xsi:type="string"&gt;cms_block_listing.cms_block_listing_data_source&lt;/item&gt; &lt;item name="deps" xsi:type="string"&gt;cms_block_listing.cms_block_listing_data_source&lt;/item&gt; &lt;/item&gt; &lt;item name="spinner" xsi:type="string"&gt;cms_block_columns&lt;/item&gt; &lt;item name="buttons" xsi:type="array"&gt; &lt;item name="add" xsi:type="array"&gt; &lt;item name="name" xsi:type="string"&gt;add&lt;/item&gt; &lt;item name="label" xsi:type="string" translate="true"&gt;Add New Block&lt;/item&gt; &lt;item name="class" xsi:type="string"&gt;primary&lt;/item&gt; &lt;item name="url" xsi:type="string"&gt;*/*/new&lt;/item&gt; &lt;/item&gt; &lt;/item&gt; &lt;/argument&gt; &lt;!-- ... we'll get to this in a second ... --&gt; &lt;/listing&gt; </code></pre> <p>These UI Component XML files are a new <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank">domain specific language (DSL)</a>。上面的指令告诉 Magento</p> <ol> <li>Look up a PHP class name and default arguments for the root level <code>listing</code> node</li> <li>Instantiate that class, using the <code>argument</code> node as constructor arguments.</li> </ol> <p>Magento 将会从下面的文件中查找 PHP 类名和默认的参数。</p> <pre><code>#File: vendor/magento/module-ui/view/base/ui_component/etc/definition.xml &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt; &lt;!-- ... --&gt; &lt;listing sorting="true" class="Magento\Ui\Component\Listing"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;item name="template" xsi:type="string"&gt;templates/listing/default&lt;/item&gt; &lt;item name="save_parameters_in_session" xsi:type="string"&gt;1&lt;/item&gt; &lt;item name="client_root" xsi:type="string"&gt;mui/index/render&lt;/item&gt; &lt;item name="config" xsi:type="array"&gt; &lt;item name="component" xsi:type="string"&gt;uiComponent&lt;/item&gt; &lt;/item&gt; &lt;/argument&gt; &lt;/listing&gt; &lt;!-- ... --&gt; &lt;/components&gt; </code></pre> <p>所以，当 Magento 渲染 时，他就像下面这样开始运行（简化后的样子），</p> <pre><code>$uiComponent = new Magento\Ui\Component\Listing( $context, $components, [ 'template'=&gt;'templates/listing/default', 'save_parameters_in_session'=&gt;'1', 'client_root'=&gt;'mui/index/render', 'config'=&gt;[ 'component'=&gt;'uiComponent' ], 'js_config'=&gt;[ 'provider'=&gt;'', 'deps'=&gt;'' ], 'spinner'=&gt;'cms_block_columns', 'buttons'=&gt;[ 'add'=&gt;[ 'name'=&gt;'add', 'label'=&gt;'Add New Block', 'class'=&gt;'primary', 'url'=&gt;'*/*/new' ] ], ] ) </code></pre> <p>参数的数据来自于<code>&lt;argument/&gt;</code>节点的合并。每个参数都有不同的作用——不过我们感兴趣的是<code>templates/listing/default</code>参数。他指定了该组件渲染的 <strong>XHTML template</strong>。<code>templates/listing/default</code>字符串对应下面的模板。</p> <pre><code>#File: vendor/magento//module-ui/view/base/ui_component/templates/listing/default.xhtml &lt;div class="admin__data-grid-outer-wrap" data-bind="scope: '{{getName()}}.{{getName()}}'" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../Ui/etc/ui_template.xsd"&gt; &lt;div data-role="spinner" data-component="{{getName()}}.{{getName()}}.{{spinner}}" class="admin__data-grid-loading-mask"&gt; &lt;div class="spinner"&gt; &lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt; &lt;/div&gt; </code></pre> <p>这个 XHTML 模版是由完全不同于 Magento 中标准的 phtml 模版渲染引擎所渲染。</p> <p>Magento 通过调用 UI 组件对象中方法（<code>getName()</code>）替换<code>{{...}}</code>文本，或者 directly accessing a data property of the same object (<code>{{spinner}}</code>).</p> <p>可能有人已经注意到模板中没有<code>x-magento-init</code>。加入<code>x-magento-init</code>部分也是由 XHTML rendering engine 完成的——更确切的说，在<code>appendLayoutConfiguration</code>方法中。</p> <pre><code>#File: vendor/magento/module-ui/TemplateEngine/Xhtml/Result.php public function __toString() { try { //... $this-&gt;appendLayoutConfiguration(); $result = $this-&gt;compiler-&gt;postprocessing($this-&gt;template-&gt;__toString()); } catch (\Exception $e) { $this-&gt;logger-&gt;critical($e-&gt;getMessage()); $result = $e-&gt;getMessage(); } return $result; } //... public function appendLayoutConfiguration() { $layoutConfiguration = $this-&gt;wrapContent( json_encode( $this-&gt;structure-&gt;generate($this-&gt;component) ) ); $this-&gt;template-&gt;append($layoutConfiguration); } //... protected function wrapContent($content) { return '&lt;script type="text/x-magento-init"&gt;&lt;![CDATA[' . '{"*": {"Magento_Ui/js/core/app": ' . str_replace(['&lt;![CDATA[', ']]&gt;'], '', $content) . '}}' . ']]&gt;&lt;/script&gt;'; } </code></pre> <p>Magento 将会以 JSON 字符串的方式渲染 UI 组件对象的结构，然后将字符串添加到模版中。</p> <p>你问 UI 组件的结构是什么？ Remember the we’ll get to the rest in a second hand waving we did here?</p> <pre><code>#File: vendor/magento//module-cms/view/adminhtml/ui_component/cms_block_listing.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- /** * Copyright © 2016 Magento. All rights reserved. * See COPYING.txt for license details. */ --&gt; &lt;listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;item name="js_config" xsi:type="array"&gt; &lt;item name="provider" xsi:type="string"&gt;cms_block_listing.cms_block_listing_data_source&lt;/item&gt; &lt;item name="deps" xsi:type="string"&gt;cms_block_listing.cms_block_listing_data_source&lt;/item&gt; &lt;/item&gt; &lt;item name="spinner" xsi:type="string"&gt;cms_block_columns&lt;/item&gt; &lt;item name="buttons" xsi:type="array"&gt; &lt;item name="add" xsi:type="array"&gt; &lt;item name="name" xsi:type="string"&gt;add&lt;/item&gt; &lt;item name="label" xsi:type="string" translate="true"&gt;Add New Block&lt;/item&gt; &lt;item name="class" xsi:type="string"&gt;primary&lt;/item&gt; &lt;item name="url" xsi:type="string"&gt;*/*/new&lt;/item&gt; &lt;/item&gt; &lt;/item&gt; &lt;/argument&gt; &lt;!-- ... we'll get to this in a second ... --&gt; &lt;/listing&gt; </code></pre> <p>如果我们看一看上面的节点内容</p> <pre><code>#File: vendor/magento//module-cms/view/adminhtml/ui_component/cms_block_listing.xml  &lt;listingToolbar name="listing_top"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;!-- ... --&gt; &lt;/argument&gt; &lt;/listingToolbar&gt; &lt;columns name="cms_block_columns"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;!-- ... --&gt; &lt;/argument&gt; &lt;/columns&gt; </code></pre> <p>我们会发现更多配置的 UI 组件。所有名称不是 <code>argument</code> 的 UI 组件的子节点，都是父对象的子节点。Magneto 渲染 <code>listing</code> 对象的时候，它还会在 <code>definitions.xml</code> 中查找 <code>listingToolbar</code>, <code>columns</code> 等组件的类和参数。</p> <pre><code>#File: vendor/magento/module-ui/view/base/ui_component/etc/definition.xml &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt; &lt;listingToolbar class="Magento\Ui\Component\Container"&gt;&lt;!--...--&gt;&lt;/listingToolbar&gt; &lt;columns class="Magento\Ui\Component\Listing\Columns"&gt;&lt;!--...--&gt;&lt;/columns&gt; &lt;/components&gt; </code></pre> <p>之前我们用的伪代码实际上更像下面这样：</p> <pre><code>$uiComponent = new Magento\Ui\Component\Listing(...);  $listingToolbar = new Magento\Ui\Component\Container(...); $columns = new Magento\Ui\Component\Listing\Columns(...);  $uiComponent-&gt;addComponent($listingToolbar); $uiComponent-&gt;addComponent($columns); </code></pre> <p>注意，这些子组件是通过 RequireJS 模块名称来进行配置的。</p> <pre><code>#File: vendor/magento/module-ui/view/base/ui_component/etc/definition.xml &lt;columns class="Magento\Ui\Component\Listing\Columns"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;item name="config" xsi:type="array"&gt; &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/listing&lt;/item&gt; &lt;!-- ... --&gt; &lt;/item&gt; &lt;/argument&gt; &lt;/columns&gt; </code></pre> <p>这些就是 Magento 转化为 KnockoutJS view model 的 RequireJS 模块。如果你查看 KnockoutJS view models 的代码，你将发现通常 view model constructor 中配置了其 template 模版。</p> <pre><code>#File: vendor/magento//module-ui/view/base/web/js/grid/listing.js define([ 'ko', 'underscore', 'Magento_Ui/js/lib/spinner', 'uiLayout', 'uiCollection' ], function (ko, _, loader, layout, Collection) { 'use strict';  return Collection.extend({ defaults: { template: 'ui/grid/listing', } //... }); }); </code></pre> <h2 id="data-source-nodes-（数据源节点）"><a href="#data-source-nodes-（数据源节点）" name="data-source-nodes-（数据源节点）"></a>Data Source Nodes （数据源节点）</h2> <p>最后，有一个特别的 UI 组件子节点，就是<code>&lt;dataSource/&gt;</code></p> <pre><code>#File: vendor/magento//module-cms/view/adminhtml/ui_component/cms_block_listing.xml &lt;listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt; &lt;argument name="data" xsi:type="array"&gt; &lt;item name="js_config" xsi:type="array"&gt; &lt;item name="provider" xsi:type="string"&gt;cms_block_listing.cms_block_listing_data_source&lt;/item&gt; &lt;item name="deps" xsi:type="string"&gt;cms_block_listing.cms_block_listing_data_source&lt;/item&gt; &lt;/item&gt; &lt;item name="spinner" xsi:type="string"&gt;cms_block_columns&lt;/item&gt; &lt;item name="buttons" xsi:type="array"&gt; &lt;item name="add" xsi:type="array"&gt; &lt;item name="name" xsi:type="string"&gt;add&lt;/item&gt; &lt;item name="label" xsi:type="string" translate="true"&gt;Add New Block&lt;/item&gt; &lt;item name="class" xsi:type="string"&gt;primary&lt;/item&gt; &lt;item name="url" xsi:type="string"&gt;*/*/new&lt;/item&gt; &lt;/item&gt; &lt;/item&gt; &lt;/argument&gt; &lt;!-- ... --&gt; &lt;dataSource name="cms_block_listing_data_source"&gt; &lt;!-- ... --&gt; &lt;/dataSource&gt; &lt;/listing&gt; </code></pre> <p>名为 <code>dataSource</code> 的节点仍然是 UI 组件，不过他们有“特殊待遇”。当 Magento 从 UI 组件中渲染 JSON 的时候，dataSource 节点被从 <code>children</code> 结构中拉出来，Magento 在主要的顶层组件之后就渲染他们（在组件名后加 <code>_data_source</code> 作为对象的键值）</p> <p>（译者注，还记得上面的子组件 <code>listing_top</code> 吧，他的层级和 <code>dataSource</code> 节点是一样的，按照道理他应该在 <code>children</code> 下和 <code>listing_top</code> 并列在一个层级，但是现在上升了一个层级，和 <code>cms_block_listing</code> 并列了。）</p> <pre><code>{ "*": { "Magento_Ui/js/core/app": { "types": /*...*/ "components": { "cms_block_listing": { "children": { "cms_block_listing": { /*...*/ "children": { "listing_top": { "type": "container", "name": "listing_top", "children": { "bookmarks": {/*...*/}, "columns_controls": {/*...*/}, "fulltext": {/*...*/}, "listing_filters": {/*...*/}, "listing_massaction": {/*...*/}, "listing_paging": {/*...*/} }, </code></pre> <p><code>dataSource</code> 组件就是 Magento 寻找 UI 组件真实数据的地方。UI 组件中的数据由 <code>dataSource</code> 组件提供。</p> <h2 id="summary-of-the-ui-component-rendering-dsl-（总结）"><a href="#summary-of-the-ui-component-rendering-dsl-（总结）" name="summary-of-the-ui-component-rendering-dsl-（总结）"></a>Summary of the UI Component Rendering DSL （总结）</h2> <p>OK — that was a bananas-pants amount of information. I just finished writing it and I’m not sure even I followed all of it, so don’t worry if your head is spinning.</p> <p>下面是比较高层面的总结。</p> <ol> <li>UI 组件通过 <code>x-magento-init</code> 脚本注入全局注册的 KnockoutJS view models （原文：UI Components render an x-magento-init script that populates a global registry of KnockoutJS view models）</li> <li>UI 组件也加载 HTML 骨架，然后使用 KnockoutJS 和自定义的 <code>scope</code> 绑定来渲染 DOM 节点租成组件。</li> <li><code>ui_component</code> XML 文件是一种领域特定语言（domain specific language），用来示例嵌套的层级 UI 组件对象。Magento 会使用它来为 <code>x-magento-init</code> 脚本加载 JSON</li> <li><code>ui_component</code> XML 节点的名称用来查找 php 类进行实例化</li> <li>Magento 使用子节点 <code>&lt;argument/&gt;</code> 作为该类的构造参数</li> <li>Magento 使用 <code>&lt;dataSource /&gt;</code> 中的数据作为 UI 组件的数据源。（例如表格列表中的信息）</li> <li>子节点将会作为子组件进行渲染——这些子组件遵循和父组件一样的规则</li> <li>最顶层的 UI 组件配置的 XHTML 模版，Magento 通过 PHP 进行渲染</li> <li>UI 组件节点配置 RequireJS 模块，而 Magento 使用他们作为 KnockoutJS view model constructors</li> </ol> <p>正如你所看到的，一方面 uiComponent 极大地简化了 Magento 2 中 layout handle XML 文件，隐藏了包括前后台在内的更为复杂的 UI 渲染系统，另一方面这对开发者来说，也要求你理解 Magento 对 RequireJS 和 KnockoutJS 做出的自定义。</p> <h2 id="creating-a-grid-listing-with-pestle-（创建一个列表）"><a href="#creating-a-grid-listing-with-pestle-（创建一个列表）" name="creating-a-grid-listing-with-pestle-（创建一个列表）"></a>Creating a Grid Listing with Pestle （创建一个列表）</h2> <p>从上文可以了解到，UI 组件系统，为了降低 Magento 1 的 layout update XML 系统的复杂度，提供更明确的使用指导。换句话说，对 Magento 2 开发者来说，这正是代码生成工具（例如 <a href="https://github.com/astorm/pestle" target="_blank">pestle</a> ，这是 Alan Storm 的一个项目）的用武之地。</p> <p><em>译者注：由于这一段操作有较多的前提条件，而且使用代码自动生成工具，对我们理解如何创建一个列表的帮助可能不太大，所以此处不再继续翻译，有兴趣的请阅读原文。而关于如何用 uiComponent 创建列表，下次再补上其他的文章。</em></p> <p>参考 <a href="/how-to-create-admin-grid-in-magento-2" target="_blank">How to Create Admin Grid in Magento 2</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_simplest_ui_component/]]></link>
		<title><![CDATA[Magento 2: Simplest UI Component]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><a href="https://alanstorm.com/magento_simplest_ui_component/">原文地址</a></p> <p>今天我们将深入 Magento 2 的 ui components ，并尝试从头创建一个。现阶段的 Maggento 2 创建一个 ui component ，需要用一些不同寻常的，对生产环境来说不安全的方法，但是要想真正了解一个系统，有时候就是要从“地基”开始。</p> <p>和这个系列的其他教程一样，请确保 Magento 2 是 developer 模式。为了防止下面的步骤不管用，我们在 <a href="https://github.com/astorm/magento2-simple-ui-component">github 上放了完整的模块代码</a>。还有，以下基于 Magento 2.1.1 ，但是文中涉及的概念是适用所有版本的。</p> <h2 id="用-pestle-创建基本的模块"><a href="#用-pestle-创建基本的模块" name="用-pestle-创建基本的模块"></a>用 Pestle 创建基本的模块</h2> <p>首先，我们用 <a href="https://github.com/astorm/pestle">pestle</a>来创建一个带后台 menu 的模块。如果你不清楚下面的命令在干啥，那你可能要看看 <a href="https://alanstorm.com/category/magento-2/#magento_2_mvc">Magento 2 for PHP MVC Developers</a> 系列文章</p> <p>首先取得 pestle.phar</p> <pre><code>curl -LO http://pestle.pulsestorm.net/pestle.phar </code></pre> <p>然后</p> <pre><code>php pestle.phar generate_module Pulsestorm SimpleUiComponent 0.0.1  php pestle.phar generate_acl Pulsestorm_SimpleUiComponent Pulsestorm_SimpleUiComponent::top,Pulsestorm_SimpleUiComponent::menu_1  php pestle.phar generate_menu Pulsestorm_SimpleUiComponent Magento_Backend::system_other_settings Pulsestorm_SimpleUiComponent::a_menu_item Pulsestorm_SimpleUiComponent::menu_1 "Hello Simple Ui Component" pulsestorm_simpleuicomponent/index/index 1  php pestle.phar generate_route Pulsestorm_SimpleUiComponent adminhtml pulsestorm_simpleuicomponent  php pestle.phar generate_view Pulsestorm_SimpleUiComponent adminhtml pulsestorm_simpleuicomponent_index_index Main content.phtml 1column  php bin/magento module:enable Pulsestorm_SimpleUiComponent  php bin/magento setup:upgrade </code></pre> <p>运行上述命令后，登陆后台，应该就能通过 <strong>System -&gt; Other Settings -&gt; Hello Simple Ui Component</strong> 进入到刚刚创建的页面中了。</p> <h2 id="配置-ui-component"><a href="#配置-ui-component" name="配置-ui-component"></a>配置 UI component</h2> <p>点击 <strong>System -&gt; Other Settings -&gt; Hello Simple Ui Component</strong> 进入到刚刚创建的页面，你看到的是这样子的：</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-component-first.png" alt="simple-ui-component" /></p> <p>首先我们要做的是给我们的 layout handle xml 文件加 <code>&lt;uiComponent&gt;</code></p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/layout/pulsestorm_simpleuicomponent_index_index.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;referenceBlock name="content"&gt;         &lt;block template="content.phtml" class="Pulsestorm\SimpleUiComponent\Block\Adminhtml\Main" name="pulsestorm_simpleuicomponent_block_main" /&gt;          &lt;!-- START: our new ui component --&gt;         &lt;uiComponent name="pulsestorm_simple"/&gt;         &lt;!-- END:   our new ui component --&gt;     &lt;/referenceBlock&gt; &lt;/page&gt; </code></pre> <p>上面的代码，我们告诉 Magento 我们要加一个 <code>pulsestorm_simple</code> UI component 到页面的 content block 中。然后没咱们清空缓存，刷新页面，我们会看到如下的错误：</p> <pre><code>1 exception(s): Exception #0 (Magento\Framework\Exception\LocalizedException): Object  DOMDocument should be created.  Exception #0 (Magento\Framework\Exception\LocalizedException): Object  DOMDocument should be created. #0 /path/to/magento/ vendor/magento/framework/View/Element/UiComponent/Config/Reader.php(95): Magento\Framework\View\Element\UiComponent\Config\DomMerger-&gt;getDom() </code></pre> <p>错误原因是我们配置一个叫 <code>pulsestorm_simple</code> 的 ui component ，但是 Magento 又找不到它的定义文件。<code>Object DOMDocument should be created</code> 错误来自于 php 代码尝试载入一个不存在的 xml object。</p> <p>任何 ui component 都需要一个 <code>ui_component/[...].xml</code> 定义文件。下面我们修复这个问题。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;pulsestorm_simple xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt; &lt;/pulsestorm_simple&gt; </code></pre> <p>ui component 的名字（pulsestorm_simple）和它的 xml 文件名（pulsestorm_simple.xml）需要一致。所有 ui component 的文件都在 <a href="frontend/adminhtml">area</a>/view/ui_component 目录下。尽管不限制使用 ui component 在 <code>frontend</code> area 中，但是前台不一定会像预期的那样管用，因为 Magento 核心团队大多数情况下（只在？）后台 layout 中使用 ui components 。</p> <p>清除缓存，刷新页面后，我们会得到一个新的错误：</p> <pre><code>1 exception(s): Exception #0 (Magento\Framework\Exception\LocalizedException): Element 'pulsestorm_simple': No matching global declaration available for the validation root. Line: 1 </code></pre> <p>这里，我们的顶层节点名字叫 <code>pulsestorm_simple</code> 。回顾上篇 <a href="https://www.hellomagento2.com/alan_magento_2_introducing_ui_components/">Magento 2 的 UI Components 介绍（翻译）</a>， ui component 文件是 domain specific language (DSL)，由它控制嵌套的 php 对象的实例化。<code>ui_component</code> 文件中的每个节点对应着下面这个文件中的节点。</p> <pre><code>vendor/magento/module-ui/view/base/ui_component/etc/definition.xml </code></pre> <p>所以，问题是我们的节点 <code>pulsestorm_simple</code> 不在 <code>definition.xml</code> 中，Magento 的 UI component DSL 当然也就不知道遇到这个节点的时候，用哪个 php 类去实例化。多亏了 Magento 会合并配置文件再载入，我们就可以通过添加下面的文件来改变合并后的 <code>definition.xml</code> （<strong>必须搁在 <code>base</code> 下面才管用</strong>）</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml --&gt; &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"/&gt; &lt;/components&gt; </code></pre> <p>通过上面的配置，我们等于告诉 Magento</p> <p><em>遇到 <code>pulsestorm_simple</code> ui component 节点，请实例化 <code>Pulsestorm\SimpleUiComponent\Component\Simple</code></em></p> <p>命名要注意，因为我们的文件会和核心 <code>definition.xml</code> 进行合并，如果你的命名和核心中的重名了，那么可能就改变系统原来的行为了。推荐加上 vendor namespace 作为前缀（pulsestorm_ ）</p> <p>清空缓存，刷新页面，我们会得到一个新的错误：</p> <pre><code>1 exception(s): Exception #0 (Magento\Framework\Exception\LocalizedException): Element 'pulsestorm_simple': This element is not expected. Expected is one of ( range, tab, dataSource, paging, massaction, listing, form, fieldset, field, filters ). </code></pre> <p>Magento 正在合并我们的 <code>definition.xml</code>，但必须通过 schema validation 。具体来说，Magento 要求最终的 <code>definition.xml</code> 要符合下面这个文件中定义结构要求：</p> <pre><code>vendor/magento/module-ui/etc/ui_definition.xsd </code></pre> <p>很不幸的是，Magento 2 没有提供方法让我们加入规则。如果你知道查看哪里（Magento\Framework\Config\Dom::validateDomDocument），可以使用 object manager 的 preference 来注入一些自定义的行为，这样我们是可以让 Magento 跳过 XSD 验证的。但是，很不幸，这么做可能跟其他也这么做的插件冲突。所以如果你打算发布代码的话，这么做可不太合适。使用 Magento 的 plugin 方式（更安全稳定些）也是不行的，因为 <code>validateDomDocument</code> 虽然是 public 但它是 static 方法，Magento 的 plugin system 不支持 static 方法。</p> <p>到这里，我们想创建一个全新的、顶层的 ui_component 节点是行不通的。这预示着，Magento 的 UI component 系统是为官方核心开发保留的，也可能说是 UI component 还不是功能齐全的。</p> <h2 id="跳过验证"><a href="#跳过验证" name="跳过验证"></a>跳过验证</h2> <p>当然咯，上面我们说行不通，是说，用安全稳定的方法做不到，但是我们还是可以通过可能不那么稳定的 class preference 来做到嘛。</p> <p>Magento 的开发者通过 calss preference 定义 interfaces 对应的具体类，object manager 遇到这个 interface 的时候，就会去实例化对应的具体类。</p> <p>Class preference 还可以用来替换具体的类，和 Magento 1 中 class rewrites 有非常相似的功能（缺点也是一样的）。</p> <p>下面我们将用 class preference 方式来跳过 XML 的 XSD 验证。在生产环境中，或是要发布的系统中，这么做是不合适的，但是这里只是为了让教程继续下去。</p> <p>创建 di.xml 文件：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/etc/di.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd"&gt;                                                                --&gt;     &lt;preference for="Magento\Framework\App\Arguments\ValidationState" type="Pulsestorm\SimpleUiComponent\Model\ValidationState"/&gt;  &lt;/config&gt; </code></pre> <p>然后添加下面的文件：</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Model/ValidationState.php &lt;?php namespace Pulsestorm\SimpleUiComponent\Model; class ValidationState extends \Magento\Framework\App\Arguments\ValidationState {     public function isValidationRequired()     {         return false;     } } </code></pre> <p>关于为什么这么做就可以跳过 XSD 验证，本篇不介绍，有兴趣的读者可以自己研究下，不过<a href="https://alanstorm.com/magento-2-more-plugin-edge-cases/">这篇</a>可能对你有帮助。</p> <p>清理缓存后刷新页面，这次看到一个新的错误：</p> <pre><code>1 exception(s): Exception #0 (ReflectionException): Class Pulsestorm\SimpleUiComponent\Component\Simple does not exist </code></pre> <p>XSD 验证跳过了，我们可以继续探索了。</p> <p><strong>UPDTE:</strong> Hello, from late 2017! When Magento release version 2.2, they broke this tutorial. If you’re using Magento 2.2, in addition to disabling XSD validation, you’ll also need to add a <a href="https://github.com/astorm/magento2-simple-ui-component/blob/master/first-pass-unstable/app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.map.xml">definition.map.xml</a> file with a name=”puslestorm_simple” node. Why? We have no idea and Magento haven’t really explained what this file is for. Open source doesn’t always mean open intent. If you’re using Magento 2.2 just copy <a href="https://github.com/astorm/magento2-simple-ui-component/blob/master/first-pass-unstable/app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.map.xml">the file from GitHub</a> to your module and you should take take of any errors about undefined <code>children</code> keys.</p> <h2 id="ui-component-rendering-class"><a href="#ui-component-rendering-class" name="ui-component-rendering-class"></a>UI Component Rendering Class</h2> <p>在我们遇到 schema validation 的坑之前，我们在 <code>definition.xml</code> 中添加了以下设置：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml --&gt; &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"/&gt; &lt;/components&gt; </code></pre> <p><code>etc/definition.xml</code> 定义了<strong>默认的</strong>属性和节点，当 Magento 在 <code>ui_component/[somefile].xml</code> 遇到特定的节点的时候，就会用 <code>definition.xml</code> 中的值。以本例来说，当 Magento 遇到 <code>pulsestorm_simple</code> 时，就会使用 <code>Pulsestorm\SimpleUiComponent\Component\Simple</code> 类。就是说，下面我们使用 <code>pulsestorm_simple</code></p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;pulsestorm_simple xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; &lt;/pulsestorm_simple&gt; </code></pre> <p>Magento 会尝试用 <code>Pulsestorm\SimpleUiComponent\Component\Simple</code> 实例化对象，用这个对象去 render UI component。所以错误就是 <code>Pulsestorm\SimpleUiComponent\Component\Simple</code> 不存在。下面创建它。</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Component/Simple.php &lt;?php namespace Pulsestorm\SimpleUiComponent\Component; class Simple extends \Magento\Ui\Component\AbstractComponent {     const NAME = 'pulsestorm_simple';     public function getComponentName()     {         return static::NAME;     } } </code></pre> <p>Magento 2 的 UI component 类必须继承 <code>Magento\Ui\Component\AbstractComponent</code> 类，必须定义一个 <code>getComponentName</code> 方法。ui component 的 name 是否必须和 UI component node 的 name 一样，还是要和 <code>ui_componont/[filename].xml</code> (pulsestorm_simple) 一样不太清楚。但是最好是跟 Magento 的核心代码的做法保持一致。所以，我们也给我们的 component 一个 NAME constant 。</p> <p>清空缓存，刷新页面后我们得到了一个新的错误：</p> <pre><code>1 exception(s): Exception #0 (Magento\Framework\Exception\LocalizedException): Object DOMDocument should be created.  Exception #0 (Magento\Framework\Exception\LocalizedException): Object DOMDocument should be created. </code></pre> <p>这次 Magento 又报错说 XML 文件缺少了。ui component object （继承自 <code>Magento\Ui\Component\AbstractComponent</code>）负责 render XHML templates 。</p> <p>我们告诉 Magento ，我需要 render <code>Pulsestorm\SimpleUiComponent\Component\Simple</code> 对象，但是我们没告诉它 <code>Pulsestorm\SimpleUiComponent\Component\Simple</code> 这个对象应该用哪个 template 。下面我们修改 <code>definition.xml</code></p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml --&gt; &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="template" xsi:type="string"&gt;templates/our-template&lt;/item&gt;         &lt;/argument&gt;     &lt;/pulsestorm_simple&gt; &lt;/components&gt; </code></pre> <p>下面创建模板文件：</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/templates/our-template.xhtml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div&gt;     &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/div&gt; </code></pre> <p>UI component 将会在模块的 <code>view/[area]/ui_component</code> 目录下找 template。<code>definition.xml</code> 文件中的值会加上 <code>.xhtml</code> 后缀转成文件路径。请注意，虽然文件看起来很像 HTML ，但是他们是有 XML 头的。他们是 XHTML 文件，是需要格式良好的 XML 。</p> <p>下面清楚缓存，刷新页面，这次我们又看到一个新的错误，不过这次已经接近目标了。</p> <pre><code>( ! ) Fatal error: Method Magento\Ui\TemplateEngine\Xhtml\Result::__toString() must not throw an  exception, caught Error: Call to a member function getConfigData() on null  in /path/to/magento/  vendor/magento/module-ui/Component/Wrapper/UiComponent.php on line 0 </code></pre> <p>UI components 系统除了 render XHTML templates 外，还需要将特定的 XHTML template 与 data provider class 匹配起来。UI component 设计本意是从服务端获取数据，data provider 是 component 获得数据的正式方法。</p> <p>这意味着，创建一个最简单的 UI component 的最后一步就是配置一个 data provider class 。这个改动放在 <code>pulsestorm_simple.xml</code> 中，因为理论上每个 component 实例都 render 不同的 UI Component 。下面我们给 <code>pulsestorm_simple.xml</code> 添加 <code>dataSource</code> 节点。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;pulsestorm_simple xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;      &lt;dataSource name="pulsestorm_simple_data_source"&gt;         &lt;argument name="dataProvider" xsi:type="configurableObject"&gt;             &lt;!-- the PHP class that implements a data provider --&gt;             &lt;argument name="class" xsi:type="string"&gt;Pulsestorm\SimpleUiComponent\Model\DataProvider&lt;/argument&gt;              &lt;!-- redundant with the `dataSource` name --&gt;             &lt;argument name="name" xsi:type="string"&gt;pulsestorm_simple_data_source&lt;/argument&gt;              &lt;!-- required: means ui components are meant to work with models --&gt;             &lt;argument name="primaryFieldName" xsi:type="string"&gt;entity_id&lt;/argument&gt;              &lt;!-- required: means ui components are meant to work with URL passing --&gt;             &lt;argument name="requestFieldName" xsi:type="string"&gt;id&lt;/argument&gt;         &lt;/argument&gt;      &lt;/dataSource&gt;  &lt;/pulsestorm_simple&gt; </code></pre> <p>在 <code>&lt;dataSource/&gt;</code> 树中有一些冗余的样板命名约定需要注意。首先是 name 属性</p> <pre><code>&lt;dataSource name="pulsestorm_simple_data_source"&gt;...&lt;/dataSource&gt; </code></pre> <p>它是 UI component 名称（pulsestorm_simple）加上 <code>_data_source</code>，同样的还有下面的参数节点：</p> <pre><code>&lt;argument name="name" xsi:type="string"&gt;pulsestorm_simple_data_source&lt;/argument&gt; </code></pre> <p>这个参数节点是必要的，虽然它是冗余的。</p> <p>下面两个节点也是必要的：</p> <pre><code>&lt;argument name="primaryFieldName" xsi:type="string"&gt;entity_id&lt;/argument&gt; &lt;argument name="requestFieldName" xsi:type="string"&gt;id&lt;/argument&gt; </code></pre> <p>最后是 class</p> <pre><code>&lt;argument name="class" xsi:type="string"&gt;Pulsestorm\SimpleUiComponent\Model\DataProvider&lt;/argument&gt; </code></pre> <p>这里我们告诉我们的 component 使用哪个 PHP data provider class 去进行实例化。所以我们下面创建它。</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Model/DataProvider.php &lt;?php namespace Pulsestorm\SimpleUiComponent\Model; class DataProvider extends \Magento\Ui\DataProvider\AbstractDataProvider { } </code></pre> <p>DataProvider 类必须继承自 <code>Magento\Ui\DataProvider\AbstractDataProvider</code> —— 尽管这个类没有 abstract methods 需要定义。</p> <p>下面清空缓存，刷新页面。</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-component-second.png" alt="" /></p> <p>我们终于把 XHTML 模板给 render 出来啦。</p> <h2 id="幕后发生的事情"><a href="#幕后发生的事情" name="幕后发生的事情"></a>幕后发生的事情</h2> <p>在我们讨论可以用这个渲染的 XHTML 模板来做点什么事情之前，让我们先来谈谈幕后发生了什么。当 Magento 的 layout rendering code 遇到 UI component 标签的时候，一堆等同于下面的伪代码的代码就会执行。</p> <p>配置 ui_component 的整个过程是选择实例化的类，并在该类上设置数据属性。在本例中实例化过程就像这样：</p> <pre><code>$data = functionThatLoadsArgumentNodesFromXmlFiles(); $ui_component = new Pulsestorm\SimpleUiComponent\Component\Simple(     //...     [         'template'=&gt;'templates/our-template'     ], ); echo $ui_component-&gt;render(); </code></pre> <pre><code>$data = functionThatLoadsArgumentNodesFromXmlFiles(); $ui_component = new Pulsestorm\SimpleUiComponent\Component\Simple(     //...     $data, ); echo $ui_component-&gt;render(); </code></pre> <p>好的 DSL 通常会让你忘记像这样的实现细节——但是如果你从来没有遇到过 dsl， 这种事情看起来很奇怪， 也很陌生。每当你被一些 UI 组件的配置缠住时, 请记住您正在为 Magento 准备转换为 PHP 代码的值。这些值并不是简单的数据属性。</p> <h2 id="raw-template-source"><a href="#raw-template-source" name="raw-template-source"></a>Raw Template Source</h2> <p><img src="/wp-content/uploads/2018/05/simple-ui-component-second.png" alt="" /></p> <p>这是我们从浏览器中看到的样子，但是加载的源代码是什么样子的呢。我们查看网页源代码，不是 browser debugger 中。</p> <pre><code>&lt; div &gt;     &lt;h1 &gt; Hello World &lt; /h1&gt;     &lt;script type = "text/x-magento-init" &gt;     {         "*":         {             "Magento_Ui/js/core/app":             {                 "types":                 {                     "dataSource": [],                     "pulsestorm_simple":                     {                         "extends": "pulsestorm_simple"                     },                     "html_content":                     {                         "component": "Magento_Ui\/js\/form\/components\/html",                         "extends": "pulsestorm_simple"                     }                 },                 "components":                 {                     "pulsestorm_simple":                     {                         "children":                         {                             "pulsestorm_simple":                             {                                 "type": "pulsestorm_simple",                                 "name": "pulsestorm_simple"                             },                             "pulsestorm_simple_data_source":                             {                                 "type": "dataSource",                                 "name": "pulsestorm_simple_data_source",                                 "dataScope": "pulsestorm_simple",                                 "config":                                 {                                     "params":                                     {                                         "namespace": "pulsestorm_simple"                                     }                                 }                             }                         }                     }                 }             }         }     }     &lt; /script&gt; &lt;/div &gt; </code></pre> <p>Magento 从 XHTML template 中不仅仅是加载了 <code>&lt;div&gt;</code> 和 <code>&lt;h1&gt;</code> 标签，他还载入了一个 <code>text/x-magento-init</code> script 。这是我们今天要讨论的关于 UI component system 的最后一个方面。UI component 不仅加载 XHTML template，也不仅仅是将 template 和 data provider 对象绑定起来，他还加载一个 JSON 对象，通过 <code>x-magento-init</code> 的方式，用这个 JSON 对象来实例化 <code>Magento_Ui/js/core/app</code> RequireJS app/module。</p> <p>现在，我们知道 UI component 做的大致事情了，下面我们来看看这个 template/rendering engine 的一些功能。</p> <h2 id="xhtml-template-tags"><a href="#xhtml-template-tags" name="xhtml-template-tags"></a>XHTML Template Tags</h2> <p>和 <code>phtml</code> 模板类似 —— 你可以在 XHTML 模板中对底层的 UI Component 类进行 “调用”。你可以使用特殊的模板指令 <code>{{...}}</code>。下面我们看个例子，我们给 component 类添加一个 <code>getEvenMoreData</code> 方法。</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Component/Simple.php &lt;?php namespace Pulsestorm\SimpleUiComponent\Component; class Simple extends \Magento\Ui\Component\AbstractComponent {     const NAME = 'pulsestorm_simple';     public function getComponentName()     {         return static::NAME;     }      //added this method     public function getEvenMoreData()     {         return 'Even More Data!';     } } </code></pre> <p>我们可以在 <code>xhtml</code> template 中调用 <code>{{...}}</code></p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/templates/our-template.xhtml --&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div&gt;     &lt;h1&gt;Hello World&lt;/h1&gt;      &lt;p&gt;         {{getComponentName()}}     &lt;/p&gt;      &lt;p&gt;         {{getEvenMoreData()}}     &lt;/p&gt; &lt;/div&gt; </code></pre> <p>上面的代码保存后，清空缓存刷新页面。你就会看到类的方法/属性中的数据传递到模板上来了。</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-component-third.png" alt="" /></p> <p>除了调用对象中的方法，我们应该还能通过 data 配置节点来获得 data 属性值，就像下面这样。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml --&gt; &lt;argument name="data" xsi:type="array"&gt;     &lt;item name="template" xsi:type="string"&gt;templates/our-template&lt;/item&gt;      &lt;!-- NEW NODE HERE --&gt;     &lt;item name="message" xsi:type="string"&gt;Hello World&lt;/item&gt; &lt;/argument&gt; </code></pre> <p>然后再 xhtml 中调用它。</p> <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div&gt;     &lt;!-- ... --&gt;     {{message}} &lt;/div&gt; </code></pre> <p>但是，这里有个 <a href="https://github.com/magento/magento2/issues/6532">bug</a>，除非这个 data variable 在 tag 的属性中，否则加载的还是 <code>{{message}}</code> 而不是它的值。</p> <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div class="{{message}}"&gt;     &lt;!-- ... --&gt;     {{message}} &lt;/div&gt; </code></pre> <p>上面这一段 render 出来的是：</p> <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div class="Hello World"&gt;     &lt;!-- ... --&gt;     {{message}} &lt;/div&gt; </code></pre> <p>真是很烦人，再次表明 UI Component system 还不成熟。</p> <h2 id="理解-ui-component-继承"><a href="#理解-ui-component-继承" name="理解-ui-component-继承"></a>理解 UI Component 继承</h2> <p>在<code>definition.xml</code> 中放置顶级节点，意味着你创建了一个可重用的 UI 组件标签。其他程序员可以在 XML 文件中使用 <code>&lt;uiComponent&gt;</code> 使用你的组件。</p> <p><code>definition.xml</code> 文件还可以设置组件的默认值，不过这些值是可以被覆盖的。</p> <p>举例来说，我们设置了默认的模板：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml --&gt; &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="template" xsi:type="string"&gt;templates/our-template&lt;/item&gt;         &lt;/argument&gt;     &lt;/pulsestorm_simple&gt; &lt;/components&gt; </code></pre> <p>假设我们需要一个 <code>pulsestorm_simple</code> 组件，但是我们要换一个 template。那么我们可以按照相同的结构重写一下要用的 template。</p> <p>比如，我们需要下面的模板：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/templates/different.xhtml --&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div&gt;     &lt;h1&gt;Hello Brave New World&lt;/h1&gt; &lt;/div&gt; </code></pre> <p>我们需要做的就是增加下面 template 部分</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;pulsestorm_simple xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;     &lt;argument name="data" xsi:type="array"&gt;         &lt;item name="template" xsi:type="string"&gt;templates/different&lt;/item&gt;     &lt;/argument&gt;     &lt;!-- ... --&gt; &lt;/pulsestorm_simple&gt; </code></pre> <p>这个功能通常不作用于 template，它常用在配置参数的重写上，并且对于使用至关重要。在实际开发中，你不会向 <code>definition.xml</code> 中加东西，但是 debug grid listing 的参数时，还是需要参考 <code>definition.xml</code> 的。</p> <h2 id="添加数据"><a href="#添加数据" name="添加数据"></a>添加数据</h2> <p>今天我们要说的最后一件时 UI Component 的 data 。UI Component 的 data 类似于 grid listing 的行，或是 form 的默认值。Behind the scenes, the UI Component system can render this backend data for you in the frontend as a javascript array/object.</p> <p>我们需要做的就是在 component 类中定义 <code>getDataSourceData</code> 方法。</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Component/Simple.php     &lt;?php namespace Pulsestorm\SimpleUiComponent\Component; class Simple extends \Magento\Ui\Component\AbstractComponent {     &lt;!-- ... --&gt;     public function getDataSourceData()     {         return ['data' =&gt; ['foo'=&gt;'bar']];     } } </code></pre> <p>清除缓存并刷新页面后，查看源代码，我们会发现刚刚的 <code>foo =&gt; bar</code> 已经在 JSON 中了。</p> <pre><code>"pulsestorm_simple_data_source": {     //...     "config": {         "data": {             "foo": "bar"         }     //...     } } </code></pre> <p>你可能会感到很困惑，如果 data 来自于 component 类的 <code>getDataSourceData</code> 方法，那么为什么还要配置 <code>Pulsestorm\SimpleUiComponent\Model\DataProvider</code> 呢？</p> <p>Alan 也没有好的答案。基于核心代码，看起来正确的使用方式是，在 component 类中获得 data provider 对象，然后调用它的 <code>getData</code> 方法。</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Component/Simple.php public function getDataSourceData() {     return ['data' =&gt; $this-&gt;getContext()-&gt;getDataProvider()-&gt;getData()]; } </code></pre> <p>data provider 的 <code>getData</code> 方法返回实际的数据</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/Model/DataProvider.php &lt;?php namespace Pulsestorm\SimpleUiComponent\Model; class DataProvider extends \Magento\Ui\DataProvider\AbstractDataProvider {     public function getData()     {         return [['foo'=&gt;'baz']];     } } </code></pre> <p>乍一看，UI Component 系统似乎是一个面向对象的领域专用语言（domain specific language），用来创建用户界面的组件，可能已经朝着这个目的去做了，但是，深入了解后发现，他还没有完成，里面有各种边缘清空，bugs, 奇怪的遗漏。</p> <h2 id="后续步骤"><a href="#后续步骤" name="后续步骤"></a>后续步骤</h2> <p>简而言之, 这是 UI Component system 的 PHP 部分。在一天结束时, 所有这些复杂性可以归结为渲染一个 xhtml 模板并将其绑定到数据源上。</p> <p>在我们的后续文章中，我们将更深入地了解 Magento 的 js 系统（RequireJS 和 knockout.js）是如何与 UI component 系统交互的。这些交互正是 Magento 的 grid listings 和后端 forms 渲染的主要工作，理解这些系统对于自定义后端 UI 是至关重要的。</p> <p><audio style="display: none;" controls="controls"></audio></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_2_simplest_ui_knockout_component/]]></link>
		<title><![CDATA[Magento 2: Simplest UI Knockout Component]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>在上篇文章中，我们通过 <code>&lt;preference&gt;</code> 的方式创建了一个最简单的 Magento 2 UI Component。如果你阅读完了整篇内容，我打赌你会对没有介绍 javascript 感到失望。今天我们将弥补上次的缺憾。</p> <p>像之前一样，确保系统运行在 developer 模式，还有我们是在 Magento 2.1.1 上做的实验，不过其中涉及到的概念是所有版本都通用的。强烈建议在阅读本文前先阅读<a href="https://www.hellomagento2.com/alan_magento_simplest_ui_component/">上篇文章</a>，不过如果你想直接开动的话，我们在 GitHub 上放了<a href="https://github.com/astorm/magento2-simple-ui-component/">上篇的源代码</a>。</p> <h2 id="an-app-for-knockout.js-view-models"><a href="#an-app-for-knockout.js-view-models" name="an-app-for-knockout.js-view-models"></a>An App for Knockout.js View Models</h2> <p>Alan 的 <a href="https://alanstorm.com/category/magento-2/#magento_2_mvc">Magento 2 for PHP MVC Developers</a>系列文章的第二篇 Magento 2: Serving Frontend Files 讲解了 Magento 2 中是如何使用前端文件的。在 <a href="https://alanstorm.com/category/magento-2/#magento2_advanced_javascript">Magento 2: Advanced Javascript</a>系列中讲到了 <code>x-magento-init</code> 和 Magento 2 中 Knockoug.js 实现的基础知识。2016 年 7 月份我们提到了 Magento 2 的 Knockout.js 的 template 中一些奇怪的标签（<a href="https://alanstorm.com/magentos-knockoutjs-templates-arent-knockoutjs/">Magento’s KnockoutJS Templates aren’t KnockoutJS Templates</a>）。如果你没有阅读过前面的系列文章，那么光看刚刚的这篇，你也能获益颇多。不过如果你理不清的话，这些文章可能会给你帮助。</p> <p>在上篇文章结束后，我们有了一个 <code>Pulsestorm_SimpleUiComponent</code>模块。查看源代码，看到的类似下面这样：</p> <pre><code>&lt;script type="text/x-magento-init"&gt; {     "*":     {         "Magento_Ui/js/core/app":         {             "types":             {                 "dataSource": [],                 "pulsestorm_simple":                 {                     "extends": "pulsestorm_simple"                 },                 "html_content":                 {                     "component": "Magento_Ui\/js\/form\/components\/html",                     "extends": "pulsestorm_simple"                 }             },             "components":             {                 "pulsestorm_simple":                 {                     "children":                     {                         "pulsestorm_simple":                         {                             "type": "pulsestorm_simple",                             "name": "pulsestorm_simple"                         },                         "pulsestorm_simple_data_source":                         {                             "type": "dataSource",                             "name": "pulsestorm_simple_data_source",                             "dataScope": "pulsestorm_simple",                             "config":                             {                                 "data": [                                 {                                     "foo": "baz"                                 }],                                 "params":                                 {                                     "namespace": "pulsestorm_simple"                                 }                             }                         }                     }                 }             }         }     } } &lt;/script&gt; </code></pre> <p><code>x-magento-init</code> 将会把这个 JSON 对象传递给 <code>Magento_Ui/js/core/app</code> 模块。我们来看看这个模块的源代码。（<a href="https://www.hellomagento2.com/alan-magento-2-and-requirejs/">Magento 2 and RequireJS (翻译)</a>）</p> <pre><code>/**  * Copyright © Magento, Inc. All rights reserved.  * See COPYING.txt for license details.  */ define([     './renderer/types',     './renderer/layout',     '../lib/knockout/bootstrap' ], function (types, layout) {     'use strict';      return function (data, merge) {         types.set(data.types);         layout(data.components, undefined, true, merge);     }; }); </code></pre> <p>这个看似简单的程序实际上是 Magento 的 UI 组件系统中最重要的 javascript 文件之一。这里的代码（准确地说是 <code>Magento_Ui/js/core/renderer/types</code> 和 <code>Magento_Ui/js/core/renderer/layout</code> 模块中的代码）负责创建和注册所有的 Knockout.js 的 view model 构造函数。</p> <p><code>view model</code> 的概念如果不是很熟悉的话，可以参考 <a href="http://knockoutjs.com/">Knockout.js 的官方 tutorials</a> 以及 Alan 的 <a href="https://alanstorm.com/category/magento-2/#magento2_advanced_javascript">Magento 2: Advanced Javascript</a></p> <p><code>view model</code> 构造函数的注册是我们不太熟悉的概念。本篇文章中，我们不会完整地介绍这个概念，我们现在只要知道 <code>Magento_Ui/js/core/app</code> 运行后，Magento 将向全局注册表（global registry）中加入许多 view model 的构造对象。</p> <p>要理解这点，最快的办法是找个 grid 页面我们来看下 registry 是个啥。<code>Products &gt; Catalog</code> 到产品列表页，然后打开 debug 工具（chrome 中在 <code>View -&gt; Developer -&gt; Javascript Console</code>）</p> <h2 id="the-uiregistry"><a href="#the-uiregistry" name="the-uiregistry"></a>The uiRegistry</h2> <p>Magento 将所有的 Knockout.js 的 view model constructor 注册到 <code>uiRegistry</code> 模块返回的对象中。我对 javascript 的AMD 规范没有深入了解，所以我不确定这种注册到全局的做法是不是最佳实践，不过既然 Magento 这么做了，那么我们最好接受这点，然后继续我们的教程。</p> <p>在 RequireJS map 中，<code>uiRegistry</code> 是一个 key</p> <pre><code>// File: vendor/magento/module-ui/view/base/requirejs-config.js var config = {     paths: {         'ui/template': 'Magento_Ui/templates'     },     map: {         '*': {             uiElement:      'Magento_Ui/js/lib/core/element/element',             uiCollection:   'Magento_Ui/js/lib/core/collection',             uiComponent:    'Magento_Ui/js/lib/core/collection',             uiClass:        'Magento_Ui/js/lib/core/class',             uiEvents:       'Magento_Ui/js/lib/core/events',             uiRegistry:     'Magento_Ui/js/lib/registry/registry',             uiLayout:       'Magento_Ui/js/core/renderer/layout',             buttonAdapter:  'Magento_Ui/js/form/button-adapter'         }     } }; </code></pre> <p><code>uiRegistry</code> 对应的模块是 <code>Magento_Ui/js/lib/registry/registry</code>，实际位置在 <code>vendor/magento/module-ui/view/base/web/js/lib/registry/registry.js</code> 。这个 registry 对象类似于字典或 hash map。你可以通过 registry 的 set 方法设置一个值，使用 get 方法去取得值。让我们来实验下。在浏览器的 debugger 中加载 <code>uiRegistry</code> 模块。</p> <pre><code>&gt; reg = requirejs('uiRegistry'); Registry {} </code></pre> <p>在 debugger 中看不到 uiRegistry 中的属性值。Magento 核心团队让它的属性是司有的。只能通过 <code>get</code> 方法来取得已注册的值。让我们来实验下：</p> <pre><code>&gt; reg.get('product_listing.product_listing'); UiClass {_super: undefined, ignoreTmpls: Object, _requesetd: Object,     containers: Array[0], exports: Object…} </code></pre> <p>这里我们取得了一个名为 <code>product_listing.product_listing</code> 的 Knockout.js view model 。</p> <p><code>uiRegistry</code> 和普通的字典或 hash map 不同的地方在于 <code>get</code> 方法是支持查询语法的。你可以在他的定义文件 <code>vendor/magento/module-ui/view/base/web/js/lib/registry/registry.js</code> 中看到该查询语言的简要说明。我们将跳过这里，你只要知道他支持回调，这样我们可以取得 registry 中的所有对象。下面试一下：</p> <pre><code>&gt; reg.get(function(item){     console.log(item.name);     console.log(item); }); //long list of view model constructor and names snipped </code></pre> <p>回调查询让我们可以变相地查看司有属性，一窥注册地所有 view models</p> <h2 id="configuring-a-view-model-constructor"><a href="#configuring-a-view-model-constructor" name="configuring-a-view-model-constructor"></a>Configuring a View Model Constructor</h2> <p>产品列表页包含了大量地 view models ，不过我们还是回到较简单的 model 中吧。进入 <code>System -&gt; Other Settings -&gt; Hello Simple UI Component</code> 然后再次尝试下面的：</p> <pre><code>&gt; reg = requirejs('uiRegistry'); reg.get(function(item){     console.log(item.name);     console.log(item); }); undefined </code></pre> <p>我们啥也没拿到。UI Component system 并没有自动地创建 view models 。我们需要通过一个 RequireJS module 来配置我们的 UI component ，让该 RequireJS module 返回一个 view model constructor 。</p> <p>首先，我们在 <code>definition.xml</code> 中加入配置节点</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;!-- ... --&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/pulsestorm_simple&gt; &lt;/components&gt; </code></pre> <p>清空缓存后重新载入页面，然后我们查看源代码，会看到下面这样的 JSON</p> <pre><code>"components": {     "pulsestorm_simple": {         "children": {             "pulsestorm_simple": {                 "type": "pulsestorm_simple",                 "name": "pulsestorm_simple",                 "config": {                     "component": "Pulsestorm_SimpleUiComponent\/js\/pulsestorm_simple_component"                 }             }, //... </code></pre> <p>下面我们创建下面的文件，清空缓存后刷新页面。</p> <pre><code>//File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/web/js/pulsestorm_simple_component.js define([], function(){     console.log("Called"); }); </code></pre> <p>然后我们会在 console 中看到如下错误：</p> <pre><code>Called Uncaught TypeError: Constr is not a constructor </code></pre> <p>有进展哦。<code>Called</code> 表明我们的模块被加载了。但是我们的模块没有返回一个 view model constructor 。下面我们来修复他。</p> <pre><code>//File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/web/js/pulsestorm_simple_component.js define(['uiElement'], function(Element){     viewModelConstructor = Element.extend({         defaults: {             template: 'Pulsestorm_SimpleUiComponent/pulsestorm_simple_template'         }     });      return viewModelConstructor; }); </code></pre> <p>这里我们导入 <code>uiElement</code> 模块，用它的 <code>extend</code> 方法创建一个新的对象，这个对象就是我们的 view model constructor ，然后我们返回这个对象。</p> <p><code>uiElement</code> 模块（<code>Magento_Ui/js/lib/core/element/element</code>）是为 UI Component 系统建造的自定义类的一部分。本文不能展开来讲了，不过他是基于 underscore JS 的，如果你好奇的话，可以看这里 <a href="https://alanstorm.com/magento-2s-base-javascript-class/">Magento 2’s Base Javascript Class</a></p> <p>上面 <code>defaults</code> 对象的 <code>template</code> 属性定义了我们的 view model 要用的 remote template （<a href="https://www.hellomagento2.com/alan_magento_2_knockoutjs_integration/">Magento 2: KnockoutJS Integration</a>）</p> <h2 id="hooking-up-the-view-model"><a href="#hooking-up-the-view-model" name="hooking-up-the-view-model"></a>Hooking up the View Model</h2> <p>下面咱们清空缓存刷新页面后，在浏览器 debugger 中输入下面的代码：</p> <pre><code>reg = requirejs('uiRegistry'); //hold your questions on pulsestorm_simple.pulsestorm_simple //we'll get there in a second viewModelConstructor = reg.get('pulsestorm_simple.pulsestorm_simple') </code></pre> <p>然后我们会看到一条返回的 veiw model</p> <pre><code>UiClass {_super: undefined, ignoreTmpls: Object, _requesetd: Object, containers: Array[0], exports: Object…} </code></pre> <p>下一步我们将把这个 view model 和我们的 HTML 页面的 DOM 节点联系起来。这里 Magento 自定义的 Knockout.js <code>scope</code> 绑定就要隆重登场了。修改你的 UI Component 的 XHTML 模板像下面这样：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/templates/different.xhtml --&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div&gt;     &lt;h1&gt;Hello Brave New World&lt;/h1&gt;     &lt;div data-bind="scope: 'pulsestorm_simple.pulsestorm_simple'" class="entry-edit form-inline"&gt;         &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt;     &lt;/div&gt; &lt;/div&gt; </code></pre> <p>这里我们做了两件事情。第一件，我们加了 <code>data-bind="scope: 'pulsestorm_simple.pulsestorm_simple'"</code> 这个属性，这个属性会调用 Magento Knockout.js <code>scope</code> 绑定。<code>scope</code> 绑定需要一个参数 （<code>pulsestorm_simple.pulsestorm_simple</code>）。Magento 会用这个参数去查找 uiRegistry 中的 view model ，然后使得这个 view model 成为所有内部节点的当前 Knockout.js veiw model。<code>scope</code> 数据绑定允许你在同一个页面的不同部分使用不同的 Knockout.js view model</p> <p>第二件事情是我们放了一个类似于 Knockout.js 绑定标签的东东：<code>&lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt;</code>这个东东将加载当前 view model 的 template 。<code>getTemplate</code> 方法来自于我们继承的类 <code>uiElement</code></p> <p>下面清空缓存并刷新页面，我们将看到下面的错误：</p> <pre><code>Unable to resolve the source file for ‘adminhtml/Magento/backend/enUS/PulsestormSimpleUiComponent/template/pulsestormsimpletemplate.html’ #0 /path/to/magento/vendor/magento/framework/App/StaticResource.php(97): Magento\Framework\View\Asset\File-&gt;getSourceFile() #1 /path/to/magento/vendor/magento/framework/App/Bootstrap.php(258): Magento\Framework\App\StaticResource-&gt;launch() #2 /path/to/magento/pub/static.php(13): Magento\Framework\App\Bootstrap-&gt;run(Object(Magento\Framework\App\StaticResource)) #3 {main} </code></pre> <p>因为我们刚刚配置了 template 但却没有创建他呀。下面咱们创建一下。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/web/template/pulsestorm_simple_template.html --&gt; &lt;h1&gt;Rendered with Knockout.js&lt;/h1&gt; </code></pre> <p>然后清空缓存刷新页面，你应该看到下面这样的：</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-1.png" alt="" /></p> <p>恭喜你，你刚刚创建了一个基于 Knockout.js 的 Magento UI Component.</p> <h2 id="using-knockout"><a href="#using-knockout" name="using-knockout"></a>Using Knockout</h2> <p>当然了，花这么大力气就为了加载一个静态 HTML 也太小题大做了。要充分利用 Knockout.js 的优势，你需要在 RequireJS 模块中导入它。</p> <p>举例说来，</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/web/template/pulsestorm_simple_template.html --&gt; &lt;h1&gt;Rendered with Knockout.js&lt;/h1&gt; &lt;strong data-bind="text: message"&gt;&lt;/strong&gt; </code></pre> <pre><code>//File: vendor/magento//module-ui/view/base/web/js/core/app.js define(['uiElement','ko'], function(Element, ko){     viewModelConstructor = Element.extend({         defaults: {             template: 'Pulsestorm_SimpleUiComponent/pulsestorm_simple_template'         },         message: ko.observable("Hello Knockout.js!")     });      return viewModelConstructor; }); </code></pre> <p>这里，我们导入了 <code>ko</code> 模块。这个 <code>ko</code> 模块就相当于 Knockout.js 提供的全局 <code>ko</code> （<a href="https://www.hellomagento2.com/alan_magento_2_knockoutjs_integration/">Magento 2 KnockoutJS 集成</a>）。我们还加了一个 <code>message</code> 属性，把这个属性设成 <code>ko.observable</code> 对象。这个就是 Knockout.js 的用法。然后刷新页面，你应该看到：</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-2.png" alt="" /></p> <p>下面在浏览器 debugger 中，输入下面的代码</p> <pre><code>&gt; reg = requirejs('uiRegistry'); &gt; reg.get('pulsestorm_simple.pulsestorm_simple').message("Change Me"); </code></pre> <p>然后立刻，我们的页面变成下面这样了：</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-3.png" alt="" /></p> <h2 id="modern-javascript-and-the-browser-debugger"><a href="#modern-javascript-and-the-browser-debugger" name="modern-javascript-and-the-browser-debugger"></a>Modern Javascript and the Browser Debugger</h2> <p>Magento 2 javascript（以及许多其他现代 javascript）调试的挑战之一就是跟踪哪些加载了哪些没有。再也不像以前那样，查看源代码查找 <code>&lt;script&gt;</code> 标签。</p> <p>Google Chrome 的 debugger ，如果你要查找 RequireJS 的模块。那么可以去 <code>Source</code> tab</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-4.png" alt="" /></p> <p>如果你要看 Knockout.js 的 remote template ，<code>Network -&gt; XHR</code> 正是你要找的。</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-5.png" alt="" /></p> <p>需要特别注意浏览器中使用的文件是不是最新的。Magento 有自己的缓存机制，还有 Magento 对前端文件设置了一些强势的 header （<a href="https://alanstorm.com/magento-2-frontend-files-serving/">Magento 2: Serving Frontend Files</a>）所以除了清空 Magento 缓存，有时候也有必要清理浏览器的缓存。</p> <h2 id="why-the-double-name"><a href="#why-the-double-name" name="why-the-double-name"></a>Why the Double Name</h2> <p>view model constructor 重复的名称可能会让你觉得困惑。</p> <pre><code>product_listing.product_listing pulsestorm_simple.pulsestorm_simple </code></pre> <p>名称来自于 <code>/ui_component/*.xml</code> 文件名</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;uiComponent name="pulsestorm_simple"/&gt; </code></pre> <p>但是，通过上面的例子，我们依然不清楚为什么要用两次名称，这种格式意味着某种层次。这正是 UI Component 系统的特性，通过他我们将理解 Magento 自带的 listing 和 form components 是怎么回事。</p> <p>首先，回到 <code>definition.xml</code> 文件，修改成下面这样：</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;!-- &lt;item name="component" xsi:type="string"&gt;Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component&lt;/item&gt; --&gt;                 &lt;item name="component" xsi:type="string"&gt;uiComponent&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/pulsestorm_simple&gt; &lt;/components&gt; </code></pre> <p>这里我们将 <code>Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component</code> 替换成了 <code>uiComponent</code> ，这个模块就是 <code>Magento_Ui/js/lib/core/collection</code></p> <p>下面我们清除缓存刷新页面，这次我们的模板不会被加载咯。这说明，不同的 view model 不同的模板。</p> <p>下面在浏览器 debugger 中输入下面的代码：</p> <pre><code>&gt; reg = requirejs('uiRegistry'); &gt; viewModelConstructor = reg.get('pulsestorm_simple.pulsestorm_simple') &gt; viewModelConstructor.getTemplate() ui/collection </code></pre> <p>这个 <code>ui/collection</code> 对应的就是下面这个文件：</p> <pre><code>&lt;!-- File: vendor/magento//module-ui/view/base/web/templates/collection.html --&gt; &lt;!-- /**  * Copyright © 2016 Magento. All rights reserved.  * See COPYING.txt for license details.  */ --&gt; &lt;each args="data: elems, as: 'element'"&gt;     &lt;render if="hasTemplate()"/&gt; &lt;/each&gt; </code></pre> <p>如果你对 Magento 2 的前端代码不熟悉，那么肯定会对这些标签感到困惑。这些标签是 Magento 2 扩展了 Knockout.js rendering engine 后的结果（<a href="https://alanstorm.com/magentos-knockoutjs-templates-arent-knockoutjs/">Magento’s KnockoutJS Templates aren’t KnockoutJS Templates</a>）。用 Knockout.js 的写法，就是下面这样：</p> <pre><code>&lt;!-- ko foreach: {data: elems, as: 'element'} --&gt;     &lt;!-- ko if: hasTemplate() --&gt;&lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt;&lt;!-- /ko --&gt; &lt;!-- /ko --&gt; </code></pre> <p>然后在浏览器中输入下面的代码，我们看看 <code>elems</code> 是什么</p> <pre><code>&gt; reg = requirejs('uiRegistry'); &gt; viewModelConstructor = reg.get('pulsestorm_simple.pulsestorm_simple') &gt; viewModelConstructor.elems() [] </code></pre> <p>是个空数组。那么我们怎么往里面加东西呢？通过 UI Component 配置。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;pulsestorm_simple xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;     &lt;!--  ... --&gt;     &lt;htmlContent name="first_ever_child"&gt;         &lt;argument name="block" xsi:type="object"&gt;Magento\Framework\View\Element\Text&lt;/argument&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/htmlContent&gt; &lt;/pulsestorm_simple&gt; </code></pre> <p>这里我们给 <code>pulsestorm_simple.xml</code> 加了一个 <code>&lt;htmlContent/&gt;</code> 子节点。这个 <code>&lt;htmlContent/&gt;</code> 是 Magento 提供的，不过这不重要，重要的是我们给这个节点配置了 <code>Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component</code> 组件。</p> <p>清空缓存然后刷新页面，你又看到 <code>Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component</code> 组件加载的模板了。</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-2.png" alt="" /></p> <p>有意思的是 <code>uiRegistry</code></p> <pre><code>&gt; reg = requirejs('uiRegistry'); &gt; reg.get(function(item){     console.log(item.name); }) undefined pulsestorm_simple.pulsestorm_simple pulsestorm_simple.pulsestorm_simple.first_ever_child undefined </code></pre> <p>这里我们看到了组件定义的层次结构。下面我们再到 UI Component XML 中加上另一个节点。</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/pulsestorm_simple.xml --&gt; &lt;pulsestorm_simple xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;     &lt;!--  ... --&gt;     &lt;htmlContent name="first_ever_child"&gt;         &lt;argument name="block" xsi:type="object"&gt;Magento\Framework\View\Element\Text&lt;/argument&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/htmlContent&gt;      &lt;htmlContent name="second_ever_child"&gt;         &lt;argument name="block" xsi:type="object"&gt;Magento\Framework\View\Element\Text&lt;/argument&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Pulsestorm_SimpleUiComponent/js/pulsestorm_simple_component&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/htmlContent&gt; &lt;/pulsestorm_simple&gt; </code></pre> <p>然后清空缓存刷新页面，我们会看到那个模板被加载了两次。</p> <p><img src="/wp-content/uploads/2018/05/simple-ui-ko-component-6.png" alt="" /></p> <p>然后咱们到浏览器 debugger 中看下：</p> <pre><code>&gt; reg = requirejs('uiRegistry'); &gt; reg.get(function(item){     console.log(item.name); }) pulsestorm_simple.pulsestorm_simple pulsestorm_simple.pulsestorm_simple.first_ever_child pulsestorm_simple.pulsestorm_simple.second_ever_child </code></pre> <p>你有很多方法可以用 UI Component system 去完成前端代码，不过最终 Magento 2 中的主要用法就是这样的。<code>uiComponent/Magento_Ui/js/lib/core/collection</code> 模块 <strong>collects and renders a series of Knockout.js view models</strong></p> <p>顶层的 UI Component 负责加载 XHTML 模板，但是如果他的 configuration 中设置了 <code>uiComponent</code> 的属性，并且他的 XHTML 中通过 <code>scope</code> 绑定调用该模块，那么他的子节点会被命名成这种树形的结构。</p> <p>这一点有点难理解，的 configuration 中设置了 <code>uiComponent</code> 的属性，指的是：</p> <pre><code>#File: app/code/Pulsestorm/SimpleUiComponent/view/base/ui_component/etc/definition.xml &lt;components xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_definition.xsd"&gt;     &lt;pulsestorm_simple class="Pulsestorm\SimpleUiComponent\Component\Simple"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;!-- uiComponent 属性 --&gt;                 &lt;item name="component" xsi:type="string"&gt;uiComponent&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/pulsestorm_simple&gt; &lt;/components&gt; </code></pre> <p>XHTML 中通过 <code>scope</code> 绑定调用该模块,指的是：</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleUiComponent/view/adminhtml/ui_component/templates/different.xhtml --&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;div&gt;     &lt;h1&gt;Hello Brave New World&lt;/h1&gt;     &lt;div data-bind="scope: 'pulsestorm_simple.pulsestorm_simple'" class="entry-edit form-inline"&gt;         &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt;     &lt;/div&gt; &lt;/div&gt; </code></pre> <p>子节点会被命名成树形结构，指的是：</p> <pre><code>pulsestorm_simple.pulsestorm_simple pulsestorm_simple.pulsestorm_simple.first_ever_child pulsestorm_simple.pulsestorm_simple.second_ever_child </code></pre> <p>让人困惑的是，根节点也被注册成一个 view model constructor 了，这就是 <code>pulsestorm_simple.pulsestorm_simple</code> 的由来。</p> <h2 id="总结"><a href="#总结" name="总结"></a>总结</h2> <p>经过这么一番捣鼓，你现在应该更深入了解 Magento 2 的神秘新系统 UI Component 了。不过，还有很多等着我们去探索。再下一篇文章中，我们将更深入地挖掘一下，看看 UI Components 怎么获得 <code>&lt;dataProvider&gt;</code> 中地数据，然后修订我们这次地模块，看看能不能不用 <code>&lt;preference/&gt;</code> 使用这个系统。</p> <p><audio style="display: none;" controls="controls"></audio></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_2_simplest_xsd_valid_ui_component/]]></link>
		<title><![CDATA[Magento 2: Simplest XSD Valid UI Component]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><a href="https://alanstorm.com/magento_2_simplest_xsd_valid_ui_component/">原文地址</a></p> <p>上期的两篇文章中，我们从头创建了一个新的 UI Component 模块。虽然我们成功了，但是是以 <code>&lt;preference&gt;</code> 重写的方式做到的，这种方式禁用了 Magento 2 的 XSD 验证的，作为学习练习还好，但不能用在生产环境中。</p> <p>使用 <code>&lt;preference&gt;</code> 的方式禁用 XSD 验证是以牺牲系统的稳定性为代价的。这次我们不会再禁用 XSD 的验证，用可以在生产环境中使用的方式来创建 UI Component</p> <h2 id="前提"><a href="#前提" name="前提"></a>前提</h2> <p>如果上次你已经使用了 <code>Pulsestorm_SimpleUiComponent</code> 那么现在请禁用该模块。</p> <pre><code>$ php bin/magento module:disable Pulsestorm_SimpleUiComponent The following modules have been disabled: - Pulsestorm_SimpleUiComponent  Cache cleared successfully. Generated classes cleared successfully. Please run the 'setup:di:compile' command to generate classes. Info: Some modules might require static view files to be cleared. To do this, run 'module:disable' with the --clear-static-content option to clear them. </code></pre> <p>下面我们使用 <a href="https://github.com/astorm/pestle">pestle</a> 创建一个 Admin 模块</p> <pre><code>php pestle.phar generate_module Pulsestorm SimpleValidUiComponent 0.0.1  php pestle.phar generate_acl Pulsestorm_SimpleValidUiComponent Pulsestorm_SimpleValidUiComponent::top,Pulsestorm_SimpleValidUiComponent::menu_1  php pestle.phar generate_menu Pulsestorm_SimpleValidUiComponent Magento_Backend::system_other_settings Pulsestorm_SimpleValidUiComponent::a_menu_item Pulsestorm_SimpleValidUiComponent::menu_1 "Hello Simple Valid Ui Component" pulsestorm_simplevaliduicomponent/index/index 1  php pestle.phar generate_route Pulsestorm_SimpleValidUiComponent adminhtml pulsestorm_simplevaliduicomponent  php pestle.phar generate_view Pulsestorm_SimpleValidUiComponent adminhtml pulsestorm_simplevaliduicomponent_index_index Main content.phtml 1column  php bin/magento module:enable Pulsestorm_SimpleValidUiComponent  php bin/magento setup:upgrade </code></pre> <p>这样，我们登陆管理后台，进入 <code>System -&gt; Other Settings -&gt; Hello Simple Valid Ui Component</code></p> <p>OK ，我们的模板已经生成了，下面开始进入正题。</p> <h2 id="a-new-ui-component"><a href="#a-new-ui-component" name="a-new-ui-component"></a>A New UI Component</h2> <p>我们在 layout handle XML 文件中加入新的 <code>&lt;uiComponent&gt;</code> 节点。</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/layout/pulsestorm_simplevaliduicomponent_index_index.xml &lt;?xml version="1.0"?&gt; &lt;page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;referenceBlock name="content"&gt;         &lt;block template="content.phtml" class="Pulsestorm\SimpleValidUiComponent\Block\Adminhtml\Main" name="pulsestorm_simplevaliduicomponent_block_main" /&gt;          &lt;uiComponent name="pulsestorm_simple_valid"/&gt;      &lt;/referenceBlock&gt; &lt;/page&gt; </code></pre> <p>然后我们创建这个名为 <code>pulsestorm_simple_valid</code> 的 UI Component 的 XML 文件。</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/pulsestorm_simple_valid.xml &lt;pulsestorm_simple_valid xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt; &lt;/pulsestorm_simple_valid&gt; </code></pre> <p>清空缓存刷新页面，我们会看到如下错误：</p> <pre><code>Exception #0 (Magento\Framework\Exception\LocalizedException): Element 'pulsestorm_simple_valid': No matching global declaration available for thevalidation root. </code></pre> <p>就像我们之前的文章中说的那样，这个错误是因为 <code>vendor/magento/module-ui/view/base/ui_component/etc/definition.xml</code> 中没有定义 <code>pulsestorm_simple_valid</code> ，而且我们没有办法增加这个节点进去，因为 Magento 的 XSD 验证不能通过名为 <code>&lt;pulsestorm_simple_valid/&gt;</code> 的 root 节点。</p> <p>在 2.1 版本的 Magento 中，我们是没有好办法不动系统方法去做到的增加 root 节点的，但是我们可以变通一下。</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/pulsestorm_simple_valid.xml &lt;container xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt; &lt;/container&gt; </code></pre> <p><code>&lt;container&gt;</code> 节点是一个有效的 root 节点，清空缓存刷新页面，我们这次会看到如下错误：</p> <pre><code>Fatal error: Method Magento\Ui\TemplateEngine\Xhtml\Result::__toString() must not throw an exception, caught Error: Call to a member function getConfigData() on null in /path/to/magento/vendor/magento/module-ui/ Component/Wrapper/UiComponent.php on line 0 </code></pre> <p>换句话说，schema validation 错误已经没有了，这次只是因为缺少 <code>dataSource</code> 节点</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/pulsestorm_simple_valid.xml &lt;container xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;     &lt;dataSource name="pulsestorm_simple_valid_data_source"&gt;         &lt;argument name="dataProvider" xsi:type="configurableObject"&gt;             &lt;!-- the PHP class that implements a data provider --&gt;             &lt;argument name="class" xsi:type="string"&gt;Pulsestorm\SimpleValidUiComponent\Model\DataProvider&lt;/argument&gt;              &lt;!-- redundant with the `dataSource` name --&gt;             &lt;argument name="name" xsi:type="string"&gt;pulsestorm_simple_valid_data_source&lt;/argument&gt;              &lt;!-- required: means ui components are meant to work with models --&gt;             &lt;argument name="primaryFieldName" xsi:type="string"&gt;entity_id&lt;/argument&gt;              &lt;!-- required: means ui components are meant to work with URL passing --&gt;             &lt;argument name="requestFieldName" xsi:type="string"&gt;id&lt;/argument&gt;         &lt;/argument&gt;     &lt;/dataSource&gt; &lt;/container&gt; </code></pre> <p>data provider class</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/Model/DataProvider.php &lt;?php namespace Pulsestorm\SimpleValidUiComponent\Model; class DataProvider extends \Magento\Ui\DataProvider\AbstractDataProvider { } </code></pre> <p>刷新页面，这次我们应该没有错误，加载了页面了。</p> <h2 id="what-did-we-render?"><a href="#what-did-we-render?" name="what-did-we-render?"></a>What Did We Render?</h2> <p>如果我们查看源代码的话，不是通过 DOM Inspector ，我们会看到下面的加载内容：</p> <pre><code>&lt;div&gt;     &lt;div data-bind="scope: 'pulsestorm_simple_valid.areas'" class="entry-edit form-inline"&gt;         &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt;     &lt;/div&gt;     &lt;script type="text/x-magento-init"&gt;     {         "*": {             "Magento_Ui/js/core/app": {                 "types": {                     "dataSource": [],                     "container": {                         "extends": "pulsestorm_simple_valid"                     },                     "html_content": {                         "component": "Magento_Ui\/js\/form\/components\/html",                         "extends": "pulsestorm_simple_valid"                     }                 },                 "components": {                     "pulsestorm_simple_valid": {                         "children": {                             "pulsestorm_simple_valid": {                                 "type": "pulsestorm_simple_valid",                                 "name": "pulsestorm_simple_valid",                                 "config": {                                     "component": "uiComponent"                                 }                             },                             "pulsestorm_simple_valid_data_source": {                                 "type": "dataSource",                                 "name": "pulsestorm_simple_valid_data_source",                                 "dataScope": "pulsestorm_simple_valid",                                 "config": {                                     "params": {                                         "namespace": "pulsestorm_simple_valid"                                     }                                 }                             }                         }                     }                 }             }         }     }     &lt;/script&gt; &lt;/div&gt; </code></pre> <p>我们看下 <code>&lt;container&gt;</code> 在 <code>definition.xml</code> 配置中的定义：</p> <pre><code>&lt;!-- File: vendor/magento//module-ui/view/base/ui_component/etc/definition.xml --&gt;  &lt;!-- ... --&gt; &lt;container class="Magento\Ui\Component\Container"&gt;     &lt;argument name="data" xsi:type="array"&gt;         &lt;item name="config" xsi:type="array"&gt;             &lt;item name="component" xsi:type="string"&gt;uiComponent&lt;/item&gt;         &lt;/item&gt;         &lt;item name="template" xsi:type="string"&gt;templates/container/default&lt;/item&gt;     &lt;/argument&gt; &lt;/container&gt; &lt;!-- ... --&gt; </code></pre> <p>他的 XHTML template 是 <code>templates/container/default</code> ，他的 component 是 <code>uiComponent</code> (<code>Magento_Ui/js/lib/core/collection</code>)</p> <p>我们选择用 <code>container</code> component 的原因有两点：第一，他是少数几个能用的不会有 XSD 验证错误的 root 节点。第二，<code>uiComponent</code> 正是我们需要的组件。上次（<a href="https://www.hellomagento2.com/alan_magento_2_simplest_ui_knockout_component/#why-the-double-name">Magento 2: Simplest UI Knockout Component</a>）我们讲到 <code>ui/collection</code> 模块会遍历子元素，并加载子元素的模板，类似于 layout update XML 的 <code>&lt;container&gt;</code> 节点，或者 Magento 1 中的 <code>core/text_list</code> block</p> <p>但是 <code>templates/container/default</code> XHTML 模板并不是我们需要的：</p> <pre><code>#File: vendor/magento/module-ui/view/base/ui_component/templates/container/default.xhtml &lt;div xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../Ui/etc/ui_template.xsd"&gt;     &lt;div data-bind="scope: '{{getName()}}.areas'" class="entry-edit form-inline"&gt;         &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt;     &lt;/div&gt; &lt;/div&gt; </code></pre> <p>这个模板是干吗用的目前还不是很清楚。Magento 的 <code>ui_component</code> files 只用 <code>&lt;container&gt;</code> 作为子节点，就是说它的 XHTML template 从来没有被加载过。很有可能是早期 Magento 使用 <code>&lt;container&gt;</code> 作为 root 根节点的遗留产物，也可能是某种为将来做的准备。管他原因是什么，这就是为什么我们可以用 <code>&lt;container&gt;</code> 作为 root 节点。很难说这个“功能”以后还会不会存在，但目前这是最好的方式了。</p> <h2 id="changing-the-template"><a href="#changing-the-template" name="changing-the-template"></a>Changing the Template</h2> <p>XHTML 模板不是我们想要的，那么我们是不是就卡住了呢？当然不是了，我们可以在 <code>ulsestorm_simple_valid.xml</code> 文件中配置一个新的模板。</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/pulsestorm_simple_valid.xml &lt;container xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;     &lt;argument name="data" xsi:type="array"&gt;         &lt;item name="template" xsi:type="string"&gt;templates/pulsestorm_simple_valid/default&lt;/item&gt;     &lt;/argument&gt;     &lt;!-- ... --&gt;  &lt;/container&gt; </code></pre> <p>记住，<code>definition.xml</code> 文件中设置的是默认值，<code>ui_component</code> 文件夹中的文件可以覆盖默认值。</p> <p>然后我们还要创建 <code>xhtml</code> template</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/templates/pulsestorm_simple_valid/default.xhtml &lt;div data-bind="scope: '{{getName()}}.{{getName()}}'"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xsi:noNamespaceSchemaLocation="../../../../../../Ui/etc/ui_template.xsd"&gt;      &lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt; &lt;/div&gt; </code></pre> <p>上面的代码基本上参照的是 listing grid (vendor/magento/module-ui/view/base/ui_component/templates/listing/default.xhtml) 的默认 XHTML 。它和我们上篇中用的模板一样，通过 <code>scope</code> 绑定将整个系统运行起来。</p> <p>这里有几点值得注意。</p> <p>首先，我们看到 Knockout tag-less 模板绑定：</p> <pre><code>&lt;!-- ko template: getTemplate() --&gt;&lt;!-- /ko --&gt; </code></pre> <p>我们已经知道了 Knockout 的 view model 是通过我们的 <code>scope</code> 绑定来实现的：</p> <pre><code>&lt;div data-bind="scope: '{{getName()}}.{{getName()}}'" ...&gt; </code></pre> <p>这里我们看到了一个不熟悉的地方。我么用了 <code>{{getName()}}.{{getName()}}</code> 来替代了硬编码的 scope 绑定。<code>{{...}}</code> 花括号中的内容是 XHTML template 语言的一部分，他将调用该 UI Component 对象的 <code>getName()</code> 方法。这里的 name 是我们用在 layout handle XML 文件中的 <code>&lt;uiComponent name="pulsestorm_simple_valid"/&gt;</code> 。就是说他等同于：</p> <pre><code>&lt;div data-bind="scope: 'pulsestorm_simple_valid.pulsestorm_simple_valid'" ...&gt; </code></pre> <p>下一处让人困惑的地方是：</p> <pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../Ui/etc/ui_template.xsd" </code></pre> <p>We have an XML namespace declaration in the root level</p> <div></div> <p>, as well as a schema validation file (xsi:noNamespaceSchemaLocation).记住，这是 XHTML 不是 HTML 模板。他们像 XML 文件那样，这意味着 XHTML 模板中只能由一个 top level node .</p> <p>虽然这些属性（namespace 等）不是严格要求的，但是 Magento 核心文件中都是有的，所以为了保持一致，我们最好也加上。</p> <p>如果你很好奇，为什么这些属性最终没有进入到 HTML 中去的话，这是因为在加载前 Magento 移除了他们：</p> <pre><code>#File: vendor/magento/module-ui/TemplateEngine/Xhtml/Result.php     public function __toString()     {         //...         foreach ($templateRootElement-&gt;attributes as $name =&gt; $attribute) {             if ('noNamespaceSchemaLocation' === $name) {                 $this-&gt;getDocumentElement()-&gt;removeAttributeNode($attribute);                 break;             }         }         $templateRootElement-&gt;removeAttributeNS('http://www.w3.org/2001/XMLSchema-instance', 'xsi');         //...     } </code></pre> <p>最后，<code>ui_template.xsd</code> 值得一看</p> <pre><code>#File: vendor/magento/module-ui/etc/ui_template.xsd &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified"&gt;     &lt;xs:element name="form"&gt;         &lt;xs:complexType &gt;             &lt;xs:sequence&gt;                 &lt;xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax" /&gt;             &lt;/xs:sequence&gt;         &lt;/xs:complexType&gt;     &lt;/xs:element&gt;     &lt;xs:element name="div" &gt;         &lt;xs:complexType &gt;             &lt;xs:sequence&gt;                 &lt;xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax" /&gt;             &lt;/xs:sequence&gt;             &lt;xs:anyAttribute processContents="lax" /&gt;         &lt;/xs:complexType&gt;     &lt;/xs:element&gt; &lt;/xs:schema&gt; </code></pre> <p>完整地讲 <code>xs:schema</code> 语言超出了本篇的范围，但是上面地代码表示 <code>xhtml</code> 文件必须有一个 root 节点，<code>div</code> 或是 <code>form</code> 。另外，我们地文件中不写 <code>si:noNamespaceSchemaLocation</code> 并不能跳过验证，因为这些 <code>.xhtml</code> 文件最终会被合并成 XML 树，带 schema 验证的。</p> <h2 id="adding-to-the-collection"><a href="#adding-to-the-collection" name="adding-to-the-collection"></a>Adding to the Collection</h2> <p>下面我们清空缓存刷新页面，我们什么变化也没有看到。但是，如果我们用 Chrome 的 debugger 工具查看 <code>Sources</code> tab ，我们会发现 Magento 已经加载了 <code>collection.js</code> (<code>Magento_Ui/js/lib/core/collectio</code>)</p> <p><img src="/wp-content/uploads/2018/06/debug-sources.png" alt="" /></p> <p>通过 XHR debugging 我们还会发现 magento 已经加载了 <code>collection.html</code> Knockout.js template</p> <p><img src="/wp-content/uploads/2018/06/debug-xhr.png" alt="" /></p> <p>我们切换到 console 中，我们会看到名为 <code>pulsestorm_simple_valid.pulsestorm_simple_valid</code> 的 view model constructor</p> <pre><code>&gt; reg = requirejs('uiRegistry'); &gt; reg.get(function(item){     console.log(item.name);     console.log(item); });  pulsestorm_simple_valid.pulsestorm_simple_valid UiClass {_super: undefined, ignoreTmpls: Object, _requesetd: Object, containers: Array[0], exports: Object…} </code></pre> <p>如果你不确定这里在做什么，请参考 <a href="https://www.hellomagento2.com/alan_magento_simplest_ui_component/">Magento 2: Simplest UI Component</a></p> <p>我们下一步要做的是加一些子组件。</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/pulsestorm_simple_valid.xml &lt;container&gt;     &lt;!-- ... --&gt;     &lt;htmlContent name="our_first_content"&gt;         &lt;argument name="block" xsi:type="object"&gt;Pulsestorm\SimpleValidUiComponent\Block\Example&lt;/argument&gt;     &lt;/htmlContent&gt;     &lt;!-- ... --&gt; &lt;/container&gt; </code></pre> <p>The <code>htmlContent</code> node allows you to render the contents of a Magento block object into our <code>x-magento-init</code> script, and then have those contents rendered onto the page via Knockout.js.上面的例子我们将 render 名为 <code>Pulsestorm\SimpleValidUiComponent\Block\Example</code> 的 block 。我们来看 <code>definition.xml</code> 中是怎么定义 <code>&lt;htmlContent/&gt;</code> 的。</p> <pre><code>&lt;htmlContent class="Magento\Ui\Component\HtmlContent"&gt;     &lt;argument name="data" xsi:type="array"&gt;         &lt;item name="config" xsi:type="array"&gt;             &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/form/components/html&lt;/item&gt;         &lt;/item&gt;     &lt;/argument&gt; &lt;/htmlContent&gt; </code></pre> <p>我们发现 rendering 是通过 <code>Magento_Ui/js/form/components/html</code> 模块进行的。完整地说，<code>Magento_Ui/js/form/components/html</code> 模块返回一个 Knockout.js view model constructor ，它有一个 Knockout.js “Magento remote” 模板 <code>ui/content/content</code></p> <pre><code>//File: vendor/magento/module-ui/view/base/web/js/form/components/html.js //... return Component.extend({     defaults: {         content:        '',         showSpinner:    false,         loading:        false,         visible:        true,         template:       'ui/content/content',         additionalClasses: {}     }, //... </code></pre> <p>render 的实现细节作为高级练习六个读者。</p> <p>下面我们清空缓存刷新页面，然后我们就会看到下面的错误：</p> <pre><code>Exception #0 (ReflectionException): Class Pulsestorm\SimpleValidUiComponent\Block\Example does not exist </code></pre> <p>哈，我们忘记创建这个对象了 <code>Pulsestorm\SimpleValidUiComponent\Block\Example</code></p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/Block/Example.php &lt;?php namespace Pulsestorm\SimpleValidUiComponent\Block;  use Magento\Framework\View\Element\BlockInterface;  class Example extends \Magento\Framework\View\Element\AbstractBlock {     public function toHtml()     {         return '&lt;h1&gt;Hello PHP Block Rendered in JS&lt;/h1&gt;';     } } </code></pre> <p>它就是 Magento 的标准 block 类，是可以通过 layout 配置的，它必须继承 <code>Magento\Framework\View\Element\AbstractBlock</code> 类。通常这些是 <code>phtml</code> template block ，但是这里为了简化我们用了 <code>toHtml</code> 方法直接返回了。</p> <p>刷新页面，我们应该看到下面的样子：</p> <p><img src="/wp-content/uploads/2018/06/html-content.png" alt="" /></p> <h2 id="hijacking-htmlcontent(劫持-htmlcontent)"><a href="#hijacking-htmlcontent(劫持-htmlcontent)" name="hijacking-htmlcontent(劫持-htmlcontent)"></a>Hijacking htmlContent(劫持 htmlContent)</h2> <p><code>htmlContent</code> 节点很有意思，if only for their amusing “render some server side code that renders some front-end code that renders some more server side code” pattern, we’re not interested in them today for their core functionality.我们使用 <code>htmlContent</code> 节点是因为：</p> <ol> <li>XSD 允许它作为 <code>&lt;container&gt;</code> 节点的子节点</li> <li>它的基本功能相对简单</li> <li>它是通用的，不太可能是特定功能的片段（比如 <code>&lt;listingToolbar/&gt;</code>）</li> </ol> <p>这些特点使得它是很适合劫持的。劫持，这里的意思是我们将利用 UI Component 的 xml 合并，使得我们的 <code>htmlContent</code> blocks 可以做如下事情：</p> <ol> <li>使用不同的 component class</li> <li>使用不同的 RequireJS view model constructor factory</li> <li>使得上面的 RequireJS view model constructor factory 指向一个新的 Knockout.js template</li> </ol> <p>对于第一点，我们要做的只是在 <code>htmlContent</code> XML 节点上加上新的 class 属性：</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/ui_component/pulsestorm_simple_valid.xml &lt;htmlContent class="Pulsestorm\SimpleValidUiComponent\Component\Simple" name="our_first_content"&gt; &lt;/htmlContent&gt; </code></pre> <p>我们也移除了 block argument 。因为 <code>Magento\Ui\Component\HtmlContent</code> 必须要 block argument ，但是我们的 <code>Pulsestorm\SimpleValidUiComponent\Component\Simple</code> 代替了它。</p> <p>下面创建 <code>Pulsestorm\SimpleValidUiComponent\Component\Simple</code></p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/Component/Simple.php &lt;?php namespace Pulsestorm\SimpleValidUiComponent\Component; class Simple extends \Magento\Ui\Component\AbstractComponent {     const NAME = 'html_content_pulsestorm_simple';     public function getComponentName()     {         return self::getName();     } } </code></pre> <p>对于第二点使用不同的 RequireJS view model constructor factory 我们要这样做：</p> <pre><code>&lt;htmlContent class="Pulsestorm\SimpleValidUiComponent\Component\Simple"  name="our_first_content"&gt;     &lt;argument name="data" xsi:type="array"&gt;         &lt;item name="config" xsi:type="array"&gt;             &lt;item name="component" xsi:type="string"&gt;Pulsestorm_SimpleValidUiComponent/js/pulsestorm_simple_component&lt;/item&gt;         &lt;/item&gt;     &lt;/argument&gt; &lt;/htmlContent&gt; </code></pre> <p>对于第三点使得 RequireJS view model constructor factory 指向一个新的 Knockout.js template</p> <pre><code>#File: app/code/Pulsestorm/SimpleValidUiComponent/view/adminhtml/web/js/pulsestorm_simple_component.js define(['uiElement','ko'], function(Element, ko){     viewModelConstructor = Element.extend({         defaults: {             template: 'Pulsestorm_SimpleValidUiComponent/pulsestorm_simple_template'         }     });      return viewModelConstructor; }); </code></pre> <p>下面创建 <code>Pulsestorm_SimpleValidUiComponent/pulsestorm_simple_template</code> 模板</p> <pre><code>&lt;!-- File: app/code/Pulsestorm/SimpleValidUiComponent//view/adminhtml/web/template/pulsestorm_simple_template.html --&gt; &lt;h1&gt;Our Remote Knockout Template!&lt;/h1&gt; </code></pre> <p>下面清空缓存，刷新页面</p> <p><img src="/wp-content/uploads/2018/06/hijack.png" alt="" /></p> <p>恭喜你，我们没有违反 Magento 的 XSD schema 验证，成功创建了一个 UI Component</p> <h2 id="wrap-up"><a href="#wrap-up" name="wrap-up"></a>Wrap Up</h2> <p>这是不是个好主意，有待后续验证。反正这次每个步骤都在我们的掌控中（自定义的 PHP Component ，自定义的 ReuqireJS Component，自定义的 Knockout.js 模板）理论上来说，将来 Magento 核心团队可能会做些修改，到时候我们今天的方法就没有用了。现在，UI Component 的基本问题是，很多证据都表明 UI Component 是 Magento 核心团队专用的，只有时间能告诉我们，第三方开发者是否能够将 UI Component 稳定地用在插件中。</p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento_2_ec6_template_literals/]]></link>
		<title><![CDATA[Magento 2: ES6 Template Literals]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><a href="https://alanstorm.com/magento_2_ec6_template_literals/">原文地址</a></p> <p>今天我们将了解 ES6 template literals （模板字符串）。Template literals 是 javascript 的新特性，Magento 2 的 UI Component 系统部分核心功能依赖它。Template literals 本身就是一个需要理解的重要概念，但是更重要的是要理解 Magento 在 template literals 之上创建的额外抽象层。还有 Magento 的 <code>uiClass</code> object system 是怎么把它吸收进来的。</p> <p>开始前，需要感谢 “bassplayer7” ，他在 <a href="https://magento.stackexchange.com/questions/137689/sigil-strings-in-magento-2s-requirejs-files/137716#137716">StackExchange 上的回答</a>，提供了完成该篇文章所需要的重要信息。</p> <h2 id="es6-template-literals"><a href="#es6-template-literals" name="es6-template-literals"></a>ES6 Template Literals</h2> <p>很多人的第一个问题可能是 —— ES6 是什么鬼？</p> <p>ES 是 ECMAScript 的缩写，ECMA 是 <a href="https://en.wikipedia.org/wiki/Ecma_International">Ecma_International</a> 的缩写，他是一个将各种 javascript/jscript/actionscript 编程语言标准化的机构。</p> <p><a href="http://es6-features.org/#Constants">ECMAScript 6 </a> 是该标准的最新版本。浏览器厂商（Apple, Google, Firefox）正在根据 ES6 标准实现功能（类似于 HTML 是怎样推出的）。</p> <p>其中一个功能正是 template literals 。Template literals 让 javascript 具备了简单的、内置的模板语言。我们将在 Google Chrome Console 中运行一些 template literal 示例代码，但是你是可以在任何支持 ES6 标准的 javascript 环境中运行这些示例代码的。</p> <p>Template literals 最简单的形式和字符串的区别很小。看下面的<code>Hello World</code> 文本：</p> <pre><code>&gt; results = `Hello World` &gt; console.log(results); Hello World </code></pre> <p>注意，我们把 “Hello World” 放在了重音符中（就是这个符号：<strong>`</strong> 中）</p> <p>放在重音符中的文本表示，这个字符串是一个 template literal</p> <p>到目前为止，字符串和模板字符串（Template literal）没什么特别大的区别。Template literals are (from a userland perspective) immediately rendered as strings</p> <pre><code>&gt; var results = `Hello World` &gt; var type    = typeof results; &gt; console.log(type) string </code></pre> <p><code>results</code> 变量看起来和 string 没什么区别，反正到目前为止，template literals 看起来没什么用。</p> <p>当然了，如果他们没有什么用的话，我们也不会写文章说它了。Template literals 支持 <strong>template variables/placeholders</strong> ，看下面的例子：</p> <pre><code>&gt; var salutation = "Goodbye" &gt; var results = `${salutation} World` &gt; console.log(results); </code></pre> <p><code>${salutation}</code> 就是一个 template literal variable (or placeholder) 这些变量从 js 当前作用域中获得。所以 js 会把 <code>${salutation}</code> 替换成 <code>Goodbye</code> 。 js 会这么做是因为我们给全局变量 <code>salutation</code> 赋值为 <code>Goodbye</code> 。</p> <p>要了解更多 template literals <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">请访问 Mozilla developer network</a> ，会讲更多高级特性，比如 <code>tag</code> 。</p> <h2 id="browser-support-and-magento-2"><a href="#browser-support-and-magento-2" name="browser-support-and-magento-2"></a>Browser Support and Magento 2</h2> <p>跟其他 js 新特性一样，客户端开发者在使用前需要特别注意浏览器是否支持该特性。目前不是所有浏览器都支持 Template literals ，在老的浏览器上使用他们会导致错误。</p> <p>Magento 2 的开发者通过创建 RequireJS 模块来 rendering template literals 去绕过使用限制。这个模块的 id 就是 <code>mage/utils/template</code> ，所以你可以像下面这样使用：</p> <pre><code>// 注意要在 Magento 页面中打开 debugger //requires an enviornment bootstrapped with Magento 2 //javascript.  i.e. open you debugger on a Magento page  &gt; requirejs(['mage/utils/template'], function(templateRenderer){     window.salutation      = 'Brave New';     var templateLiteral = '${salutation} World';     var results         = templateRenderer.template(templateLiteral);     console.log(results); });  Brave New World </code></pre> <p>幕后，<code>mage/utils/template</code> 模块会检查浏览器对 template literal 的支持。如果支持，模块将使用浏览器原生的实现方式，如果不支持，模块将使用纯用户级的实现方式（速度更慢一点）。<a href="https://en.wikipedia.org/wiki/Polyfill">这被称为 polyfill </a></p> <p>这个模块很有用，但是有几点需要说明。首先，你会注意到我们需要把 <code>salutation</code> 变量搁到全局的命名空间上（在浏览器的 js 环境下指的是 “window”）</p> <pre><code>window.salutation      = 'Brave New'; var templateLiteral = '${salutation} World'; </code></pre> <p>原生的 template literals 会从当前作用域取值，但是 Magento 2 的模块（任何用户级代码）则不能自动地访问该作用域，因此，template literals 只能从全局作用域上取值。</p> <p>看下面的代码：</p> <pre><code> &gt; requirejs(['mage/utils/template'], function(templateRenderer){         var salutation      = 'Brave New';         var templateLiteral = '${salutation} World';         var results         = templateRenderer.template(templateLiteral);         console.log(results);     }); </code></pre> <p>这里会报错(除非你定义了一个全局变量 salutation)：</p> <pre><code> VM1627:1 Uncaught ReferenceError: salutation is not defined </code></pre> <p>（这一段我也没看懂，所以放上原文）</p> <p>The second mage/utils/template caveat, and likely a direct result of the above scope problem, is Magento 2’s template literals have extra abilities that go above and beyond those defined in the standard.</p> <h2 id="binding-view-variables-to-a-template-literal"><a href="#binding-view-variables-to-a-template-literal" name="binding-view-variables-to-a-template-literal"></a>Binding View Variables to a Template Literal</h2> <p>Magento 2 的 template litearls 允许你绑定特定的对象到特定的 template literal 上，然后通过特别的语法引用变量。就像下面这样：</p> <pre><code>&gt; requirejs(['mage/utils/template'], function(templateRenderer){         var viewVars        = {             'salutation':'What a Crazy'         };         var templateLiteral = '${salutation} World';         var results         = templateRenderer.template(templateLiteral, viewVars);         console.log(results);     }); </code></pre> <p>就是说，<code>template</code> 方法第二个参数接受一个对象。</p> <pre><code>templateRenderer.template(templateLiteral, viewVars); </code></pre> <p>但是上面的代码还是会报错。这是因为我们前面说过要用特殊的语法的。你需要在 <code>${}</code> 里面用第二个 <code>$</code> 符号来引用对象。</p> <p>就是说下面这样</p> <pre><code>var templateLiteral = '${salutation} World'; </code></pre> <p>需要变成这样：</p> <pre><code>var templateLiteral = '${$.placeholder} World'; </code></pre> <p>这有点笨拙，不过还是很好理解的，只要明白 <code>$.</code> 指代你传递过去的对象。</p> <p>下面这样就对了。</p> <pre><code>requirejs(['mage/utils/template'], function(templateRenderer){         var viewVars        = {             'salutation':'What a Crazy'         };         var templateLiteral = '${$.salutation} World';         var results         = templateRenderer.template(templateLiteral, viewVars);         console.log(results);     });  What a Crazy World </code></pre> <h2 id="connection-to-ui-components"><a href="#connection-to-ui-components" name="connection-to-ui-components"></a>Connection to UI Components</h2> <p>为什么我们要在讲 Magento 2 的 UI Component 系列文章中讲 template literals 呢？这是因为 template literals 已经被植入了 view model constructor object 系统中。</p> <p>我们知道，Magento UI Components 使用的 Knockout.js view model constructor objects 是基于 <code>uiElement/Magento_Ui/js/lib/core/element/element</code> 模块的。(<a href="https://www.hellomagento2.com/alan_magento_2_simplest_ui_knockout_component/#configuring-a-view-model-constructor">不明白戳这里</a>)</p> <p>下面是一个简单的例子，我们先创建一个 view model constructor ，然后用这个 constructor 去创建 view model</p> <pre><code>&gt; requirejs(['uiElement'], function(Element){     viewModelConstructor = Element.extend({});     viewModel = new viewModelConstructor;     console.log(viewModel); });  UiClass {_super: undefined, ignoreTmpls: Object, ...} </code></pre> <p>这个 view model constructor 有能力带 default 值进行实例化（因为 <code>uiElement</code> 继承自 <code>uiClass/Magento_Ui/js/lib/core/class</code>，这个父类是拥有这个能力的）如果你为 view model constructor 提供 default object ，像下面这样：</p> <pre><code>viewModelConstructor = Element.extend({     'defaults':{         'ourDefaultValue':'Look at our value!'     } }); </code></pre> <p>那么所有通过这个 constructor 实例化的对象都会拥有 default 值 ourDefaultValue</p> <pre><code>&gt; requirejs(['uiElement'], function(Element){     viewModelConstructor = Element.extend({         'defaults':{             'ourDefaultValue':'Look at our value!'         }     });     viewModel = new viewModelConstructor;     console.log(viewModel.ourDefaultValue); });  Look at our value! </code></pre> <p>Magento 对象系统会是检查所有的 default 字符串，发现 template literal 就会自动计算出他们。</p> <pre><code>&gt; requirejs(['uiElement'], function(Element){     window.salutation = 'Hello';     viewModelConstructor = Element.extend({         'defaults':{             'message':'${salutation} World. ',             'salutation':'Goodbye'         }     });     viewModel = new viewModelConstructor;     console.log(viewModel.message); });  Hello World. </code></pre> <p>注意这里使用的是全局的 <code>salutation</code> 值。</p> <p>看下面的例子：</p> <pre><code>requirejs(['uiElement'], function(Element){     viewModelConstructor = Element.extend({         'defaults':{             'message':'${$.salutation} World. ',             'salutation':'Goodbye'         }     });     viewModel = new viewModelConstructor;     console.log(viewModel.message);  });  Goodbye World. </code></pre> <p>给 view model constructor 传递对象</p> <pre><code>requirejs(['uiElement'], function(Element){     viewModelConstructor = Element.extend({         'defaults':{             'message':'${$.salutation} World. ',             'salutation':'Goodbye'         }     });     viewModel = new viewModelConstructor({         'salutation':'This is still a crazy'     });     console.log(viewModel.message); });  This is still a crazy World. </code></pre> <h2 id="wrap-up"><a href="#wrap-up" name="wrap-up"></a>Wrap Up</h2> <p>本文揭示了想把 Magento 当作平台使用的开发者遇到的挑战之一。不仅有前沿 javaScript 概念，还有 Magento 通过不那么标准的方式(binding view variables)去扩展了这些概念，还有 Magento 是如何将这些概念吸收到自己的系统中去的（<code>uiClass</code> object system）。 如果没有上面的这些概念，那么你遇到下面这些代码的时候：</p> <pre><code>return Element.extend({     defaults: {         clientConfig: {             urls: {                 save: '${ $.submit_url }',                 beforeSave: '${ $.validate_url }'             }         }     }, </code></pre> <p>就只能摸不着头脑干着急了。</p> <p>现在我们了解了 Magento 的 ES6-like template literals .我们距离更进一步的探索又近了一步，下面我们将探索 Magento 是如何将后端数据放入 view model constructor 的 <code>default</code> 数组中的，还有 Magento 是如何处理 UI Component 生成的 data sources 的。</p> <p><a href="https://stackoverflow.com/questions/34270829/chrome-console-clear-assignment-and-variables">chrome console 中 var 声明的也是全局变量</a></p> <p><audio style="display: none;" controls="controls"></audio></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/category/developer-documentation/articles-for-professional-programmers/]]></link>
		<title><![CDATA[UI components 完整案例]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>原文地址 这篇要说的是 Magento 2 的 Mixins 。说它奇怪是因为 Mixins 这个命名不正确，有歧义，他其实是 RequireJS monkey patching 。（Monkey Patching 指的是在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在代码运行时&#8230;</p>  			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/alan_magento-2s-base-javascript-class/]]></link>
		<title><![CDATA[Magento 2’s Base Javascript Class]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p><a href="https://alanstorm.com/magento-2s-base-javascript-class/">原文地址</a></p> <p>Magento 2 的核心 javascript library 实现了一个基于类的基础 object system（Magento 2’s core javascript library ships with a basic implementation of a class based object system），uiComponent 广泛地使用了这些基本类和对象。这个基本类就是 <code>Magento_Ui/js/lib/core/class</code> ，你可以通过 javascript 的 <code>new</code> 关键字来创建这个基础类的实例。</p> <pre><code>&gt; requirejs([     &#39;Magento_Ui/js/lib/core/class&#39;, ], function (Class) {     &#39;use strict&#39;;     var o = new Class;     console.log(o); });  UiClass {ignoreTmpls: {…}} </code></pre> <p>你可以使用基础类的 <code>extend</code> 方法去创建子类。通过 <code>extend</code> 方法传递 key/function 对去定义方法。Magento 的对象有一个类似 constructor 的方法叫做 <code>initialize</code>，它在实例化对象的时候被调用。你可以通过 <code>this._super()</code> 来调用父类的方法。只能在方法体中调用 <code>_super</code> —— 该方法并不是”公有的” (not exposed publicly)</p> <p>在下面的例子中，我们定义两个类 A 和 B 。 A 继承基础类，B 继承 A，定义好类以后，我们实例化一个 B 类，然后调用该对象的 hello 方法：</p> <pre><code>requirejs([     &#39;Magento_Ui/js/lib/core/class&#39;, ], function (Class) {     &#39;use strict&#39;;      var A = Class.extend({         initialize: function () {             this._super();             console.log(&quot;Called A&#39;s initialize/constructor&quot;);             this.foo = &quot;foo&quot;;             this.bar = &quot;bar&quot;;          },          hello: function(){             console.log(&quot;Hello&quot;);         }     });      var B = A.extend({         initialize: function () {             this._super();             console.log(&quot;Called B&#39;s initialize/constructor&quot;);             this.bar = &quot;BIG BAR&quot;;             this.baz = &quot;baz&quot;;         },          hello: function(){             this._super();             console.log(&quot;Hello Again&quot;);         }     });      var object = new B;     object.hello();     console.log(object); });   Called A&#39;s initialize/constructor Called B&#39;s initialize/constructor Hello Hello Again UiClass {_super: undefined, ignoreTmpls: {…}, foo: &quot;foo&quot;, bar: &quot;BIG BAR&quot;, baz: &quot;baz&quot;} </code></pre> <p><code>Magento_Ui/js/lib/core/class</code> 的别名是 <code>uiClass</code></p> <pre><code>vendor/magento/module-ui/view/base/requirejs-config.js 15:            uiClass:        &#39;Magento_Ui/js/lib/core/class&#39;, </code></pre> <p>所以下面这样也是等价的：</p> <pre><code>requirejs([     &#39;uiClass&#39;, ], function (Class) {     &#39;use strict&#39;;     o = new Class; }); </code></pre> <p><code>lib/core/element/element</code>(别名 <code>uiElement</code>) 继承自 <code>Magento_Ui/js/lib/core/class</code>，而 <code>lib/core/collection</code> (别名 <code>uiComponent</code>) 继承自 <code>uiElement</code></p> <p>讲解基础类的是怎么实现的超出了本文的范围。不过 <code>extend</code> 方法是通过 Underscore JS 实现的，<code>_super</code> 则来自于 <code>mage/utils/wrapper</code> (也就是 <code>lib/web/mage/utils/wrapper.js</code>)</p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/%E5%88%9B%E5%BB%BA-magento-2-hello-world-simple-module/]]></link>
		<title><![CDATA[创建 Magento 2 Hello World Simple Module]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇文章将介绍如何创建一个输出 <code>hello world</code> 的简单模块。</p> <p>在 Magento 2 中，模块存在于 <code>app/code</code> 目录下，格式如下<br /> <code>app/code/&lt;Vendor&gt;/&lt;ModuleName&gt;</code>。</p> <h2 id="第一步：创建模块所需的目录"><a href="#第一步：创建模块所需的目录" name="第一步：创建模块所需的目录"></a>第一步：创建模块所需的目录</h2> <p>我们将使用 <code>ThankIT</code> 作为 Vendor name ，<code>HelloWorld</code> 作为 ModuleName ，所以我们现在创建文件目录 <code>app/code/ThankIT/HelloWorld</code></p> <h2 id="第二步：创建-module.xml-声明该模块"><a href="#第二步：创建-module.xml-声明该模块" name="第二步：创建-module.xml-声明该模块"></a>第二步：创建 module.xml 声明该模块</h2> <p>在上面创建的目录下，创建 <code>etc</code> 目录，在 <code>etc</code> 下创建 <code>module.xml</code></p> <pre><code>&lt;!-- File: app/code/ThankIT/HelloWorld/etc/module.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd"&gt;     &lt;module name="ThankIT_HelloWorld" setup_version="1.0.0" /&gt; &lt;/config&gt; </code></pre> <p>在该配置文件中，我们注册了一个模块名称为 <code>ThankIT_HelloWorld</code> 的模块，它的版本是 <code>1.0.0</code></p> <h2 id="第三步：创建-registration.php-注册模块"><a href="#第三步：创建-registration.php-注册模块" name="第三步：创建-registration.php-注册模块"></a>第三步：创建 registration.php 注册模块</h2> <p>Magento 2 中的所有模块都必须通过 magento 的 ComponentRegistrar 类进行注册。</p> <pre><code>#File: app/code/ThankIT/HelloWorld/registration.php &lt;?php \Magento\Framework\Component\ComponentRegistrar::register(     \Magento\Framework\Component\ComponentRegistrar::MODULE,     'ThankIT_HelloWorld',     __DIR__ ); </code></pre> <h2 id="第四步：enable-该模块"><a href="#第四步：enable-该模块" name="第四步：enable-该模块"></a>第四步：Enable 该模块</h2> <p>上面步骤做完后，我们就已经创建好了一个空模块，下面输入以下命令行，看看我们的模块是否已经注册好了。</p> <pre><code>php bin/magento module:status </code></pre> <p>你会看到</p> <pre><code>List of disabled modules: ThankIT_HelloWorld </code></pre> <p>这代表，模块已经被检测到，但 disabled 状态，下面启用它</p> <pre><code>php bin/magento module:enable ThankIT_HelloWorld </code></pre> <p>如果看到以下信息，表明模块已经成功启用了</p> <pre><code>The following modules has been enabled: - ThankIT_HelloWorld </code></pre> <p>这是你第一次启用该模块，magento 需要检查和升级模块的数据库记录，运行以下命令行</p> <pre><code>php bin/magento setup:upgrade </code></pre> <p>现在我们进入后台，在 <code>Stores -&gt; Configuration -&gt; Advanced -&gt; Advanced</code> 下我们可以看到该模块了</p> <h2 id="第五步：为模块创建路由"><a href="#第五步：为模块创建路由" name="第五步：为模块创建路由"></a>第五步：为模块创建路由</h2> <p>Magento 系统中，请求 URL 是如下格式</p> <pre><code>http://example.com/&lt;router_name&gt;/&lt;controller_name&gt;/&lt;action_name&gt; </code></pre> <p>路由用来分配 URL 给对应的 controller （控制器）和 action 。在该模块中，我们给前端创建一个路由，所以创建下面的文件</p> <pre><code>&lt;!-- File: app/code/ThankIT/HelloWorld/etc/frontend/routes.xml --&gt; &lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd"&gt;     &lt;router id="standard"&gt;         &lt;route id="helloworld" frontName="helloworld"&gt;             &lt;module name="ThankIT_HelloWorld" /&gt;         &lt;/route&gt;     &lt;/router&gt; &lt;/config&gt; </code></pre> <p>定义好路由后，我们的模块 URL 路径变成 <code>http://example.com/helloworld/*</code></p> <h2 id="第六步：创建-controller-和-action"><a href="#第六步：创建-controller-和-action" name="第六步：创建-controller-和-action"></a>第六步：创建 controller 和 action</h2> <p>在该步骤中，我们将创建 controller 和 action 来输出 <code>Hello World</code> 。假设我们的 URL 是 <code>http://example.com/helloworld/index/display</code></p> <p>所以我们将创建如下文件</p> <pre><code>#File: app/code/Mageplaza/HelloWorld/Controller/Index/Display.php &lt;?php namespace ThankIT\HelloWorld\Controller\Index;  class Display extends \Magento\Framework\App\Action\Action {     public function __construct(         \Magento\Framework\App\Action\Context $context     ){     return parent::__construct($context);     }      public function execute()     {         echo 'Hello World';         exit;     } } </code></pre> <p>如果打开 <code>http://example.com/helloworld/index/display</code> 就会看到输出 <code>Hello World</code> 字符串。</p> <p>如果出现 404 请清空缓存 <code>php bin/magento cache:clean</code></p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="https://www.mageplaza.com/magento-2-module-development/" target="_blank" rel="noopener">Magento 2 Module Development &#8211; Magento 2 Hello World Simple Module</a></p> <h2 id="代码下载"><a href="#代码下载" name="代码下载"></a>代码下载</h2> <p><a href="https://github.com/PiscesThankIT/ThankIT_HelloWorld/" target="_blank" rel="noopener">ThankIT_HelloWorld 模块代码下载</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-%E4%B8%AD%E7%9A%84-controller/]]></link>
		<title><![CDATA[Magento 2 中的 Controller]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇围绕 Magento 2 的 Controller ，介绍控制器是怎么工作的，怎么创建，它和 layout 配置文件配合，怎么输出一个页面，以及控制器中经常用到的两个方法 <code>_redirect()</code> 和 <code>_forward()</code> 。</p> <p>控制器在 Magento 2 中是很重要的，一般而言，对 PHP MVC 框架来说也是很重要的。它的功能是接受请求，处理请求和呈现页面(render page)。</p> <p>模块的 Controller 目录下有一个或多个文件，每个文件都是一个单独的 class ，每个 class 都有一个 <code>execute</code> 方法。Magento 2 中有两种类型的控制器，一种是前台控制器，另一种是后台控制器。他们大体上是一样的流程，后台控制器稍微特别点，它拥有一个检查权限的方法。</p> <h2 id="控制器怎么工作的？"><a href="#控制器怎么工作的？" name="控制器怎么工作的？"></a>控制器怎么工作的？</h2> <p>它从终端用户（浏览器或命令行）接受请求，比如：</p> <pre><code>http://example.com/route_name/controller/action </code></pre> <ul> <li><code>route_name</code> 是一个在 routes.xml 中设置的唯一名称</li> <li><code>controller</code> 是 Controller 目录下的文件夹</li> <li><code>action</code> 是一个有 execute 方法的 class</li> </ul> <p>Magento 2 系统中处理请求，路由到对应控制器的类是 frontController (<code>Magento\Framework\App\FrontController</code>)<br /> 看代码：</p> <pre><code>foreach ($this-&gt;_routerList as $router) {    try {       $actionInstance = $router-&gt;match($request);    … } </code></pre> <p>如果找到匹配的 action 类，那么就会执行其中的 <code>execute</code> 方法。</p> <h2 id="如何创建控制器"><a href="#如何创建控制器" name="如何创建控制器"></a>如何创建控制器</h2> <p>如果还不清楚怎么创建模块，请参考 <a href="/%E5%88%9B%E5%BB%BA-magento-2-hello-world-simple-module/">创建 Magento 2 Hello World Simple Module</a>。本篇以该文中创建的模块为基础。该文末尾可以找到对应的代码下载地址，可以下载后跟着本文的步骤做。本文末尾也附带完成后的代码供比对。</p> <p>要创建控制器，首先需要在模块目录下创建 <code>Controller</code> 目录。<br /> 假设我们在 <code>ThankIT_HelloWorld</code> 模块的基础上创建一个 <code>Index</code> controller 和一个 <code>Index</code> action</p> <h3 id="创建-routes.xml"><a href="#创建-routes.xml" name="创建-routes.xml"></a>创建 routes.xml</h3> <p>File: etc/frontend/routes.xml</p> <pre><code>&lt;?xml version="1.0" ?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:App/etc/routes.xsd"&gt;     &lt;router id="standard"&gt;         &lt;route frontName="helloworld" id="helloworld"&gt;             &lt;module name="ThankIT_HelloWorld"/&gt;         &lt;/route&gt;     &lt;/router&gt; &lt;/config&gt; </code></pre> <h3 id="创建控制器"><a href="#创建控制器" name="创建控制器"></a>创建控制器</h3> <p>File: Controller/Index/Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Index;  class Index extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     )     {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         return $this-&gt;resultPageFactory-&gt;create();     } } </code></pre> <p>所有 controller 都必须继承自 <code>\Magento\Framework\App\Action\Action</code> 该类有 <code>dispatch</code> 方法，就是 <code>dispatch</code> 方法会调用 <code>execute</code> 方法。在 <code>execute</code> 方法中我们放控制器的逻辑并返回响应结果。</p> <h3 id="创建-layout-文件"><a href="#创建-layout-文件" name="创建-layout-文件"></a>创建 layout 文件</h3> <p>File: view/frontend/layout/helloworld_index_index.xml</p> <pre><code>&lt;?xml version="1.0" ?&gt; &lt;page layout="1column" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;body&gt;         &lt;referenceContainer name="content"&gt;             &lt;block class="ThankIT\HelloWorld\Block\Index\Index" name="index.index" template="ThankIT_HelloWorld::index/index.phtml"/&gt;         &lt;/referenceContainer&gt;     &lt;/body&gt; &lt;/page&gt; </code></pre> <h3 id="创建-block"><a href="#创建-block" name="创建-block"></a>创建 Block</h3> <p>File: app\code\ThankIT\HelloWorld\Block\Index\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Block\Index; use Magento\Framework\View\Element\Template;  class Index extends Template {  } </code></pre> <h3 id="创建-template"><a href="#创建-template" name="创建-template"></a>创建 template</h3> <p>File: view/frontend/templates/index/index.phtml</p> <pre><code>Welcome to hellomagento2.com </code></pre> <h3 id="刷新缓存"><a href="#刷新缓存" name="刷新缓存"></a>刷新缓存</h3> <p>命令行：</p> <pre><code>php bin/magento cache:flush </code></pre> <h3 id="测试"><a href="#测试" name="测试"></a>测试</h3> <p>浏览器中打开<code>http://&lt;yourhost.com&gt;/helloworld/index/index</code> 或者 <code>http://&lt;yourhost.com&gt;/helloworld/</code></p> <p>我们就可以看到结果了，这次不是纯字符串哦。</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/08/How-to-create-Controllers-in-Magento-2.png" alt="How to create Controllers in Magento 2" /></p> <h2 id="permission---acl"><a href="#permission---acl" name="permission---acl"></a>Permission &#8211; ACL</h2> <p>参考 <a href="/magento-2-admin-acl-access-control-lists" target="_blank" rel="noopener">Magento 2 Admin ACL Access Control Lists</a></p> <h2 id="magento-2-控制的其他方法"><a href="#magento-2-控制的其他方法" name="magento-2-控制的其他方法"></a>Magento 2 控制的其他方法</h2> <h3 id="forward-method"><a href="#forward-method" name="forward-method"></a>Forward method</h3> <p><code>_forward()</code> protected 方法会将请求转向其他 <code>controller/action</code> 但是用户在浏览器中看到的 URL 是不变的。</p> <p>例如:<br /> File: Controller/Index/Forward.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Index;  class Forward extends \Magento\Framework\App\Action\Action {     public function execute()     {         $this-&gt;_forward('index');     } } </code></pre> <p>创建好以后 <code>cache:flush</code> 然后访问 <code>http://&lt;yourhost.com&gt;/helloworld/index/forward</code> 会看到和访问 <code>http://&lt;yourhost.com&gt;/helloworld/index/index</code> 一样的结果，但是我们的 url 并没有改变。</p> <p><code>_forward()</code> 还有其他参数：</p> <pre><code>function _forward($action, $controller = null, $module = null, array $params = null) </code></pre> <p>其中的 <code>$module</code> 指的是 route_name 对应在 routes.xml 中设置的唯一名称。</p> <h3 id="redirect-method"><a href="#redirect-method" name="redirect-method"></a>Redirect method</h3> <p><code>_redirect()</code> 除了会会将请求转向其他 <code>controller/action</code> ，响应的 URL 也会发生改变。</p> <p>可将上述例子中的 <code>$this-&gt;_forward('index');</code> 改成 <code>$this-&gt;_redirect('*/*/index');</code> 查看效果。</p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="https://www.mageplaza.com/magento-2-module-development/how-to-create-controllers-magento-2.html" target="_blank" rel="noopener noreferrer">how to create Controllers in Magento 2</a></p> <h2 id="代码下载"><a href="#代码下载" name="代码下载"></a>代码下载</h2> <p><a href="https://github.com/PiscesThankIT/ThankIT_HelloWorld_2" target="_blank" rel="noopener noreferrer">相关代码下载</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/crud-models-in-magento-2/]]></link>
		<title><![CDATA[CRUD Models in Magento 2]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇我们将介绍通过 setup script 创建数据表，创建 Magento 2 model, resource model, collection ，以及如何通过它们对数据进行增删改查。</p> <p>Magento 2 中的 CRUD Models 用于操纵数据库中的数据，不需要很多代码就可以创建一个 CRUD 。 CRUD 代表 Create, Read, Update and Delete （增删改查）。</p> <p>我们将创建一个表 <code>thankit_helloworld_post</code></p> <table class="table table-hover"> <thead> <tr> <th>Name</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>post_id</td> <td>ID 主键</td> </tr> <tr> <td>name</td> <td>post 的名称</td> </tr> <tr> <td>url_key</td> <td>Post URL Key</td> </tr> <tr> <td>post_content</td> <td>post 的内容</td> </tr> <tr> <td>tags</td> <td>post tags</td> </tr> <tr> <td>status</td> <td>post 状态</td> </tr> <tr> <td>featured_image</td> <td>Post Featured Image</td> </tr> <tr> <td>sample_country_selection</td> <td>Post Sample Country Selection</td> </tr> <tr> <td>sample_multiselect</td> <td>Post Sample Multiselect</td> </tr> <tr> <td>created_at</td> <td>创建时间</td> </tr> <tr> <td>updated_at</td> <td>更新时间</td> </tr> </tbody> </table> <h2 id="第一步：setup-script"><a href="#第一步：setup-script" name="第一步：setup-script"></a>第一步：Setup Script</h2> <p>File:app/code/ThankIT/HelloWorld/Setup/InstallSchema.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Setup;  class InstallSchema implements \Magento\Framework\Setup\InstallSchemaInterface {     /**      * install tables      *      * @param \Magento\Framework\Setup\SchemaSetupInterface $setup      * @param \Magento\Framework\Setup\ModuleContextInterface $context      * @return void      * @SuppressWarnings(PHPMD.ExcessiveMethodLength)      */     public function install(         \Magento\Framework\Setup\SchemaSetupInterface $setup,         \Magento\Framework\Setup\ModuleContextInterface $context     ) {         $installer = $setup;         $installer-&gt;startSetup();         if (!$installer-&gt;tableExists('thankit_helloworld_post')) {             $table = $installer-&gt;getConnection()-&gt;newTable(                 $installer-&gt;getTable('thankit_helloworld_post')             )             -&gt;addColumn(                 'post_id',                 \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,                 null,                 [                     'identity' =&gt; true,                     'nullable' =&gt; false,                     'primary'  =&gt; true,                     'unsigned' =&gt; true,                 ],                 'Post ID'             )             -&gt;addColumn(                 'name',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 255,                 ['nullable =&gt; false'],                 'Post Name'             )             -&gt;addColumn(                 'url_key',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 255,                 [],                 'Post URL Key'             )             -&gt;addColumn(                 'post_content',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 '64k',                 [],                 'Post Post Content'             )             -&gt;addColumn(                 'tags',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 255,                 [],                 'Post Tags'             )             -&gt;addColumn(                 'status',                 \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,                 1,                 [],                 'Post Status'             )             -&gt;addColumn(                 'featured_image',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 255,                 [],                 'Post Featured Image'             )             -&gt;addColumn(                 'sample_country_selection',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 3,                 [],                 'Post Sample Country Selection'             )             -&gt;addColumn(                 'sample_upload_file',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 255,                 [],                 'Post Sample File'             )             -&gt;addColumn(                 'sample_multiselect',                 \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                 '64k',                 [],                 'Post Sample Multiselect'             )             -&gt;addColumn(                 'created_at',                 \Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,                 null,                 [],                 'Post Created At'             )             -&gt;addColumn(                 'updated_at',                 \Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,                 null,                 [],                 'Post Updated At'             )             -&gt;setComment('Post Table');             $installer-&gt;getConnection()-&gt;createTable($table);             $installer-&gt;getConnection()-&gt;addIndex(                 $installer-&gt;getTable('thankit_helloworld_post'),                 $setup-&gt;getIdxName(                     $installer-&gt;getTable('thankit_helloworld_post'),                     ['name','url_key','post_content','tags','featured_image','sample_upload_file'],                     \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_FULLTEXT                 ),                 ['name','url_key','post_content','tags','featured_image','sample_upload_file'],                 \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_FULLTEXT             );         }         $installer-&gt;endSetup();     } } </code></pre> <p><em><br /> 了解 addColumn() addIndex() addForeignKey 的参数参照 <code>vendor/magento/framework/DB/Ddl/Table</code><br /> </em></p> <p>该文件只会在安装模块时执行一次。如果你以前安装过该模块了，这个文件就不会执行了。</p> <p>执行命令行：</p> <pre><code>php bin/magento setup:upgrade </code></pre> <p>如果你的数据库中没有出现 <code>thankit_helloworld_post</code> 表，那么请在数据库中找到 <code>setup_module</code> 表，找到 <code>ThankIT_HelloWorld</code> 的记录，删掉这行记录。然后再运行上面的命令行。</p> <p><code>InstallSchema.php</code> 是用来创建数据库结构的，如果你想插入记录的话，使用 <code>InstallData.php</code></p> <p>参考下面的文件，看 <code>InstallData.php</code> 是怎么个用法：</p> <pre><code>- vendor/magento/module-tax/Setup/InstallData.php - vendor/magento/module-customer/Setup/InstallData.php - vendor/magento/module-catalog/Setup/InstallData.php </code></pre> <p>这些安装文件是在初次安装时执行的，如果你想在升级时做点什么，请使用 <code>UpgradeSchema.php</code> 和 <code>UpgradeData.php</code></p> <h2 id="第二步：创建-model"><a href="#第二步：创建-model" name="第二步：创建-model"></a>第二步：创建 Model</h2> <p>Magento 2 中模型有很多作用，比如操作数据，安装或升级模块。在本教程中，我们只涉及数据的增删改查操作。我们要操作 <code>thankit_helloworld_post</code> 中的数据，需要创建 Model, Resource Model, Resource Model Conllection</p> <p>File: app/code/ThankIT/HelloWorld/Model/Post.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Model;  /**  * @method Post setName($name)  * @method Post setUrlKey($urlKey)  * @method Post setPostContent($postContent)  * @method Post setTags($tags)  * @method Post setStatus($status)  * @method Post setFeaturedImage($featuredImage)  * @method Post setSampleCountrySelection($sampleCountrySelection)  * @method Post setSampleUploadFile($sampleUploadFile)  * @method Post setSampleMultiselect($sampleMultiselect)  * @method mixed getName()  * @method mixed getUrlKey()  * @method mixed getPostContent()  * @method mixed getTags()  * @method mixed getStatus()  * @method mixed getFeaturedImage()  * @method mixed getSampleCountrySelection()  * @method mixed getSampleUploadFile()  * @method mixed getSampleMultiselect()  * @method Post setCreatedAt(\string $createdAt)  * @method string getCreatedAt()  * @method Post setUpdatedAt(\string $updatedAt)  * @method string getUpdatedAt()  */ class Post extends \Magento\Framework\Model\AbstractModel {      /**      * Initialize resource model      *      * @return void      */     protected function _construct()     {         $this-&gt;_init('ThankIT\HelloWorld\Model\ResourceModel\Post');     } } </code></pre> <p>Model 必须继承 <code>\Magento\Framework\Model\AbstractModel</code> 而该类又继承自 <code>\Magento\Framework\Object</code> ，这样我们的 model 就拥有了额外的方法，比如 <code>load, delete, save, toArray, toJson, toString, toXml</code></p> <p>Model 中关键的代码是</p> <pre><code>/**  * Initialize resource model  *  * @return void  */ protected function _construct() {    $this-&gt;_init('ThankIT\HelloWorld\Model\ResourceModel\Post'); } </code></pre> <h2 id="第三步：resource-model"><a href="#第三步：resource-model" name="第三步：resource-model"></a>第三步：Resource Model</h2> <p>Model 中包含总体上的数据逻辑，但它不执行 sql 语句，由 Resource model 做。</p> <p>File: ThankIT\HelloWorld\Model\ResourceModel\Post.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Model\ResourceModel;  class Post extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb {     /**      * Date model      *      * @var \Magento\Framework\Stdlib\DateTime\DateTime      */     protected $_date;      /**      * constructor      *      * @param \Magento\Framework\Stdlib\DateTime\DateTime $date      * @param \Magento\Framework\Model\ResourceModel\Db\Context $context      */     public function __construct(         \Magento\Framework\Stdlib\DateTime\DateTime $date,         \Magento\Framework\Model\ResourceModel\Db\Context $context     ) {         $this-&gt;_date = $date;         parent::__construct($context);     }      /**      * Initialize resource model      *      * @return void      */     protected function _construct()     {         $this-&gt;_init('thankit_helloworld_post', 'post_id');     }      /**      * Retrieves Post Name from DB by passed id.      * 本篇未使用到 保留 以后研究      * @param string $id      * @return string]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-templates-use-block-or-this/]]></link>
		<title><![CDATA[Magento 2 Templates: Use $block or $this]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>在 Magento 2 的 templates 中使用 <code>$block</code> 还是 <code>$this</code> ？<br /> 结论：<code>$block</code> 和 <code>$this</code> 指向同一个 block 对象，但是建议使用 <code>$block</code> 不建议使用 <code>$this</code>。</p> <p>在 M2 的 template 中，<code>$this</code> 指向的不再是该 template 的 block 对象，而是一个 template 类：<code>Magento\Framework\View\TemplateEngine\Php</code></p> <p>以之前的 ThankIT_HelloWorld 模块为基础，修改以下文件，进行实验。</p> <p>File：app\code\ThankIT\HelloWorld\view\frontend\templates\index\index.phtml</p> <pre><code>Welcome to hellomagento2.com &lt;?php echo '&lt;br/&gt;'; echo get_class($this); echo '&lt;br/&gt;'; echo $block-&gt;sayHello(); echo '&lt;br/&gt;'; // discouraged echo $this-&gt;sayHello(); </code></pre> <p>File: app\code\ThankIT\HelloWorld\Block\Index\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Block\Index;  use Magento\Framework\View\Element\Template;  class Index extends Template {     # ... other code     public function sayHello()     {         return __('Hello World');     }     #... ohter code ... </code></pre> <p>那么访问我们的 url <code>http://example.com/helloworld/index/index/</code> 得到的类名正是 <code>Magento\Framework\View\TemplateEngine\Php</code><br /> 查看该类的以下方法：</p> <pre><code>    /**      * Redirects methods calls to the current block      *      * This is needed because the templates are included in the context of this engine      * rather than in the context of the block.      *      * @param   string $method      * @param   array  $args      * @return  mixed      */     public function __call($method, $args)     {         return call_user_func_array([$this-&gt;_currentBlock, $method], $args);     } </code></pre> <p>这就解释了为什么我们可以通过 <code>$this</code> 来调用 block 中的方法。</p> <p>查看该类的以下方法</p> <pre><code>    /**      * Render output      *      * Include the named PHTML template using the given block as the $this      * reference, though only public methods will be accessible.      *      * @param BlockInterface           $block      * @param string                   $fileName      * @param array                    $dictionary      * @return string      * @throws \Exception      */     public function render(BlockInterface $block, $fileName, array $dictionary = [])     {         ob_start();         try {             $tmpBlock = $this-&gt;_currentBlock;             $this-&gt;_currentBlock = $block;             extract($dictionary, EXTR_SKIP);             include $fileName;             $this-&gt;_currentBlock = $tmpBlock;         } catch (\Exception $exception) {             ob_end_clean();             throw $exception;         }         /** Get output buffer. */         $output = ob_get_clean();         return $output;     } </code></pre> <p>在 <code>include $fileName;</code> 前，<code>$this-&gt;_currentBlock = $block</code> ，而在 template 中，<code>$block</code> 和 <code>$this-&gt;_currentBlock</code> 是一样的。这就解释了为什么我们可以通过 <code>$block</code> 来访问 block 中的方法。</p> <p>但是 <code>The php sniffer with the EcgM2 standards</code> 不建议使用 <code>$this</code> ，所以我们还是用 <code>$block</code> 吧。</p> <h2 id="参考网址"><a href="#参考网址" name="参考网址"></a>参考网址</h2> <p><a href="https://magento.stackexchange.com/questions/103096/magento-2-templates-use-block-or-this" target="_blank">Magento 2 Templates: Use <code>$block</code> or <code>$this</code>?</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/system-xml-configuration/]]></link>
		<title><![CDATA[System.xml Configuration]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>如果模块需要管理员设置某些选项，就需要通过 <code>system.xml</code> 配置文件来创建和保存配置字段。那么我们怎么创建和使用 <code>system.xml</code> 呢？</p> <h2 id="第一步：创建-system.xml"><a href="#第一步：创建-system.xml" name="第一步：创建-system.xml"></a>第一步：创建 system.xml</h2> <p>请在 Magento 2 后台进入 <code>Stores -&gt; Settings -&gt; Configuration</code> 。<br /> Magento 2 的系统配置页面被分成了几个部分：Tabs, Sections, Groups, Fields 。</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/09/tabs-sections-groups-fields.png" alt="Magento 2 system configuration page is divided logically in few parts: Tabs, Sections, Groups, Fields" /></p> <p>以之前的 <code>ThankIT_HelloWorld</code> 模块为基础，下面我们创建一个配置页面，tab 是 ThankIT （for our vendor），section 是 Hello World （for our module），group 组包含一些简单的字段。</p> <p>File: app/code/ThankIT/HelloWorld/etc/adminhtml/system.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Config:etc/system_file.xsd"&gt;     &lt;system&gt;         &lt;tab id="mageplaza" translate="label" sortOrder="10"&gt;             &lt;label&gt;Mageplaza&lt;/label&gt;         &lt;/tab&gt;         &lt;section id="helloworld" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1"&gt;             &lt;class&gt;separator-top&lt;/class&gt;             &lt;label&gt;Hello World&lt;/label&gt;             &lt;tab&gt;mageplaza&lt;/tab&gt;             &lt;resource&gt;Mageplaza_HelloWorld::hello_configuration&lt;/resource&gt;             &lt;group id="general" translate="label" type="text" sortOrder="10" showInDefault="1" showInWebsite="0" showInStore="0"&gt;                 &lt;label&gt;General Configuration&lt;/label&gt;                 &lt;field id="enable" translate="label" type="select" sortOrder="1" showInDefault="1" showInWebsite="0" showInStore="0"&gt;                     &lt;label&gt;Module Enable&lt;/label&gt;                     &lt;source_model&gt;Magento\Config\Model\Config\Source\Yesno&lt;/source_model&gt;                 &lt;/field&gt;                 &lt;field id="display_text" translate="label" type="text" sortOrder="1" showInDefault="1" showInWebsite="0" showInStore="0"&gt;                     &lt;label&gt;Display Text&lt;/label&gt;                     &lt;comment&gt;This text will display on the frontend.&lt;/comment&gt;                 &lt;/field&gt;             &lt;/group&gt;         &lt;/section&gt;     &lt;/system&gt; &lt;/config&gt; </code></pre> <p>以下是关于 system.xml 中一些元素的介绍。</p> <ul> <li>The Tab element may have many sections and some main attributes and child: <ul> <li>Id attribute is the identify for this tab</li> <li>sortOrder attribute will define the position of this tab.</li> <li>Translate attribute let Magento know which title need to translate</li> <li>Label element child is the text which will show as tab title.</li> </ul> </li> <li>The Section element will have id, sortOrder, translate attributes like the Tab element. Some other attributes (showInDefault, showInWebsite, showInStore) will decide this element will be show on each scope or not. You can change the scope here<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/configuration-scope.png" alt="change system configuration scope" /></li> </ul> <p>The section may have many group and some other child elements:</p> <ul> <li>Class: this value will be added as class for this element. You should use it if you want to make-up this element.</li> <li>Label: the text title of this element</li> <li>Tab: this’s a tab id. This tab element will let Magento know the tab which this section is belong to. This section will be placed under that tab</li> <li>Resource: defined the ACL rule which the admin user must have in order to access this configuration.</li> <li>Group: This element may have many field and some attributes which is same as Sections.</li> <li>Fields: is the main path of this page. It will save the data which we want to setting. In this element, we focus on the type attribute. It will define how the element is when display. It can be: text, select, file… In this example we create 2 fields with type select and text. With each type we will define the child element for the field to make it work as we want.</li> </ul> <h2 id="第二步：设置默认值"><a href="#第二步：设置默认值" name="第二步：设置默认值"></a>第二步：设置默认值</h2> <p>我么可以通过 <code>config.xml</code> 来给 <code>system.xml</code> 中的字段设置默认值。</p> <p>File: app/code/ThankIT/HelloWorld/etc/config.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Store:etc/config.xsd"&gt;     &lt;default&gt;         &lt;helloworld&gt;             &lt;general&gt;                 &lt;enable&gt;1&lt;/enable&gt;                 &lt;display_text&gt;Hello World&lt;/display_text&gt;             &lt;/general&gt;         &lt;/helloworld&gt;     &lt;/default&gt; &lt;/config&gt; </code></pre> <p>格式：</p> <pre><code>&lt;default&gt;     &lt;section_id&gt;         &lt;group_id&gt;             &lt;field_id&gt;{value}&lt;/field_id&gt;         &lt;/group_id&gt;     &lt;/section_id&gt; &lt;/default&gt; </code></pre> <h2 id="第三步：刷新缓存"><a href="#第三步：刷新缓存" name="第三步：刷新缓存"></a>第三步：刷新缓存</h2> <p>刷新缓存后，你就可以看到结果了：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/thankit_helloworld_configuration_page.png" alt="ThankIT HelloWorld Configuration page" /></p> <h2 id="第四步：获得配置值"><a href="#第四步：获得配置值" name="第四步：获得配置值"></a>第四步：获得配置值</h2> <p>在 <code>system.xml</code> 中，我们加了两个字段，他们的 path 是：<br /> <code>helloworld/general/enable</code><br /> <code>helloworld/general/display_text</code></p> <p>然后，我们改一下配置，保存后，刷新缓存。我们查看 <code>core_config_data</code> 这张数据库表，就会看到我们保存的配置值了（只创建了 config.xml 并不会在该表插入记录，后台点击保存后才会在表中插入记录）。</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/09/core_config_data_records.png" alt="core_config_data 中的记录值" /></p> <p>万变不离其宗，获取配置值，是通过 <code>\Magento\Framework\App\Config\ScopeConfigInterface</code> 来实现的。</p> <p>通过查 di.xml 可以发现<br /> <code>&lt;preference for="Magento\Framework\App\Config\ScopeConfigInterface" type="Magento\Framework\App\Config" /&gt;</code><br /> 所以实际注入的是 <code>Magento\Framework\App\Config</code></p> <h3 id="标准用法"><a href="#标准用法" name="标准用法"></a>标准用法</h3> <p>在构造函数中注入 <code>\Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig</code> 并设置 <code>$this-&gt;scopeConfig = $scopeConfig;</code></p> <p>我们就可以通过</p> <pre><code>$this-&gt;scopeConfig-&gt;getValue('helloworld/general/enable', \Magento\Store\Model\ScopeInterface::SCOPE_STORE); </code></pre> <p>来取得 <code>helloworld/general/enable</code> 的设置值。</p> <h3 id="通过-helper-来取得配置值"><a href="#通过-helper-来取得配置值" name="通过-helper-来取得配置值"></a>通过 helper 来取得配置值</h3> <p>File: ThankIT/HelloWorld/Helper/Data.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Helper;  use Magento\Framework\App\Helper\AbstractHelper; use Magento\Framework\App\Helper\Context; use Magento\Store\Model\ScopeInterface;  class Data extends AbstractHelper {      const XML_PATH_HELLOWORLD = 'helloworld/general/';      public function __construct(Context $context)     {         parent::__construct($context);     }      public function getConfigValue($field, $storeId = null)     {         return $this-&gt;scopeConfig-&gt;getValue(             $field, ScopeInterface::SCOPE_STORE, $storeId         );     }      public function getGeneralConfig($code, $storeId = null)     {         return $this-&gt;getConfigValue(self::XML_PATH_HELLOWORLD . $code, $storeId);     }  } </code></pre> <p>File: app\code\ThankIT\HelloWorld\view\frontend\templates\index\index.phtml</p> <pre><code>&lt;hr&gt; &lt;h3&gt;get configuration value by helper file&lt;/h3&gt; &lt;?php $helper = $this-&gt;helper('ThankIT\HelloWorld\Helper\Data'); echo $helper-&gt;getConfigValue('helloworld/general/display_text'); echo '&lt;br/&gt;'; echo $helper-&gt;getGeneralConfig('display_text'); </code></pre> <p>结果：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/get-configuration-value-by-helper-file.png" alt="get-configuration-value-by-helper-file" /></p> <p><em><br /> 关于 helper<br /> Helpers are classes that can be used anywhere we want,we can use them in controllers,views,modeles and even in other helpers. Helpers are usually created to provide methods for a common functionality. 它一般位于 /Helper 目录下，常用的文件名是 Data.php<br /> 它继承自 <code>Magento\Framework\App\Helper\AbstractHelper</code><br /> </em></p> <p>因为他的父类已经注入了<code>\Magento\Framework\App\Config\ScopeConfigInterface</code> 所以我们可以在 helper 中使用 <code>$this-&gt;scopeConfig-&gt;getValue()</code> 来获得配置值。</p> <p>在 block 中我们可以通过 <code>$this-&gt;helper('{Vendor}\{Module}\Helper\Data');</code> 来获得 helper 。注意，此处一定是右斜杠。path 是左斜杠。</p> <h2 id="参考文档"><a name="参考文档" href="#参考文档"></a>参考文档</h2> <p><a href="https://www.mageplaza.com/magento-2-module-development/create-system-xml-configuration-magento-2.html" target="_blank">Magento 2 How to Create System.xml Configuration</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-admin-acl-access-control-lists/]]></link>
		<title><![CDATA[Magento 2 Admin ACL Access Control Lists]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>Magento 2 Admin ACL 用来创建访问权限列表（Access Controller List Rules）。管理员可以创建不同的角色，给角色分配权限，给后台用户赋予角色，从而控制后台用户的访问权限。本文将介绍 ACL 是如何工作的以及如何给自己的模块添加 ACL。</p> <p>acl.xml is used for backend actions protection and web Api.</p> <p>后台访问 <code>System &gt; Permissions &gt; User Roles</code><br /> 我们点击 <strong>Add New Role</strong> 或者点击某个角色，就会看到类似下图的界面：</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/09/role-resources.png" alt="Role Resources" /></p> <p>对于某个后台用户来讲，他只能访问他的角色所拥有的 resources ，没有的看都看不到。</p> <h2 id="创建-acl-rule"><a href="#创建-acl-rule" name="创建-acl-rule"></a>创建 ACL rule</h2> <p>以之前的 <code>ThankIT_HelloWorld</code> 模块为基础。</p> <p>File:app/code/ThankIT/HelloWorld/etc/acl.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Acl/etc/acl.xsd"&gt;      &lt;acl&gt;         &lt;resources&gt;             &lt;resource id="Magento_Backend::admin"&gt;                 &lt;resource id="ThankIT_HelloWorld::helloworld" title="Hello World" sortOrder="51"&gt;                     &lt;resource id="ThankIT_HelloWorld::post" title="Posts" sortOrder="10"/&gt;                     &lt;resource id="ThankIT_HelloWorld::helloworld_configuration" title="Configuration" sortOrder="99" /&gt;                 &lt;/resource&gt;                 &lt;resource id="Magento_Backend::stores"&gt;                     &lt;resource id="Magento_Backend::stores_settings"&gt;                         &lt;resource id="Magento_Config::config"&gt;                             &lt;resource id="ThankIT_HelloWorld::hello_configuration" title="Hello World"/&gt;                         &lt;/resource&gt;                     &lt;/resource&gt;                 &lt;/resource&gt;             &lt;/resource&gt;         &lt;/resources&gt;     &lt;/acl&gt; &lt;/config&gt; </code></pre> <p>Our resource will be placed as child of Magento_Backend::admin. Each resource will have an Id, title and sortOrder attribute:</p> <ul> <li>Id attribute is the identify of this resource. You can use this when define resource in Admin menu, configuration and limit access to your module controller. This is a unique string and should be in this format: Vendor_ModuleName::resource_name.</li> <li>Title attribute is the label of this resource when showing in resource tree.</li> <li>sortOrder attribute define the position of this resource in tree.</li> </ul> <p>刷新缓存，我们可以看到原来的 ACL 添加了一些东西：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/acl-helloworld.png" alt="acl" /></p> <h2 id="验证"><a href="#验证" name="验证"></a>验证</h2> <p>之前文章中我们的 <code>system.xml</code> 中有相关的 resource 引用：</p> <p>File：app/code/ThankIT/HelloWorld/etc/adminhtml/system.xml</p> <pre><code>&lt;section id="helloworld" translate="label" sortOrder="130" showInDefault="1" showInWebsite="1" showInStore="1"&gt;         ….             &lt;resource&gt;ThankIT_HelloWorld::hello_configuration&lt;/resource&gt;         …. &lt;/section&gt; </code></pre> <p>我们新建一个 test 后台用户，一个 test 角色，角色权限仅勾选上图中的 stores 下的 Hello Wolrd （第二个，不是第一个）。然后我们以 test 用户登录，发现我们可以访问 configuration 中 Hello World Section ，如果不够选的话，看也看不到。</p> <h3 id="admin-controller-中检查权限"><a href="#admin-controller-中检查权限" name="admin-controller-中检查权限"></a>Admin Controller 中检查权限</h3> <p>Admin Controller 中通过覆写 <code>_isAllowed()</code> 来检查权限。<br /> 比如 File: vendor/magento/module-customer/Controller/Adminhtml/Index.php</p> <pre><code>protected function _isAllowed() {  return $this-&gt;_authorization-&gt;isAllowed('Magento_Customer::manage'); } </code></pre> <p>因为 Admin Controller 继承自 <code>\Magento\Backend\App\Action</code> 它又继承自 <code>\Magento\Backend\App\AbstractAction</code> 这样可以追查到 <code>$this-&gt;_authorization</code> 是 <code>Magento\Framework\AuthorizationInterface</code></p> <p>File:Magento\Backend\App\AbstractAction.php</p> <pre><code>const ADMIN_RESOURCE = 'Magento_Backend::admin';     /**      * @return bool      */     protected function _isAllowed()     {         return $this-&gt;_authorization-&gt;isAllowed(static::ADMIN_RESOURCE);     } </code></pre> <h4 id="static"><a href="#static" name="static"></a>static</h4> <pre><code>&lt;?php class A {     const ADMIN_RESOURCE = 'Magento_Backend::admin';     public function getResource()     {         echo static::ADMIN_RESOURCE;         echo self::ADMIN_RESOURCE;     } }  class B extends A {     const ADMIN_RESOURCE = 'B'; }  $b = new B(); $b-&gt;getResource();  // 输出 B // 输出 Magento_Backend::admin </code></pre> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="https://www.mageplaza.com/magento-2-module-development/magento-2-acl-access-control-lists.html" target="_blank" rel="noopener">Magento 2 Admin ACL Access Control Lists</a><br /> <a href="https://magento.stackexchange.com/questions/93840/how-does-magento2-access-control-list-work" target="_blank" rel="noopener">How does Magento2 Access Control List work?</a><br /> <a href="http://alanstorm.com/magento_2_understanding_access_control_list_rules/" target="_blank" rel="noopener">Magento 2: Understanding Access Control List Rules</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-create-admin-menu/]]></link>
		<title><![CDATA[Magento 2 Create Admin Menu]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇我们将介绍如何创建 Admin menu 。</p> <p>Admin menu 看起来就是这样：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/admin-menu.png" alt="admin menu" /></p> <p>他是有层次的。可以分成三级，最左侧大类的 Sales ，然后是分组 Operation ，然后是 Orders 和 invoice 等。</p> <p>我们来看 orders 的链接结构：</p> <pre><code>http://example/admin/sales/order/index/key/9118b14253fc71837e2b0d7ea73c818b63d1401ebd1f04f310486d985f3e6d57/ </code></pre> <p>和前台的 url 结构相比较，他多出了 <code>admin</code> 和后面的 <code>/key/118b14253fc71837e2b0d7ea73c818b63d1401ebd1f04f310486d985f3e6d57/</code></p> <p>key 是为了防止跨站脚本攻击（cross site script attacks）</p> <p>后台的 url 结构就是(看到的)</p> <pre><code>admin/front-name/controller-name/action </code></pre> <p>如果引用则是</p> <pre><code>admin/front-id/controller-name/action </code></pre> <h2 id="创建-menu.xml"><a href="#创建-menu.xml" name="创建-menu.xml"></a>创建 menu.xml</h2> <p>File:app/code/ThankIT/HelloWorld/etc/adminhtml/menu.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Backend:etc/menu.xsd"&gt;     &lt;menu&gt;        &lt;add id="ThankIT_HelloWorld::helloworld" title="Hello World" module="ThankIT_HelloWorld" sortOrder="51" resource="ThankIT_HelloWorld::helloworld"/&gt;        &lt;add id="ThankIT_HelloWorld::post" title="Posts" module="ThankIT_HelloWorld" sortOrder="10" action="thankit_helloworld/post/index" resource="ThankIT_HelloWorld::post" parent="ThankIT_HelloWorld::helloworld"/&gt;        &lt;add id="ThankIT_HelloWorld::helloworld_configuration" title="Configuration" module="ThankIT_HelloWorld" sortOrder="99" parent="ThankIT_HelloWorld::helloworld" action="adminhtml/system_config/edit/section/helloworld" resource="ThankIT_HelloWorld::helloworld_configuration"/&gt;     &lt;/menu&gt; &lt;/config&gt; </code></pre> <p>注意 <code>action="adminhtml/system_config/edit/section/helloworld"</code> 此处使用的是 <code>adminhtml</code> 而不是 <code>admin</code> 尽管我们看到的是 <code>admin</code> 。</p> <ul> <li>The id attribute is the identifier for this note. It’s a unique string and should follow the format: {Vendor_ModuleName}::{menu_description}.</li> <li>The title attribute is the text which will be shown on the menu bar.</li> <li>The module attribute is defined the module which this menu is belong to.</li> <li>The sortOrder attribute is defined the position of the menu. Lower value will display on top of menu.</li> <li>The parent attribute is an Id of other menu node. It will tell Magento that this menu is a child of another menu. In this example, we have parent=”ThankIT_HelloWorld::helloworld”, so we &#8211; know this menu “Posts” is a child of “Hello World” menu and it will show inside of Hello World menu.</li> <li>The action attribute will define the url of the page which this menu link to. As we talk above, the url will be followed this format {router_name}{controller_folder}{action_name}.</li> <li>The resource attribute is used to defined the ACL rule which the admin user must have in order to see and access this menu. We will find more detail about ACL in other topic.</li> </ul> <p>关于最左侧的大类的 icon 请参考<a href="http://devdocs.magento.com/guides/v2.1/pattern-library/graphics/iconography/iconography.html">Magento Admin Pattern Library-Iconography</a></p> <p>效果如下<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09//menu-效果.png" alt="menu效果" /></p> <p>这里只有两层结构，下面看下三层的结构：</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;!-- /**  * Copyright © 2013-2017 Magento, Inc. All rights reserved.  * See COPYING.txt for license details.  */ --&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Backend:etc/menu.xsd"&gt;     &lt;menu&gt;         &lt;add id="Magento_Sales::sales" title="Sales" translate="title" module="Magento_Sales" sortOrder="15" dependsOnModule="Magento_Sales" resource="Magento_Sales::sales"/&gt;         &lt;add id="Magento_Sales::sales_operation" title="Operations" translate="title" module="Magento_Sales" sortOrder="10" parent="Magento_Sales::sales" resource="Magento_Sales::sales_operation" /&gt;         &lt;add id="Magento_Sales::sales_order" title="Orders" translate="title" module="Magento_Sales" sortOrder="10" parent="Magento_Sales::sales_operation" action="sales/order" resource="Magento_Sales::sales_order"/&gt;         &lt;add id="Magento_Sales::sales_invoice" title="Invoices" translate="title" module="Magento_Sales" sortOrder="20" parent="Magento_Sales::sales_operation" action="sales/invoice" resource="Magento_Sales::sales_invoice"/&gt;         ....     &lt;/menu&gt; &lt;/config&gt; </code></pre> <p>对应第一张的图片。</p> <h2 id="参考文档"><a name="参考文档" href="#参考文档"></a>参考文档</h2> <p><a href="https://www.mageplaza.com/magento-2-module-development/create-admin-menu-magento-2.html" target="_blank">Magento 2 Create Admin Menu</a><br /><a href="http://alanstorm.com/magento_2_admin_menu_items/" target="_blank">Magento 2: Admin Menu Items</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/layout-instruction-%E4%B9%8B-argument-%E5%92%8C-action/]]></link>
		<title><![CDATA[Layout instruction 之 argument 和 action]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇我们将通过一个 demo 来演示如何使用 layout 指令 ——— argument 和 action 。</p> <p>本篇基于 <a href="https://www.hellomagento2.com/%E5%88%9B%E5%BB%BA-magento-2-hello-world-simple-module/" target="_blank" rel="noopener">创建 Magento 2 Hello World Simple Module</a> 文章中的简单模块。</p> <h2 id="创建-controller"><a href="#创建-controller" name="创建-controller"></a>创建 Controller</h2> <p>File:app\code\ThankIT\HelloWorld\Controller\Layout\Instruction.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Layout;  class Instruction extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         return $this-&gt;resultPageFactory-&gt;create();     } } </code></pre> <h2 id="创建-layout"><a href="#创建-layout" name="创建-layout"></a>创建 layout</h2> <p>File:app\code\ThankIT\HelloWorld\view\frontend\layout\helloworld_layout_instruction.xml</p> <pre><code>&lt;?xml version="1.0" ?&gt; &lt;page layout="1column" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;      &lt;body&gt;         &lt;referenceContainer name="content"&gt;             &lt;block class="ThankIT\HelloWorld\Block\Layout\Instruction" name="layout.instruction" template="ThankIT_HelloWorld::layout/instruction.phtml"&gt;                 &lt;arguments&gt;                     &lt;argument name="label" xsi:type="string"&gt;Block Label&lt;/argument&gt;                 &lt;/arguments&gt;                 &lt;action method="doSomething"&gt;                     &lt;argument translate="true" name="thing" xsi:type="string"&gt;Running&lt;/argument&gt;                 &lt;/action&gt;             &lt;/block&gt;         &lt;/referenceContainer&gt;     &lt;/body&gt; &lt;/page&gt; </code></pre> <h2 id="创建-block"><a href="#创建-block" name="创建-block"></a>创建 Block</h2> <p>File:app\code\ThankIT\HelloWorld\Block\Layout\Instruction.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Block\Layout;  use Magento\Framework\View\Element\Template;  class Instruction extends Template {     public function doSomething($thing)     {         // do something ...         $this-&gt;setData('some_thing', $thing);     } } </code></pre> <h2 id="创建-view"><a href="#创建-view" name="创建-view"></a>创建 view</h2> <p>File:app\code\ThankIT\HelloWorld\view\frontend\templates\layout\instruction.phtml</p> <pre><code>&lt;?php echo $block-&gt;getLabel();?&gt; &lt;?php //等价于//echo $block-&gt;getData('label');?&gt; &lt;br/&gt; &lt;?php echo $block-&gt;getSomeThing();?&gt; </code></pre> <h2 id="测试"><a href="#测试" name="测试"></a>测试</h2> <p>刷新缓存后，访问 <code>http://example/helloworld/layout/instruction/</code></p> <p>会看到：</p> <p><img class="img-responsive" src="/wp-content/uploads/2017/09/layout-instruction-argument-action.png" alt="layout-instruction-argument-action" /></p> <h2 id="注意点"><a href="#注意点" name="注意点"></a>注意点</h2> <h3 id="use-block-object-methods-to-set-block-properties"><a href="#use-block-object-methods-to-set-block-properties" name="use-block-object-methods-to-set-block-properties"></a>Use block object methods to set block properties</h3> <p>There are two ways to access block object methods:</p> <ul> <li>using the <code>&lt;argument&gt;</code> instruction for <code>&lt;block&gt;</code> or <code>&lt;referenceBlock&gt;</code></li> <li>using the <code>&lt;action&gt;</code> instruction. This way is not recommended, but can be used for calling those methods, which are not refactored yet to be accessed through <code>&lt;argument&gt;</code>.</li> </ul> <p><em>Do not use <code>&lt;action&gt;</code>, if the method implementation allows calling it using <code>&lt;argument&gt;</code> for <code>&lt;block&gt;</code> or <code>&lt;referenceBlock&gt;</code>.</em></p> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="http://devdocs.magento.com/guides/v2.0/frontend-dev-guide/layouts/xml-manage.html" target="_blank" rel="noopener">Common layout customization tasks</a><br /> <a href="http://devdocs.magento.com/guides/v2.0/frontend-dev-guide/layouts/xml-instructions.html#argument" target="_blank" rel="noopener">Layout instructions</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-javascript-init-ways/]]></link>
		<title><![CDATA[<code>&lt;script type="text/x-magento-init"&gt;</code>]]></title>
		<content><![CDATA[]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-and-konockoutjs/]]></link>
		<title><![CDATA[Magento 2 and konockoutjs]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>本篇将通过实验来介绍 ko 的模版绑定、自定义绑定和组件绑定，然后在此基础上介绍 magento 2 对 ko 的扩展。最后通过一个例子来介绍如何在 magento 2 中使用 ko 绑定。</p> <h2 id="准备"><a href="#准备" name="准备"></a>准备</h2> <p>在 <code>ThankIT_HelloWorld</code> 模块的基础上，我们来创建一个页面，用来做实验。</p> <p>File: app\code\ThankIT\HelloWorld\Controller\Knockoutjs\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Knockoutjs;  class Index extends \Magento\Framework\App\Action\Action {      protected $resultPageFactory;      /**      * Constructor      *      * @param \Magento\Framework\App\Action\Context  $context      * @param \Magento\Framework\View\Result\PageFactory $resultPageFactory      */     public function __construct(         \Magento\Framework\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         $this-&gt;resultPageFactory = $resultPageFactory;         parent::__construct($context);     }      /**      * Execute view action      *      * @return \Magento\Framework\Controller\ResultInterface      */     public function execute()     {         return $this-&gt;resultPageFactory-&gt;create();     } } </code></pre> <p>File:app\code\ThankIT\HelloWorld\view\frontend\layout\helloworld_knockoutjs_index.xml</p> <pre><code>&lt;?xml version="1.0" ?&gt; &lt;page layout="1column" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:View/Layout/etc/page_configuration.xsd"&gt;     &lt;body&gt;         &lt;referenceContainer name="content"&gt;             &lt;block class="ThankIT\HelloWorld\Block\Knockoutjs\Index" name="knockoutjs.index" template="ThankIT_HelloWorld::knockoutjs/index.phtml"/&gt;         &lt;/referenceContainer&gt;     &lt;/body&gt; &lt;/page&gt; </code></pre> <p>File:app\code\ThankIT\HelloWorld\Block\Knockoutjs\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Block\Knockoutjs;  use Magento\Framework\View\Element\Template;  class Index extends Template {  } </code></pre> <p>File:app\code\ThankIT\HelloWorld\view\frontend\templates\knockoutjs\index.phtml</p> <pre><code>&lt;p&gt;First name: &lt;strong data-bind="text:firstName"&gt;todo&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Last name: &lt;strong data-bind="text:lastName"&gt;todo&lt;/strong&gt;&lt;/p&gt; </code></pre> <p><em>注意：Magento 2 的 js 框架部分变化比较频繁，2.0 和 2.1 之间有较大差异，本文使用的是 2.1.7</em></p> <p>然后我们清空缓存，刷新页面，打开调试面板，会看到：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/ko-uncaught-reference-error.png" alt="ko" /></p> <p>假设我们在普通的页面中，我们尚未应用 <code>ko.applyBindings(obj)</code>，那么 <code>data-bind</code> 应该被浏览器忽略，我们是不会看到这样的错误的。</p> <p>所以 Magento 2 页面中自动调用了 <code>ko.applyBindings(obj)</code></p> <p>调用 <code>ko.applyBindings()</code> 部分的实现位于 <code>Magento_Ui/js/lib/knockout/bootstrap</code> 具体的文件位置位于 <code>vendor\magento\module-ui\view\base\web\js\lib\knockout\bootstrap.js</code>，文件内容如下：</p> <pre><code>/**  * Copyright © 2013-2017 Magento, Inc. All rights reserved.  * See COPYING.txt for license details.  */ /** Loads all available knockout bindings, sets custom template engine, initializes knockout on page */  define([     'ko',     './template/engine',     'knockoutjs/knockout-es5',     './bindings/bootstrap',     './extender/observable_array',     './extender/bound-nodes',     'domReady!' ], function (ko, templateEngine) {     'use strict';      ko.uid = 0;      ko.setTemplateEngine(templateEngine);     ko.applyBindings(); }); </code></pre> <p>至于他是怎样实现页面加载后，自动调用 <code>ko.applyBindings()</code> 的，此处先挖坑，留着以后填。</p> <p>这里先明白，Magento 2 对 ko 做了自定义，他会让 ko 自动进行初始化。</p> <h2 id="template-binding"><a href="#template-binding" name="template-binding"></a>template binding</h2> <p>我们先来看一个 ko 的模版绑定，看看 ko 原来的用法是怎样的。</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;ko&lt;/title&gt;     &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Participants&lt;/h2&gt; Here are the participants: &lt;div data-bind="template: { name: 'person-template', data: buyer }"&gt;&lt;/div&gt; &lt;div data-bind="template: { name: 'person-template', data: seller }"&gt;&lt;/div&gt; &lt;script type="text/html" id="person-template"&gt;     &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt;     &lt;p&gt;Credits: &lt;span data-bind="text: credits"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt;      function MyViewModel() {          this.buyer = { name: 'Franklin', credits: 250 };          this.seller = { name: 'Mario', credits: 5800 };      }      ko.applyBindings(new MyViewModel()); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; </code></pre> <p>效果：<br /> <img class="img-resoponsive" src="/wp-content/uploads/2017/09/template-binding.png" alt="ko 模版绑定" /></p> <p>下面我们来看看 Magento 2 对 ko 模版引擎的改造后的用法。<br /> 将 phtml 改成以下内容：<br /> File:app\code\ThankIT\HelloWorld\view\frontend\templates\knockoutjs\index.phtml</p> <pre><code>&lt;div data-bind="template:'ThankIT_HelloWorld/hello'"&gt;&lt;/div&gt; </code></pre> <p>然后我们创建以下文件：<br /> File:app\code\ThankIT\HelloWorld\view\frontend\web\template\hello.html</p> <pre><code>&lt;p data-bind="style:{color:'red'}"&gt;Hello World&lt;/p&gt; </code></pre> <p>然后我们刷新页面，效果如下：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/magento2-ko-template-engine.png" alt="m2 模版引擎" /></p> <p>Magento 2 对 ko 模版引擎的改造让我们不需要用 <code>&lt;script type="text/html"&gt;</code> 来声明模版，把模版也从 <code>phtml</code> 文件中分离到独立的 <code>html</code> 文件中，有利于模版的复用。</p> <h2 id="ko-自定义绑定"><a href="#ko-自定义绑定" name="ko-自定义绑定"></a>ko 自定义绑定</h2> <p>我们先来看看 ko 的自定义绑定是怎样的：</p> <pre><code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;     &lt;title&gt;ko&lt;/title&gt;     &lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-min.js"&gt;&lt;/script&gt;     &lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;label&gt;&lt;input type="checkbox" data-bind="checked: giftWrap" /&gt; Gift wrap&lt;/label&gt; &lt;div data-bind="slideVisible: giftWrap, slideDuration:600, test:'just for test'"&gt;You have selected the option&lt;/div&gt; &lt;script type="text/javascript"&gt;     var viewModel = {         giftWrap: ko.observable(true)     };     ko.bindingHandlers.slideVisible = {     update: function(element, valueAccessor, allBindings) {         // console.log(element);         // First get the latest data that we're bound to         var value = valueAccessor();         // console.log(value);         // Next, whether or not the supplied model property is observable, get its current value         var valueUnwrapped = ko.unwrap(value);         // console.log(valueUnwrapped);         // console.log(allBindings);         // Grab some more data from another binding property         var duration = allBindings.get('slideDuration') ]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/how-to-create-admin-grid-in-magento-2/]]></link>
		<title><![CDATA[How to Create Admin Grid in Magento 2]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>Admin Grid 是一种表格，用来展示数据库表中的记录，附带一些额外的特性：排序、筛选、删除更新等。Admin Grid 的创建有两种方式：使用 layout 和使用 component 。本篇是利用 component 创建的 Admin Grid 。</p> <p>文章中涉及的内容太多了，还有很多地方可以分解和完善，先发出来，作为初探，或者是索引以供后续研究。</p> <h2 id="前提"><a href="#前提" name="前提"></a>前提</h2> <p>以 <code>ThankIT_HelloWorld</code> 模块为基础，已经通过 InstallSchema 添加了数据表，创建了 Admin Menu 和 ACL</p> <p>如果没有，参考以下文章：<br /> <a href="/crud-models-in-magento-2" target="_blank">CRUD Models in Magento 2</a><br /> <a href="/magento-2-create-admin-menu" target="_blank">Magento 2 Create Admin Menu</a><br /> <a href="/magento-2-admin-acl-access-control-lists" target="_blank">Magento 2 Admin ACL Access Control Lists</a></p> <p>我们的 admin menu 创建了一个后台 path</p> <pre><code>thankit_helloworld/post/index </code></pre> <h2 id="创建-routes.xml"><a href="#创建-routes.xml" name="创建-routes.xml"></a>创建 routes.xml</h2> <p>File: app\code\ThankIT\HelloWorld\etc\adminhtml\routes.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../lib/internal/Magento/Framework/App/etc/routes.xsd"&gt;     &lt;router id="admin"&gt;         &lt;route id="thankit_helloworld" frontName="thankit_helloworld"&gt;             &lt;module name="ThankIT_HelloWorld" after="Magento_Backend"/&gt;         &lt;/route&gt;     &lt;/router&gt; &lt;/config&gt; </code></pre> <h2 id="创建-controller"><a href="#创建-controller" name="创建-controller"></a>创建 controller</h2> <p>File:app\code\ThankIT\HelloWorld\Controller\Adminhtml\Post\Index.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Controller\Adminhtml\Post;  class Index extends \Magento\Backend\App\Action {     const ADMIN_RESOURCE = 'ThankIT_HelloWorld::post';     protected $resultPageFactory;     public function __construct(         \Magento\Backend\App\Action\Context $context,         \Magento\Framework\View\Result\PageFactory $resultPageFactory     ) {         parent::__construct($context);         $this-&gt;resultPageFactory = $resultPageFactory;     }      public function execute()     {         $page = $this-&gt;resultPageFactory-&gt;create();         // var_dump(get_class($page));         // 'Magento\Backend\Model\View\Result\Page\Interceptor' (length=50)         // 如果没有下面这句，title 是 Magento Admin ，active menu 正常         // 如果下面这句的 id 不存在，则 active menu 不正常 title 还是 Magento Admin         $page-&gt;setActiveMenu('ThankIT_HelloWorld::post');         // title 替换成 Posts         $page-&gt;getConfig()-&gt;getTitle()-&gt;prepend((__('Posts')));          // class: Magento\Backend\Model\View\Result\Page         // addBreadcrumb($label, $title, $link = null)         $page-&gt;addBreadcrumb(__('ThankIT'), __('ThankIT'));         $page-&gt;addBreadcrumb(__('Hello World'), __('Manage Blogs'));         return $page;     }  } </code></pre> <h2 id="创建-layout"><a href="#创建-layout" name="创建-layout"></a>创建 layout</h2> <p>File: app\code\ThankIT\HelloWorld\view\adminhtml\layout\thankit_helloworld_post_index.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../../../lib/internal/Magento/Framework/View/Layout/etc/page_configuration.xsd"&gt;     &lt;update handle="styles"/&gt;     &lt;body&gt;         &lt;referenceContainer name="content"&gt;             &lt;uiComponent name="thankit_helloworld_post_listing"/&gt;         &lt;/referenceContainer&gt;     &lt;/body&gt; &lt;/page&gt; </code></pre> <p>注意我们这里声明的 <code>uiComponent name="thankit_helloworld_post_listing"</code></p> <h2 id="创建-component-layout-file"><a href="#创建-component-layout-file" name="创建-component-layout-file"></a>创建 component layout file</h2> <p>File:app/code/ThankIT/HelloWorld/view/adminhtml/ui_component/thankit_helloworld_post_listing.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd"&gt;     &lt;argument name="data" xsi:type="array"&gt;         &lt;item name="js_config" xsi:type="array"&gt;             &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing_data_source&lt;/item&gt;             &lt;item name="deps" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing_data_source&lt;/item&gt;         &lt;/item&gt;         &lt;item name="spinner" xsi:type="string"&gt;thankit_helloworld_post_columns&lt;/item&gt;         &lt;item name="buttons" xsi:type="array"&gt;             &lt;item name="add" xsi:type="array"&gt;                 &lt;item name="name" xsi:type="string"&gt;add&lt;/item&gt;                 &lt;item name="label" xsi:type="string" translate="true"&gt;Add New Post&lt;/item&gt;                 &lt;item name="class" xsi:type="string"&gt;primary&lt;/item&gt;                 &lt;item name="url" xsi:type="string"&gt;*/*/new&lt;/item&gt;             &lt;/item&gt;         &lt;/item&gt;     &lt;/argument&gt;     &lt;dataSource name="thankit_helloworld_post_listing_data_source"&gt;         &lt;argument name="dataProvider" xsi:type="configurableObject"&gt;             &lt;!-- &lt;argument name="class" xsi:type="string"&gt;ThankITHelloWorldPostGridDataProvider&lt;/argument&gt; --&gt;             &lt;argument name="class" xsi:type="string"&gt;Magento\Framework\View\Element\UiComponent\DataProvider\DataProvider&lt;/argument&gt;             &lt;argument name="name" xsi:type="string"&gt;thankit_helloworld_post_listing_data_source&lt;/argument&gt;             &lt;argument name="primaryFieldName" xsi:type="string"&gt;post_id&lt;/argument&gt;             &lt;argument name="requestFieldName" xsi:type="string"&gt;post_id&lt;/argument&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="update_url" xsi:type="url" path="mui/index/render"/&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/argument&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="js_config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/provider&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/dataSource&gt;     &lt;container name="listing_top"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="template" xsi:type="string"&gt;ui/grid/toolbar&lt;/item&gt;                 &lt;item name="stickyTmpl" xsi:type="string"&gt;ui/grid/sticky/toolbar&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;         &lt;bookmark name="bookmarks"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="storageConfig" xsi:type="array"&gt;                         &lt;item name="namespace" xsi:type="string"&gt;thankit_helloworld_post_listing&lt;/item&gt;                     &lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/bookmark&gt;         &lt;component name="columns_controls"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="columnsData" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns&lt;/item&gt;                     &lt;/item&gt;                     &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/controls/columns&lt;/item&gt;                     &lt;item name="displayArea" xsi:type="string"&gt;dataGridActions&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/component&gt;         &lt;exportButton name="export_button"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="selectProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns.ids&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/exportButton&gt;         &lt;filterSearch name="fulltext"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing_data_source&lt;/item&gt;                     &lt;item name="chipsProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.listing_filters_chips&lt;/item&gt;                     &lt;item name="storageConfig" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.bookmarks&lt;/item&gt;                         &lt;item name="namespace" xsi:type="string"&gt;current.search&lt;/item&gt;                     &lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/filterSearch&gt;         &lt;filters name="listing_filters"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="columnsProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns&lt;/item&gt;                     &lt;item name="storageConfig" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.bookmarks&lt;/item&gt;                         &lt;item name="namespace" xsi:type="string"&gt;current.filters&lt;/item&gt;                     &lt;/item&gt;                     &lt;item name="templates" xsi:type="array"&gt;                         &lt;item name="filters" xsi:type="array"&gt;                             &lt;item name="select" xsi:type="array"&gt;                                 &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/form/element/ui-select&lt;/item&gt;                                 &lt;item name="template" xsi:type="string"&gt;ui/grid/filters/elements/ui-select&lt;/item&gt;                             &lt;/item&gt;                         &lt;/item&gt;                     &lt;/item&gt;                     &lt;item name="childDefaults" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.listing_filters&lt;/item&gt;                         &lt;item name="imports" xsi:type="array"&gt;                             &lt;item name="visible" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns.${ $.index }:visible&lt;/item&gt;                         &lt;/item&gt;                     &lt;/item&gt;                 &lt;/item&gt;                 &lt;item name="observers" xsi:type="array"&gt;                     &lt;item name="column" xsi:type="string"&gt;column&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/filters&gt;         &lt;massaction name="listing_massaction"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="selectProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns.ids&lt;/item&gt;                     &lt;item name="indexField" xsi:type="string"&gt;post_id&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;             &lt;action name="delete"&gt;                 &lt;argument name="data" xsi:type="array"&gt;                     &lt;item name="config" xsi:type="array"&gt;                         &lt;item name="type" xsi:type="string"&gt;delete&lt;/item&gt;                         &lt;item name="label" xsi:type="string" translate="true"&gt;Delete&lt;/item&gt;                         &lt;item name="url" xsi:type="url" path="thankit_helloworld/post/massDelete"/&gt;                         &lt;item name="confirm" xsi:type="array"&gt;                             &lt;item name="title" xsi:type="string" translate="true"&gt;Delete Posts&lt;/item&gt;                             &lt;item name="message" xsi:type="string" translate="true"&gt;Are you sure you wan't to delete selected Posts?&lt;/item&gt;                         &lt;/item&gt;                     &lt;/item&gt;                 &lt;/argument&gt;             &lt;/action&gt;             &lt;action name="edit"&gt;                 &lt;argument name="data" xsi:type="array"&gt;                     &lt;item name="config" xsi:type="array"&gt;                         &lt;item name="type" xsi:type="string"&gt;edit&lt;/item&gt;                         &lt;item name="label" xsi:type="string" translate="true"&gt;Edit&lt;/item&gt;                         &lt;item name="callback" xsi:type="array"&gt;                             &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns_editor&lt;/item&gt;                             &lt;item name="target" xsi:type="string"&gt;editSelected&lt;/item&gt;                         &lt;/item&gt;                     &lt;/item&gt;                 &lt;/argument&gt;             &lt;/action&gt;         &lt;/massaction&gt;         &lt;paging name="listing_paging"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="storageConfig" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.bookmarks&lt;/item&gt;                         &lt;item name="namespace" xsi:type="string"&gt;current.paging&lt;/item&gt;                     &lt;/item&gt;                     &lt;item name="selectProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns.ids&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/paging&gt;     &lt;/container&gt;     &lt;columns name="thankit_helloworld_post_columns"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="storageConfig" xsi:type="array"&gt;                     &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.bookmarks&lt;/item&gt;                     &lt;item name="namespace" xsi:type="string"&gt;current&lt;/item&gt;                 &lt;/item&gt;                 &lt;item name="editorConfig" xsi:type="array"&gt;                     &lt;item name="selectProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns.ids&lt;/item&gt;                     &lt;item name="enabled" xsi:type="boolean"&gt;true&lt;/item&gt;                     &lt;item name="indexField" xsi:type="string"&gt;post_id&lt;/item&gt;                     &lt;item name="clientConfig" xsi:type="array"&gt;                         &lt;item name="saveUrl" xsi:type="url" path="thankit_helloworld/post/inlineEdit"/&gt;                         &lt;item name="validateBeforeSave" xsi:type="boolean"&gt;false&lt;/item&gt;                     &lt;/item&gt;                 &lt;/item&gt;                 &lt;item name="childDefaults" xsi:type="array"&gt;                     &lt;item name="fieldAction" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns_editor&lt;/item&gt;                         &lt;item name="target" xsi:type="string"&gt;startEdit&lt;/item&gt;                         &lt;item name="params" xsi:type="array"&gt;                             &lt;item name="0" xsi:type="string"&gt;${ $.$data.rowIndex }&lt;/item&gt;                             &lt;item name="1" xsi:type="boolean"&gt;true&lt;/item&gt;                         &lt;/item&gt;                     &lt;/item&gt;                     &lt;item name="storageConfig" xsi:type="array"&gt;                         &lt;item name="provider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top.bookmarks&lt;/item&gt;                         &lt;item name="root" xsi:type="string"&gt;columns.${ $.index }&lt;/item&gt;                         &lt;item name="namespace" xsi:type="string"&gt;current.${ $.storageConfig.root}&lt;/item&gt;                     &lt;/item&gt;                 &lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;         &lt;selectionsColumn name="ids"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="resizeEnabled" xsi:type="boolean"&gt;false&lt;/item&gt;                     &lt;item name="resizeDefaultWidth" xsi:type="string"&gt;55&lt;/item&gt;                     &lt;item name="indexField" xsi:type="string"&gt;post_id&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/selectionsColumn&gt;         &lt;column name="post_id"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;textRange&lt;/item&gt;                     &lt;item name="sorting" xsi:type="string"&gt;asc&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;ID&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="name"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;text&lt;/item&gt;                     &lt;item name="editor" xsi:type="array"&gt;                         &lt;item name="editorType" xsi:type="string"&gt;text&lt;/item&gt;                         &lt;item name="validation" xsi:type="array"&gt;                             &lt;item name="required-entry" xsi:type="boolean"&gt;true&lt;/item&gt;                         &lt;/item&gt;                     &lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;Name&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="url_key"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;text&lt;/item&gt;                     &lt;item name="visible" xsi:type="boolean"&gt;false&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;URL Key&lt;/item&gt;                     &lt;item name="dataType" xsi:type="string"&gt;text&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="tags"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;text&lt;/item&gt;                     &lt;item name="visible" xsi:type="boolean"&gt;false&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;Tags&lt;/item&gt;                     &lt;item name="dataType" xsi:type="string"&gt;text&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="status"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="options" xsi:type="object"&gt;Magento\Config\Model\Config\Source\Yesno&lt;/item&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;select&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;Status&lt;/item&gt;                     &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/columns/select&lt;/item&gt;                     &lt;item name="dataType" xsi:type="string"&gt;select&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="sample_country_selection"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="options" xsi:type="object"&gt;Magento\Config\Model\Config\Source\Locale\Country&lt;/item&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;select&lt;/item&gt;                     &lt;item name="visible" xsi:type="boolean"&gt;false&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;Sample Country Selection&lt;/item&gt;                     &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/columns/select&lt;/item&gt;                     &lt;item name="dataType" xsi:type="string"&gt;select&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="created_at" class="Magento\Ui\Component\Listing\Columns\Date"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;dateRange&lt;/item&gt;                     &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/columns/date&lt;/item&gt;                     &lt;item name="dataType" xsi:type="string"&gt;date&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;Created&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;column name="updated_at" class="Magento\Ui\Component\Listing\Columns\Date"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="filter" xsi:type="string"&gt;dateRange&lt;/item&gt;                     &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/columns/date&lt;/item&gt;                     &lt;item name="dataType" xsi:type="string"&gt;date&lt;/item&gt;                     &lt;item name="label" xsi:type="string" translate="true"&gt;Modified&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/column&gt;         &lt;actionsColumn name="actions" class="ThankIT\HelloWorld\Ui\Component\Listing\Column\PostActions"&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="resizeEnabled" xsi:type="boolean"&gt;false&lt;/item&gt;                     &lt;item name="resizeDefaultWidth" xsi:type="string"&gt;107&lt;/item&gt;                     &lt;item name="indexField" xsi:type="string"&gt;post_id&lt;/item&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/actionsColumn&gt;     &lt;/columns&gt;     &lt;container name="sticky"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/grid/sticky/sticky&lt;/item&gt;                 &lt;item name="toolbarProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.listing_top&lt;/item&gt;                 &lt;item name="listingProvider" xsi:type="string"&gt;thankit_helloworld_post_listing.thankit_helloworld_post_listing.thankit_helloworld_post_columns&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/container&gt; &lt;/listing&gt; </code></pre> <p>代码比较长，一段一段来分析。<br /> 我们在 layout 中声明的 listing name 是 <code>thankit_helloworld_post_listing</code></p> <p><img class="img-responsive" src="/wp-content/uploads/2017/09/thankit-helloworld-post-listing.png" alt="thankit-helloworld-post-listing.png" /></p> <p>这里面经常用到的有四个元素，<code>&lt;argument&gt;</code>,<code>&lt;dataSource&gt;</code>,<code>&lt;columns&gt;</code>,<code>&lt;container&gt;</code>,这几个元素间的粗略关系见上图。</p> <p>这个里面声明了一个 dataSource <code>thankit_helloworld_post_listing_data_source</code></p> <h2 id="di.xml"><a href="#di.xml" name="di.xml"></a>di.xml</h2> <p>File: app\code\ThankIT\HelloWorld\etc\di.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../../../lib/internal/Magento/Framework/ObjectManager/etc/config.xsd"&gt;     &lt;type name="Magento\Framework\View\Element\UiComponent\DataProvider\CollectionFactory"&gt;         &lt;arguments&gt;             &lt;argument name="collections" xsi:type="array"&gt;                 &lt;item name="thankit_helloworld_post_listing_data_source" xsi:type="string"&gt;ThankIT\HelloWorld\Model\ResourceModel\Post\Grid\Collection&lt;/item&gt;             &lt;/argument&gt;         &lt;/arguments&gt;     &lt;/type&gt;     &lt;type name="ThankIT\HelloWorld\Model\ResourceModel\Post\Grid\Collection"&gt;         &lt;arguments&gt;             &lt;argument name="mainTable" xsi:type="string"&gt;thankit_helloworld_post&lt;/argument&gt;             &lt;argument name="eventPrefix" xsi:type="string"&gt;thankit_helloworld_post_grid_collection&lt;/argument&gt;             &lt;argument name="eventObject" xsi:type="string"&gt;post_grid_collection&lt;/argument&gt;             &lt;argument name="resourceModel" xsi:type="string"&gt;ThankIT\HelloWorld\Model\ResourceModel\Post&lt;/argument&gt;         &lt;/arguments&gt;     &lt;/type&gt;     &lt;!-- start 这一段可以不要 --&gt;     &lt;!-- &lt;virtualType name="ThankITHelloWorldPostGridDataProvider" type="Magento\Framework\View\Element\UiComponent\DataProvider\DataProvider"&gt;         &lt;arguments&gt;             &lt;argument name="collection" xsi:type="object" shared="false"&gt;ThankIT\HelloWorld\Model\ResourceModel\Post\Collection&lt;/argument&gt;             &lt;argument name="filterPool" xsi:type="object" shared="false"&gt;ThankITHelloWorldGirdFilterPool&lt;/argument&gt;         &lt;/arguments&gt;     &lt;/virtualType&gt;     &lt;virtualType name="ThankITHelloWorldGirdFilterPool" type="Magento\Framework\View\Element\UiComponent\DataProvider\FilterPool"&gt;         &lt;arguments&gt;             &lt;argument name="appliers" xsi:type="array"&gt;                 &lt;item name="regular" xsi:type="object"&gt;Magento\Framework\View\Element\UiComponent\DataProvider\RegularFilter&lt;/item&gt;                 &lt;item name="fulltext" xsi:type="object"&gt;Magento\Framework\View\Element\UiComponent\DataProvider\FulltextFilter&lt;/item&gt;             &lt;/argument&gt;         &lt;/arguments&gt;     &lt;/virtualType&gt; --&gt;     &lt;!-- end 这一段可以不要 --&gt; &lt;/config&gt; </code></pre> <p>其中重要部分如下图：<br /> <img class="img-responsive" src="/wp-content/uploads/2017/09/di.xml_.png" alt="di.xml" /></p> <h2 id="grid-collection"><a href="#grid-collection" name="grid-collection"></a>Grid Collection</h2> <p>File: ThankIT\HelloWorld\Model\ResourceModel\Post\Grid\Collection;</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Model\ResourceModel\Post\Grid;  class Collection extends \ThankIT\HelloWorld\Model\ResourceModel\Post\Collection implements \Magento\Framework\Api\Search\SearchResultInterface {     /**      * Aggregations      *      * @var \Magento\Framework\Search\AggregationInterface      */     protected $_aggregations;      /**      * constructor      *      * @param \Magento\Framework\Data\Collection\EntityFactoryInterface $entityFactory      * @param \Psr\Log\LoggerInterface $logger      * @param \Magento\Framework\Data\Collection\Db\FetchStrategyInterface $fetchStrategy      * @param \Magento\Framework\Event\ManagerInterface $eventManager      * @param $mainTable      * @param $eventPrefix      * @param $eventObject      * @param $resourceModel      * @param $model      * @param $connection      * @param \Magento\Framework\Model\ResourceModel\Db\AbstractDb $resource      */     public function __construct(         \Magento\Framework\Data\Collection\EntityFactoryInterface $entityFactory,         \Psr\Log\LoggerInterface $logger,         \Magento\Framework\Data\Collection\Db\FetchStrategyInterface $fetchStrategy,         \Magento\Framework\Event\ManagerInterface $eventManager,         $mainTable,         $eventPrefix,         $eventObject,         $resourceModel,         $model = 'Magento\Framework\View\Element\UiComponent\DataProvider\Document',         $connection = null,         \Magento\Framework\Model\ResourceModel\Db\AbstractDb $resource = null     ) {         parent::__construct($entityFactory, $logger, $fetchStrategy, $eventManager, $connection, $resource);         $this-&gt;_eventPrefix = $eventPrefix;         $this-&gt;_eventObject = $eventObject;         $this-&gt;_init($model, $resourceModel);         $this-&gt;setMainTable($mainTable);     }      /**      * @return \Magento\Framework\Search\AggregationInterface      */     public function getAggregations()     {         return $this-&gt;_aggregations;     }      /**      * @param \Magento\Framework\Search\AggregationInterface $aggregations      * @return $this      */     public function setAggregations($aggregations)     {         $this-&gt;_aggregations = $aggregations;     }      /**      * Retrieve all ids for collection      * Backward compatibility with EAV collection      *      * @param int $limit      * @param int $offset      * @return array      */     public function getAllIds($limit = null, $offset = null)     {         return $this-&gt;getConnection()-&gt;fetchCol($this-&gt;_getAllIdsSelect($limit, $offset), $this-&gt;_bindParams);     }      /**      * Get search criteria.      *      * @return \Magento\Framework\Api\SearchCriteriaInterface]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-js-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/]]></link>
		<title><![CDATA[Magento 2 JS 开发入门]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>默认情况下，Magento 2 使用 RequireJS （可参考 <a href="https://www.hellomagento2.com/alan-magento-2-and-requirejs/#requirejs-and-jquery-plugins" target="_blank" rel="noopener">Magento 2 and RequireJS (翻译)</a> 和 <a href="https://www.hellomagento2.com/requirejs-modularity-async/" target="_blank" rel="noopener">关于 RequireJS</a>）来异步加载 js 模块，管理模块依赖。在这个大前提下，Magento 2 中使用的主要 JS 库是 jQuery 和 KnockoutJS （简称 ko），还使用了 AngularJS （used for the web based installer）和 Underscore (This provides some useful Javascript functions to manipulate Javascript arrays, functions, objects and collections.)</p> <p>另外 Magento 做了许多自定义的设置，比如对 ko 模版引擎的改造，让我们不需要用 <code>&lt;script type="text/html"&gt;</code> 来声明模版，也把模版从 phtml 文件中分离到独立的 html 文件中，有利于模版的复用。比如，创建了 ko 的自定义绑定 <code>scope</code> 。上面提到的可以参考 <a href="https://www.hellomagento2.com/magento-2-and-konockoutjs/" target="_blank" rel="noopener">Magento 2 and konockoutjs</a>。还有，<code>&lt;script type="text/x-magento-init"&gt;</code> 也是 Magento 2 的自定义设计（可参考 <a href="https://www.hellomagento2.com/magento-2-javascript-init-ways/" target="_blank" rel="noopener"><code>&lt;script type="text/x-magento-init"</code>&gt;</a>）。</p> <p>既然用到了 jQuery ，那么 jQuery 丰富的插件就绝对是绕不过去的话题。但是 jQuery 的插件并不都是符合 AMD 规范的，所以，我们需要用到 requireJS 的 <code>shim</code> ，参考 <a href="https://www.hellomagento2.com/requirejs-%E7%9A%84-shim-%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">RequireJS 的 shim 用法</a>。</p> <p><em>RequireJS 的 shim 解决的是加载非 AMD 规范模块的问题，并不限于 jQuery 的插件</em></p> <p>我们中文语境中的<strong> jQuery 插件</strong>，可能指的是 jQuery Plugin 或者是 jQuery widget。但是这两者是有差别的，参考 <a href="/jquery-plugin-and-widget" target="_blank">jQuery Plugin and Widget</a>。下面介绍 Magento 2 中的几个术语，是比较容易混淆的概念。</p> <table class="table table-hover"> <thead> <tr> <th>术语</th> <th>描述</th> </tr> </thead> <tbody> <tr> <td>JavaScript component (JS component)</td> <td>Any separate .js file decorated as AMD module。 符合 AMD 规范的 JS 模块，通常都是一个文件一个模块</td> </tr> <tr> <td>Ui component</td> <td>JS component located in the Magento_Ui module, in the app/code/Magento/Ui/view directory. 他是 Magento_Ui 模块中的一组 JS ，位于 app/code/Magento/Ui/view 目录下</td> </tr> <tr> <td>jQuery UI widget</td> <td>A JS component/widget provided by jQuery UI library used in Magento. jQuery UI 中包含的组件，参考 <a href="http://jqueryui.com/" target="_blank" rel="noopener">jQuery UI</a></td> </tr> <tr> <td>jQuery widget</td> <td>Custom widget created using jQuery UI Widget Factory and decorated as AMD module. Many Magento JS components are jQuery widget. 使用 jQuery UI Widget Factory 创建并且符合 AMD 规范的 js 模块， Magento 中许多 js 组件都是 jQuery widget ，参考 <a href="http://devdocs.magento.com/guides/v2.0/javascript-dev-guide/widgets/jquery-widgets-about.html" target="_blank" rel="noopener">Magento jQuery widgets</a></td> </tr> </tbody> </table> <h2 id="参考文档"><a href="#参考文档" name="参考文档"></a>参考文档</h2> <p><a href="http://devdocs.magento.com/guides/v2.0/javascript-dev-guide/javascript/js_overview.html" target="_blank" rel="noopener">JavaScript</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-helper/]]></link>
		<title><![CDATA[magento 2 helper]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>Helpers are classes that can be used anywhere we want,we can use them in controllers,views,modeles and even in other helpers. Helpers are usually created to provide methods for a common functionality.</p> <p>它一般位于 <code>&lt;module_dir&gt;/Helper</code>目录下，常用的文件名是 Data.php<br /> 它继承自 <code>Magento\Framework\App\Helper\AbstractHelper</code></p> <p>因为他的父类已经注入了<code>\Magento\Framework\App\Config\ScopeConfigInterface</code> 所以我们可以在 helper 中使用 <code>$this-&gt;scopeConfig-&gt;getValue()</code> 来获得配置值。</p> <p>在 block 中我们可以通过 <code>$this-&gt;helper('{Vendor}\{Module}\Helper\Data');</code> 来获得 helper 。注意，此处一定是右斜杠。path 是左斜杠。</p> <p>举例：</p> <p>File: ThankIT/HelloWorld/Helper/Data.php</p> <pre><code>&lt;?php namespace ThankIT\HelloWorld\Helper;  use Magento\Framework\App\Helper\AbstractHelper; use Magento\Framework\App\Helper\Context; use Magento\Store\Model\ScopeInterface;  class Data extends AbstractHelper {      const XML_PATH_HELLOWORLD = 'helloworld/general/';      public function __construct(Context $context)     {         parent::__construct($context);     }      public function getConfigValue($field, $storeId = null)     {         return $this-&gt;scopeConfig-&gt;getValue(             $field, ScopeInterface::SCOPE_STORE, $storeId         );     }      public function getGeneralConfig($code, $storeId = null)     {         return $this-&gt;getConfigValue(self::XML_PATH_HELLOWORLD . $code, $storeId);     }  } </code></pre> <p>File: app\code\ThankIT\HelloWorld\view\frontend\templates\index\index.phtml</p> <pre><code>&lt;hr&gt; &lt;h3&gt;get configuration value by helper file&lt;/h3&gt; &lt;?php $helper = $this-&gt;helper('ThankIT\HelloWorld\Helper\Data'); echo $helper-&gt;getConfigValue('helloworld/general/display_text'); echo '&lt;br/&gt;'; echo $helper-&gt;getGeneralConfig('display_text'); </code></pre> <p>参考 <a href="https://www.hellomagento2.com/system-xml-configuration/">System.xml Configuration</a></p> 			</div>]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/ui-components-%E5%AE%8C%E6%95%B4%E6%A1%88%E4%BE%8B/]]></link>
		<title><![CDATA[UI components 完整案例]]></title>
		<content><![CDATA[ 	<div class="entry-media"><img width="1893" height="967" src="https://www.hellomagento2.com/wp-content/uploads/2017/11/uicomponents-complete.gif" class="attachment-post-thumbnail size-post-thumbnail wp-post-image" alt="" /></div>	<div class="entry-content"> 		<h2 id="题外话"><a href="#题外话" name="题外话"></a>题外话</h2> <p>目前 <a href="https://devdocs.magento.com/guides/v2.2/ui_comp_guide/bk-ui_comps.html" target="_blank" rel="noopener">Magento 2 官网上关于 UI components 的介绍文档</a> 依然不够实用，如果要实践还是要依靠社区内容，以及自己参考 Magento 2 自带的模块。</p> <p>之前发布了两篇关于 UI components 的文章，一篇是 Alan Storm 的 <a href="/alan_magento_2_introducing_ui_components/">Magento 2 的 UI Components 介绍（翻译）</a>，另一篇是 <a href="/how-to-create-admin-grid-in-magento-2/">How to Create Admin Grid in Magento 2</a>，但这篇文章只用到了 Listing component ，没有继续下去，完成完整的增删改查。此外，该文章末尾的参考文档，其实是很有参考价值的，博主深挖到了文档对应 github 地址。</p> <p>文档：<a href="https://www.mageplaza.com/magento-2-module-development/create-admin-grid-magento-2.html" target="_blank" rel="noopener">How to Create Admin Grid in Magento 2</a><br /> 代码：<a href="https://github.com/mageplaza/magento-2-sample-module" target="_blank" rel="noopener">mageplaza/magento-2-sample-module</a></p> <p>上面的模块基于 Magento 2.1 ，使用了 ui component 的 listng component ，但是 form 部分是用的是 layout 方式而不是 component 方式。ui components 的 xml 写法 2.1 和 2.2 有一些差别，但是 2.2 兼容 2.1 的写法。</p> <p>比如 2.1.7 中 <code>vendor\magento\module-customer\view\base\ui_component\customer_form.xml</code> 中的写法：</p> <pre><code>    &lt;dataSource name="customer_form_data_source"&gt;         &lt;argument name="dataProvider" xsi:type="configurableObject"&gt;             &lt;argument name="class" xsi:type="string"&gt;Magento\Customer\Model\Customer\DataProvider&lt;/argument&gt;             &lt;argument name="name" xsi:type="string"&gt;customer_form_data_source&lt;/argument&gt;             &lt;argument name="primaryFieldName" xsi:type="string"&gt;entity_id&lt;/argument&gt;             &lt;argument name="requestFieldName" xsi:type="string"&gt;id&lt;/argument&gt;             &lt;argument name="data" xsi:type="array"&gt;                 &lt;item name="config" xsi:type="array"&gt;                     &lt;item name="submit_url" xsi:type="url" path="customer/index/save"/&gt;                     &lt;item name="validate_url" xsi:type="url" path="customer/index/validate"/&gt;                 &lt;/item&gt;             &lt;/argument&gt;         &lt;/argument&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="js_config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/form/provider&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;     &lt;/dataSource&gt; </code></pre> <p>在 2.2.0 版本中是这样的：</p> <pre><code>    &lt;dataSource name="customer_form_data_source"&gt;         &lt;argument name="data" xsi:type="array"&gt;             &lt;item name="js_config" xsi:type="array"&gt;                 &lt;item name="component" xsi:type="string"&gt;Magento_Ui/js/form/provider&lt;/item&gt;             &lt;/item&gt;         &lt;/argument&gt;         &lt;settings&gt;             &lt;validateUrl path="customer/index/validate"/&gt;             &lt;submitUrl path="customer/index/save"/&gt;         &lt;/settings&gt;         &lt;dataProvider class="Magento\Customer\Model\Customer\DataProvider" name="customer_form_data_source"&gt;             &lt;settings&gt;                 &lt;requestFieldName&gt;id&lt;/requestFieldName&gt;                 &lt;primaryFieldName&gt;entity_id&lt;/primaryFieldName&gt;             &lt;/settings&gt;         &lt;/dataProvider&gt;     &lt;/dataSource&gt; </code></pre> <p>该模块在 2.2.0 版本上 di：compile 的时候会报错，主要是因为 2.2.0 中类的变动，后面还会提到，但不影响执行和研究。总的来说，是一个很好的例子，有兴趣的童鞋可以继续研究。</p> <p>本文中项目的出发点是使用 UI components 完成一个完整的增删改查。和参考文档不同的是，form 部分用的是 form component 。</p> <p>具体的功能点如下：</p> <ul> <li>ui listing 的展示、筛选</li> <li>单个记录的增加（form component）</li> <li>单个记录的修改（form component）</li> <li>单个记录的删除</li> <li>批量删除</li> <li>ui listing 的行内批量修改</li> </ul> <p><code>Magento_Ui</code> 模块中的 <code>readme.md</code> 是这样介绍的：<br /> The Magento\Ui module introduces a set of common UI components, which could be used and configured via layout XML files.</p> <p>他是为了统一 UI ，希望可以通过 layout xml 来进行配置和使用。但目前看来模块还够不稳定。</p> <h2 id="实践"><a href="#实践" name="实践"></a>实践</h2> <h3 id="创建一个模块"><a href="#创建一个模块" name="创建一个模块"></a>创建一个模块</h3> <p>创建模块 <code>ThankIT_UIcomponents</code></p> <p>ThankIT\UIcomponents\registration.php</p> <pre><code>&lt;?php \Magento\Framework\Component\ComponentRegistrar::register(     \Magento\Framework\Component\ComponentRegistrar::MODULE,     'ThankIT_UIcomponents',     __DIR__ ); </code></pre> <p>ThankIT\UIcomponents\etc\module.xml</p> <pre><code>&lt;?xml version="1.0"?&gt; &lt;config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd"&gt;     &lt;module name="ThankIT_UIcomponents" setup_version="1.0.0" /&gt; &lt;/config&gt; </code></pre> <h3 id="创建数据表和-model-等"><a href="#创建数据表和-model-等" name="创建数据表和-model-等"></a>创建数据表和 model 等</h3> <p>ThankIT\UIcomponents\Setup\InstallSchema.php</p> <pre><code>&lt;?php namespace ThankIT\UIcomponents\Setup;  class InstallSchema implements \Magento\Framework\Setup\InstallSchemaInterface {     /**      * install tables      *      * @param \Magento\Framework\Setup\SchemaSetupInterface $setup      * @param \Magento\Framework\Setup\ModuleContextInterface $context      * @return void      * @SuppressWarnings(PHPMD.ExcessiveMethodLength)      */     public function install(         \Magento\Framework\Setup\SchemaSetupInterface $setup,         \Magento\Framework\Setup\ModuleContextInterface $context     ) {         $installer = $setup;         $installer-&gt;startSetup();         if (!$installer-&gt;tableExists('thankit_uicomponents_post')) {             $table = $installer-&gt;getConnection()-&gt;newTable(                 $installer-&gt;getTable('thankit_uicomponents_post')             )                 -&gt;addColumn(                     'post_id',                     \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,                     null,                     [                         'identity' =&gt; true,                         'nullable' =&gt; false,                         'primary'  =&gt; true,                         'unsigned' =&gt; true,                     ],                     'Post ID'                 )                 -&gt;addColumn(                     'name',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     255,                     ['nullable =&gt; false'],                     'Post Name'                 )                 -&gt;addColumn(                     'url_key',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     255,                     [],                     'Post URL Key'                 )                 -&gt;addColumn(                     'post_content',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     '64k',                     [],                     'Post Post Content'                 )                 -&gt;addColumn(                     'tags',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     255,                     [],                     'Post Tags'                 )                 -&gt;addColumn(                     'status',                     \Magento\Framework\DB\Ddl\Table::TYPE_INTEGER,                     1,                     [],                     'Post Status'                 )                 -&gt;addColumn(                     'featured_image',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     255,                     [],                     'Post Featured Image'                 )                 -&gt;addColumn(                     'sample_country_selection',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     3,                     [],                     'Post Sample Country Selection'                 )                 -&gt;addColumn(                     'sample_upload_file',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     255,                     [],                     'Post Sample File'                 )                 -&gt;addColumn(                     'sample_multiselect',                     \Magento\Framework\DB\Ddl\Table::TYPE_TEXT,                     '64k',                     [],                     'Post Sample Multiselect'                 )                 -&gt;addColumn(                     'created_at',                     \Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,                     null,                     [],                     'Post Created At'                 )                 -&gt;addColumn(                     'updated_at',                     \Magento\Framework\DB\Ddl\Table::TYPE_TIMESTAMP,                     null,                     [],                     'Post Updated At'                 )                 -&gt;setComment('Post Table');             $installer-&gt;getConnection()-&gt;createTable($table);             $installer-&gt;getConnection()-&gt;addIndex(                 $installer-&gt;getTable('thankit_uicomponents_post'),                 $setup-&gt;getIdxName(                     $installer-&gt;getTable('thankit_uicomponents_post'),                     ['name', 'url_key', 'post_content', 'tags', 'featured_image', 'sample_upload_file'],                     \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_FULLTEXT                 ),                 ['name', 'url_key', 'post_content', 'tags', 'featured_image', 'sample_upload_file'],                 \Magento\Framework\DB\Adapter\AdapterInterface::INDEX_TYPE_FULLTEXT             );         }         $installer-&gt;endSetup();     } } </code></pre> <p>ThankIT\UIcomponents\Model\Post.php</p> <pre><code>&lt;?php namespace ThankIT\UIcomponents\Model; class Post extends \Magento\Framework\Model\AbstractModel {      /**      * Initialize resource model      *      * @return void      */     protected function _construct()     {         $this-&gt;_init('ThankIT\UIcomponents\Model\ResourceModel\Post');     } } </code></pre> <p>ThankIT\UIcomponents\Model\ResourceModel\Post.php</p> <pre><code>&lt;?php namespace ThankIT\UIcomponents\Model\ResourceModel;  class Post extends \Magento\Framework\Model\ResourceModel\Db\AbstractDb {     /**      * Date model      *      * @var \Magento\Framework\Stdlib\DateTime\DateTime      */     protected $_date;      /**      * constructor      *      * @param \Magento\Framework\Stdlib\DateTime\DateTime $date      * @param \Magento\Framework\Model\ResourceModel\Db\Context $context      */     public function __construct(         \Magento\Framework\Stdlib\DateTime\DateTime $date,         \Magento\Framework\Model\ResourceModel\Db\Context $context     ) {         $this-&gt;_date = $date;         parent::__construct($context);     }      /**      * Initialize resource model      *      * @return void      */     protected function _construct()     {         $this-&gt;_init('thankit_uicomponents_post', 'post_id');     }      /**      * before save callback      *      * @param \Magento\Framework\Model\AbstractModel]]></content>
	</node>
	<node>
		<link><![CDATA[https://www.hellomagento2.com/magento-2-%E4%BD%BF%E7%94%A8-grunt-%E7%BC%96%E8%AF%91-less/]]></link>
		<title><![CDATA[Magento 2 使用 Grunt 编译 Less]]></title>
		<content><![CDATA[ 		<div class="entry-content"> 		<p>Magento 2 前端使用 Less ，官方推荐的前端工具是 Grunt 。本文将介绍如何安装 Grunt ，使用流程和遇到的问题。</p> <h2 id="安装-node.js"><a name="安装-node.js" href="#安装-node.js"></a>安装 node.js</h2> <p>由于没有找到 Magento 2 官方对 node.js 的版本要求说明，加上安装过程中遇到了一些奇怪的问题，所以博主尝试了 node.js 不同的安装方式和不同的版本。虽然最终问题解决了，但是博主也还是不能确定 Magento 2 使用 Grunt ，对 Node.js 的版本有没有要求。所以以下仅是个人实验的记录，仅供参考。</p> <p>通过 nvm 来安装 node.js</p> <pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh ]]></content>
	</node>
</data>
